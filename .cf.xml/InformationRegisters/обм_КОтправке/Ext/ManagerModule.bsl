#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	
#Область ПрограммныйИнтерфейс

Процедура Зарегистрировать(пИсходящееСообщение, пУзел, пОбработчикОтправки, пФлагОшибки = Ложь) Экспорт  

	// Проверить заполненность вектора
	Если Не ПроверитьВекторИсходящееОбработчикУзел(пИсходящееСообщение, пУзел, пОбработчикОтправки) Тогда
		Возврат;
		
	КонецЕсли;
	
	блокировка = Новый БлокировкаДанных;
	элементБлок = блокировка.Добавить(общ.Объект_ИмяТаблицы(Метаданные.РегистрыСведений.обм_КОтправке));
	элементБлок.Режим = ?(пФлагОшибки, РежимБлокировкиДанных.Исключительный, РежимБлокировкиДанных.Разделяемый);
	элементБлок.УстановитьЗначение("ИсходящееСообщение", пИсходящееСообщение);
	элементБлок.УстановитьЗначение("ОбработчикОтправки", пОбработчикОтправки);
	элементБлок.УстановитьЗначение("Узел", пУзел);
	
	Попытка
		НачатьТранзакцию();
		блокировка.Заблокировать();
		запись = РегистрыСведений.обм_КОтправке.СоздатьМенеджерЗаписи();
		запись.ИсходящееСообщение = пИсходящееСообщение;
		запись.ОбработчикОтправки = пОбработчикОтправки;
		запись.Узел = пУзел;
		
		запись.Прочитать();
		
		Если Не запись.Выбран() Тогда
			запись.ДатаВремя = ТекущаяДатаСеанса();
			
		КонецЕсли;
		
		запись.ФлагОшибкиОтправки = пФлагОшибки;
		
		запись.Записать(Истина); 
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;

КонецПроцедуры

Функция ИсходящееСообщение_Отправить(пИсходящееСообщение, пУзел, пОбработчикОтправки, пУдалитьРегистрацию = Истина) Экспорт
	
	имяСобытия = обм.ИмяСобытияЖурналаРегистрации("Отправка.ИсходящееСообщение_Отправить");
	ссылкиПараметров = Новый Массив;
	ссылкиПараметров.Добавить(пИсходящееСообщение);
	ссылкиПараметров.Добавить(пОбработчикОтправки);
	
	комментарийОшибки = "";
	Попытка
		отправитель = Обработки.обм_ИсходящиеСообщения_СозданиеАдресацияОтправка.Создать();
		отправитель.ИсходящееСообщение_Отправить(пИсходящееСообщение, пУзел, пОбработчикОтправки);
		
		естьОшибки = отправитель.ЕстьОшибки();
		
		Если естьОшибки Тогда
			РегистрыСведений.обм_КОтправке.ПоднятьФлагОшибкиОтправки(пИсходящееСообщение, пУзел, пОбработчикОтправки)
			
		Иначе
			Если пУдалитьРегистрацию Тогда
				РегистрыСведений.обм_КОтправке.УдалитьРегистрацию(пИсходящееСообщение, пУзел, пОбработчикОтправки);
				
			КонецЕсли;
			
			// В журнале регистрации сделать запись о выгрузке объекта 
			комментарийОшибки = 
				СтрШаблон(
					"Объект %1 выгружен в узел: %2
					|обработчиком: %3",
					пИсходящееСообщение, // %1
					пУзел, // %2
					пОбработчикОтправки // %3
					);
					
			общ.Ошибка_ВЖурналРегистрации(имяСобытия, комментарийОшибки, ссылкиПараметров);

		КонецЕсли;
		
	Исключение
		инфоОшибки = ИнформацияОбОшибке();
		комментарийОшибки = общ.Ошибка_ПодробноеПредставление(инфоОшибки);
		общ.Ошибка_ВЖурналРегистрации(имяСобытия, комментарийОшибки, ссылкиПараметров);
		
	КонецПопытки;
	
	Возврат СокрЛП(комментарийОшибки);
	
КонецФункции

Процедура ПоднятьФлагОшибкиОтправки(пИсходящееСообщение, пУзел, пОбработчикОтправки) Экспорт
	
	Зарегистрировать(пИсходящееСообщение, пУзел, пОбработчикОтправки, Истина);
	
КонецПроцедуры

Процедура СброситьФлагиОшибокОтправки() Экспорт
	
	запрос = Новый Запрос;
	запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Т.ИсходящееСообщение КАК ИсходящееСообщение,
	|	Т.Узел КАК Узел,
	|	Т.ОбработчикОтправки КАК ОбработчикОтправки
	|ИЗ
	|	РегистрСведений.обм_КОтправке КАК Т
	|ГДЕ
	|	Т.ФлагОшибкиОтправки";
	
	выборка = запрос.Выполнить().Выбрать();
	имяТаблицы = общ.Объект_ИмяТаблицы(Метаданные.РегистрыСведений.обм_КОтправке);
	
	Пока выборка.Следующий() Цикл
		Попытка
			Зарегистрировать(выборка.ИсходящееСообщение, выборка.Узел, выборка.ОбработчикОтправки, Ложь);
			
		Исключение
			// При исключении не прервывать обработку, только записать ошибку в журнал регистрации
			// оставшийся флаг ошибки отправки не серьезная проблема, гораздо хуже если из-за
			// облома процесса остануться висеть все флаги ошибок
			инфоОшибки = ИнформацияОбОшибке();
			комментарийОшибки = общ.Ошибка_ПодробноеПредставление(инфоОшибки);
			ЗаписьЖурналаРегистрации(
				обм.ИмяСобытияЖурналаРегистрации("Отправка.СброситьФлагиОшибокОтправки"),
				УровеньЖурналаРегистрации.Ошибка,
				Метаданные.РегистрыСведений.обм_КОтправке,
				выборка.ИсходящееСообщение,
				комментарийОшибки,
				РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
				);
				
		КонецПопытки;

	КонецЦикла;
	выборка.Сбросить();
	
КонецПроцедуры

Процедура УдалитьРегистрацию(пИсходящееСообщение, пУзел, пОбработчикОтправки) Экспорт
	
	// Проверить заполненность вектора
	Если Не ПроверитьВекторИсходящееОбработчикУзел(пИсходящееСообщение, пУзел, пОбработчикОтправки) Тогда
		Возврат;
		
	КонецЕсли;
	
	блокировка = Новый БлокировкаДанных;
	элементБлок = блокировка.Добавить(общ.Объект_ИмяТаблицы(Метаданные.РегистрыСведений.обм_КОтправке));
	элементБлок.Режим = РежимБлокировкиДанных.Исключительный;
	элементБлок.УстановитьЗначение("ИсходящееСообщение", пИсходящееСообщение);
	элементБлок.УстановитьЗначение("ОбработчикОтправки", пОбработчикОтправки);
	элементБлок.УстановитьЗначение("Узел", пУзел);
	
	Попытка
		НачатьТранзакцию();
		блокировка.Заблокировать();
		запись = РегистрыСведений.обм_КОтправке.СоздатьМенеджерЗаписи();
		запись.ИсходящееСообщение = пИсходящееСообщение;
		запись.ОбработчикОтправки = пОбработчикОтправки;
		запись.Узел = пУзел;
		
		запись.Прочитать(); 
	
		Если запись.Выбран() Тогда
			запись.Удалить();
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;

КонецПроцедуры

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныйПрограммныйИнтерфейс

Функция ПроверитьВекторИсходящееОбработчикУзел(пИсходящееСообщение, пУзел, пОбработчикОтправки) Экспорт
	
	// Проверить заполненность вектора
	Если
			Не Общ.ЭтоЗаполненнаяСсылка(пОбработчикОтправки, Тип("СправочникСсылка.общ_Обработчики"))
		Или ПустаяСтрока(пУзел)
		Или Не общ.ЭтоЗаполненнаяСсылка(пИсходящееСообщение, Тип("СправочникСсылка.обм_ИсходящиеСообщения"))
	Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти // СлужебныйПрограммныйИнтерфейс

#КонецЕсли // #Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

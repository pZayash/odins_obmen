#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	
#Область ПрограммныйИнтерфейс

Процедура Зарегистрировать(пИсходящееСообщение, пОбработчикОтправки, пУзел, пФлагОшибки = Ложь) Экспорт  

	// Проверить заполненность вектора
	Если Не ПроверитьВекторИсходящееОбработчикУзел(пИсходящееСообщение, пОбработчикОтправки, пУзел) Тогда
		Возврат;
		
	КонецЕсли;
	
	блокировка = Новый БлокировкаДанных;
	элементБлок = блокировка.Добавить(общ.Объект_ИмяТаблицы(Метаданные.РегистрыСведений.обм_КОтправке));
	элементБлок.Режим = ?(пФлагОшибки, РежимБлокировкиДанных.Исключительный, РежимБлокировкиДанных.Разделяемый);
	элементБлок.УстановитьЗначение("ИсходящееСообщение", пИсходящееСообщение);
	элементБлок.УстановитьЗначение("ОбработчикОтправки", пОбработчикОтправки);
	элементБлок.УстановитьЗначение("Узел", пУзел);
	
	Попытка
		НачатьТранзакцию();
		блокировка.Заблокировать();
		запись = РегистрыСведений.обм_КОтправке.СоздатьМенеджерЗаписи();
		запись.ИсходящееСообщение = пИсходящееСообщение;
		запись.ОбработчикОтправки = пОбработчикОтправки;
		запись.Узел = пУзел;
		запись.ДатаВремя = ТекущаяДатаСеанса();
		запись.ФлагОшибкиОтправки = пФлагОшибки;
		
		запись.Записать(Истина); 
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;

КонецПроцедуры

Процедура ПоднятьФлагОшибкиОтправки(пИсходящееСообщение, пОбработчикОтправки, пУзел) Экспорт
	
	Зарегистрировать(пИсходящееСообщение, пОбработчикОтправки, пУзел, Истина);
	
КонецПроцедуры

Процедура СброситьФлагиОшибокОтправки() Экспорт
	
	запрос = Новый Запрос;
	запрос.Текст =
	"ВЫБРАТЬ
	|	Т.ОбработчикОтправки КАК ОбработчикОтправки,
	|	Т.Узел КАК Узел,
	|	Т.ИсходящееСообщение КАК ИсходящееСообщение
	|ИЗ
	|	РегистрСведений.обм_КОтправке КАК Т
	|ГДЕ
	|	Т.ФлагОшибкиОтправки";
	
	выборка = запрос.Выполнить().Выбрать();
	имяТаблицы = общ.Объект_ИмяТаблицы(Метаданные.РегистрыСведений.обм_КОтправке);
	
	Пока выборка.Следующий() Цикл
		Попытка
			Зарегистрировать(выборка.ИсходящееСообщение, выборка.ОбработчикОтправки, выборка.Узел, Ложь);
			
		Исключение
			// При исключении не прервывать обработку, только записать ошибку в журнал регистрации
			// оставшийся флаг ошибки отправки не серьезная проблема, гораздо хуже если из-за
			// облома процесса остануться висеть все флаги ошибок
			инфоОшибки = ИнформацияОбОшибке();
			комментарийОшибки = общ.Ошибка_ПодробноеПредставление(инфоОшибки);
			ЗаписьЖурналаРегистрации(
				обм.ИмяСобытияЖурналаРегистрации("Отправка.СброситьФлагиОшибокОтправки"),
				УровеньЖурналаРегистрации.Ошибка,
				Метаданные.РегистрыСведений.обм_КОтправке,
				выборка.ИсходящееСообщение,
				комментарийОшибки,
				РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
				);
				
		КонецПопытки;

	КонецЦикла;
	выборка.Сбросить();
	
КонецПроцедуры

Процедура УдалитьРегистрацию(пИсходящееСообщение, пОбработчикОтправки, пУзел) Экспорт
	
	// Проверить заполненность вектора
	Если Не ПроверитьВекторИсходящееОбработчикУзел(пИсходящееСообщение, пОбработчикОтправки, пУзел) Тогда
		Возврат;
		
	КонецЕсли;
	
	блокировка = Новый БлокировкаДанных;
	элементБлок = блокировка.Добавить(общ.Объект_ИмяТаблицы(Метаданные.РегистрыСведений.обм_КОтправке));
	элементБлок.Режим = РежимБлокировкиДанных.Исключительный;
	элементБлок.УстановитьЗначение("ИсходящееСообщение", пИсходящееСообщение);
	элементБлок.УстановитьЗначение("ОбработчикОтправки", пОбработчикОтправки);
	элементБлок.УстановитьЗначение("Узел", пУзел);
	
	Попытка
		НачатьТранзакцию();
		блокировка.Заблокировать();
		запись = РегистрыСведений.обм_КОтправке.СоздатьМенеджерЗаписи();
		запись.ИсходящееСообщение = пИсходящееСообщение;
		запись.ОбработчикОтправки = пОбработчикОтправки;
		запись.Узел = пУзел;
		
		запись.Прочитать(); 
	
		Если запись.Выбран() Тогда
			запись.Удалить();
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;

КонецПроцедуры

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныйПрограммныйИнтерфейс

Функция ПроверитьВекторИсходящееОбработчикУзел(пИсходящееСообщение, пОбработчикОтправки, пУзел) Экспорт
	
	// Проверить заполненность вектора
	Если
			Не Общ.ЭтоЗаполненнаяСсылка(пОбработчикОтправки, Тип("СправочникСсылка.общ_Обработчики"))
		Или ПустаяСтрока(пУзел)
		Или Не общ.ЭтоЗаполненнаяСсылка(пИсходящееСообщение, Тип("СправочникСсылка.обм_ИсходящиеСообщения"))
	Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти // СлужебныйПрограммныйИнтерфейс

#КонецЕсли // #Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

// Инструкции сервисам проверки кода по отступлению от стандартов
//
// BSLLS:IncorrectLineBreak-off // Использую свои методы переноса строк
// BSLLS:UsingServiceTag-off // Чтобы не срабатывали проверки на комментарии @skip-check
// 
// Использую имена переменных с маленькой буквы, чтобы понимать область видимости переменной

// Исключения для этого модуля
//
// Это собрание неструктурированных методов, фактически все внешний интерфейс
// Поэтому стандартную структуру модуля здесь не использовать
//@skip-check module-structure-method-in-regions

// Экспортирует таблицу значений в текст в формате CSV
//
// Параметры:
//  пТаблица	 - 	ТаблицаЗначений - Обязательный, таблица значений, которую необходимо преобразовать в CSV
//  пРазделитель	 - 	Строка - необязательный, разделитель полей CSV, по умолчанию ';'
//  пПараметры	 - 	Структура - необязательный, дополнительный параметры процедуры 
//					Возможные значения:
//						ВыводитьИменаКолонок - булево, признак необходимости в первой строке вывести имена колонок, 
//								по умолчанию Истина
//						ВосстановитьПробелыВИменахКолонок - булево, заменить символв '_' в именах колонок на пробел, 
//								по умолчанию Ложь;
//						ФорматДат - строка, форматная строка, которя будет использована для преобразования дат;
//
// Возвращаемое значение:
//  Строка - текст файла CSV
//
// Исходная процедура взята здесь: https://helpf.pro/faq8/view/1818.html
// 
Функция CSV_ПоТаблице(пТаблица, пРазделитель = ";", пПараметры = Неопределено) Экспорт
	
	#Область Инициализация
	
	Если ТипЗнч(пПараметры) <> Тип("Структура") Тогда
		пПараметры = Новый Структура;
		
	КонецЕсли;
	
	выводитьИменаКолонок = Истина;
	Если пПараметры.Свойство("ВыводитьИменаКолонок") Тогда
		выводитьИменаКолонок = пПараметры.ВыводитьИменаКолонок; 
		
	КонецЕсли;
	
	восстановитьПробелыВИменахКолонок = Ложь;
	Если пПараметры.Свойство("ВосстановитьПробелыВИменахКолонок") Тогда
		восстановитьПробелыВИменахКолонок = пПараметры.ВосстановитьПробелыВИменахКолонок;
		
	КонецЕсли; 
	
	форматДат = "";
	пПараметры.Свойство("ФорматДат", форматДат);
	
	#КонецОбласти // Инициализация
	
	массивСтрокCSV = Новый Массив;
		
	Если выводитьИменаКолонок Тогда
		//Если нужно выгружать наименование колонок Выгружаем
		именаКолонок = "";
		Для Каждого колонка Из пТаблица.Колонки Цикл
			имяКолонки = СокрЛП(колонка.Имя);
			Если восстановитьПробелыВИменахКолонок Тогда
				имяКолонки = СтрЗаменить(имяКолонки, "_", " ");
				
			КонецЕсли;
			
			именаКолонок = именаКолонок + имяКолонки + пРазделитель;
			
		КонецЦикла;
		колонка = Неопределено;
		
		именаКолонок = Лев(именаКолонок, СтрДлина(именаКолонок)-1);
		
		массивСтрокCSV.Добавить(именаКолонок);
		
	КонецЕсли; // Если выводитьИменаКолонко
	
	Для Каждого рядТЗ Из пТаблица Цикл
		массивПолейCSV = Новый Массив;
		
		Для Каждого колонка Из пТаблица.Колонки Цикл
			полеCSV = рядТЗ[колонка.Имя];
			
			Если ТипЗнч(полеCSV) = Тип("Дата") Тогда
				Если ЗначениеЗаполнено(форматДат) Тогда
					полеCSV = Формат(полеCSV, форматДат);
					
				Иначе
					полеCSV = XMLСтрока(полеCSV);
					
				КонецЕсли; 
				
			ИначеЕсли ТипЗнч(полеCSV) = Тип("Число") Тогда
				полеCSV = Формат(полеCSV, "ЧН=0; ЧГ=0");
				
			КонецЕсли;
			
			//по правилам CSV если поле содержит двойные ковычки они должны повторятся дважды
			Если Найти(полеCSV,"""") Тогда
				полеCSV = СтрЗаменить(полеCSV,"""","""""");
				
			КонецЕсли;
			
			//по правилам CSV если поле содержит перенос строки или запятую оно должно заключатся в двойные кавычки
			Если Найти(полеCSV, пРазделитель) ИЛИ Найти(полеCSV, Символы.ПС) ИЛИ Найти(полеCSV, """") Тогда
				полеCSV = """" + полеCSV + """";
				
			КонецЕсли;

			массивПолейCSV.Добавить(полеCSV);
			
		КонецЦикла; 
		колонка = Неопределено;
		
		строкаCSV = СтрСоединить(массивПолейCSV, пРазделитель);;
		
		массивСтрокCSV.Добавить(строкаCSV);
		
	КонецЦикла;
	рядТЗ = Неопределено; 
	
	стрCSV = СтрСоединить(массивСтрокCSV, Символы.ПС);

	Возврат стрCSV;

КонецФункции

// Создает файл dbf (XBASE, DBASEIV) на основании таблицы значений
//
// Параметры:
//  пТаблицаЗначений - ТаблицаЗначений - 
// 
// Возвращаемое значение:
//  ДвоичныеДанные - Содержат файл dbf, созданный по таблице значений
//
Функция XBase_ПоТаблице(пТаблицаЗначений) Экспорт 
	
	дбф = Новый XBase;
	
	Для Каждого колонкаИсточник Из пТаблицаЗначений.Колонки Цикл
		
		// Тип создаваемого поля: "N" - число, "S" - строка, "D" - дата, "L" - булево
		типДБФ = "S"; // По умолчанию строка
		длинаДБФ = 254;
		точностьДБФ = 0;
		Если колонкаИсточник.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			типДБФ = "N";
			длинаДБФ = колонкаИсточник.ТипЗначения.КвалификаторыЧисла.Разрядность;
			точностьДБФ = колонкаИсточник.ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти; 
			
			Если длинаДБФ = 0 Тогда
				длинаДБФ = 20;
				точностьДБФ = 5;
				
			КонецЕсли;
			
		ИначеЕсли колонкаИсточник.ТипЗначения.СодержитТип(Тип("Дата")) Тогда
			типДБФ = "D"; 
			
		ИначеЕсли колонкаИсточник.ТипЗначения.СодержитТип(Тип("Булево"))  Тогда
			типДБФ = "L"; 
			
		ИначеЕсли колонкаИсточник.ТипЗначения.СодержитТип(Тип("Строка")) Тогда
			типДБФ = "S";
			длинаДБФ = колонкаИсточник.ТипЗначения.КвалификаторыСтроки.Длина;
			Если длинаДБФ = 0 Тогда
				длинаДБФ = 254; // Максимально допустимая длина строчного поля ДБФ
				
			КонецЕсли;
			
		КонецЕсли;

		дбф.Поля.Добавить(колонкаИсточник.Имя, типДБФ, длинаДБФ, точностьДБФ);
			
	КонецЦикла;
	колонкаИсточник = Неопределено;
	
	// Сократить длину имени файла до 8, иначе dbf его не есть
	путьВрФайла = ПолучитьИмяВременногоФайла("dbf");
	файл = Новый Файл(путьВрФайла);
	короткоеИмяФайла = СтрЗаменить(файл.ИмяБезРасширения, "_", ""); // v8_F069_30 —> v8F06930
	короткоеИмяФайла = Прав(короткоеИмяФайла, 8); // Имя файла dbf должно быть 8 символов, как в православном DOS!
	путьВрФайла = файл.Путь + короткоеИмяФайла + файл.Расширение;
	
	дбф.СоздатьФайл(путьВрФайла);
	дбф.ЗакрытьФайл();
	дбф.ОткрытьФайл(путьВрФайла);
	
	Для Каждого рядИсточник Из пТаблицаЗначений Цикл
		дбф.Добавить();
		ЗаполнитьЗначенияСвойств(дбф, рядИсточник);
		дбф.Записать();
		
	КонецЦикла;
	рядИсточник = Неопределено;

	дбф.ЗакрытьФайл();
	дбф = Неопределено;
	
	двоичныеДанныеДБФ = Новый ДвоичныеДанные(путьВрФайла);
	
	общ.Файл_Удалить(путьВрФайла);
	
	Возврат двоичныеДанныеДБФ;

КонецФункции

Процедура ВЖурнал(пИмяСобытия, пКомментарий, Знач пУровеньЖурнала = Неопределено, 
	Знач пСсылкиДанных = Неопределено) Экспорт
	
	Если ТипЗнч(пУровеньЖурнала) <> Тип("УровеньЖурналаРегистрации") Тогда
		пУровеньЖурнала = УровеньЖурналаРегистрации.Информация;
		
	КонецЕсли;
	
	комментарий = "";
	Если ТипЗнч(пКомментарий) = Тип("ИнформацияОбОшибке") Тогда
		комментарий = общ.Ошибка_ПодробноеПредставление(пКомментарий);
		
	ИначеЕсли ТипЗнч(пКомментарий) = Тип("Строка") Тогда
		комментарий = пКомментарий;
		
	Иначе
		комментарий = Строка(пКомментарий);
		
	КонецЕсли;
	
	ссылкиДанных = Новый Массив;
	Если ТипЗнч(пСсылкиДанных) = Тип("Массив") Тогда
		ссылкиДанных = пСсылкиДанных;
		
	ИначеЕсли ссылкиДанных = Неопределено Тогда
		// Ничего не делать
		
	ИначеЕсли Не ЗначениеЗаполнено(ссылкиДанных) Тогда
		// Ничего не делать
		
	Иначе
		ссылкиДанных.Добавить(пСсылкиДанных);
		
	КонецЕсли;
	
	Если ТранзакцияАктивна() Или ссылкиДанных.Количество() = 0 Тогда
		// Сделать запись в журнал регистрации без привязки к данным
		// Такая запись транзакционно-безопасна
		ЗаписьЖурналаРегистрации(
			пИмяСобытия,
			пУровеньЖурнала,
			,
			,
			комментарий,
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
			);
			
	КонецЕсли;

	уникальныСсылки = Новый Соответствие;
	Для Каждого данныеСсылка Из ссылкиДанных Цикл
		уникальныСсылки.Вставить(данныеСсылка, данныеСсылка);
		
	КонецЦикла;
	данныеСсылка = Неопределено;
	
	// Доп записи для связанных с ошибкой данных
	Для Каждого пара Из уникальныСсылки Цикл
		данныеСсылка = пара.Значение;
		мета = Неопределено;
		Если Не ТранзакцияАктивна() Тогда
			// Попытка выполнить Метаданные.НайтиПоТипу или получить представление ссылки в испорченной транзакции 
			// вызвовет еще одну ошибку т.к. это обращение к базе данных
			// Обращение к базе данных в испорченной транзакции приводит к ошибке:
			// "В данной транзакции уже происходили ошибки"
			// Поэтому доп. записи не делать. Пусть методы, которые выше по стеку находятся перехватывают ошибку 
			// и записывают в журнал регистрации
			данныеСсылка = общ.Ссылка_ПоОбъекту(данныеСсылка);
			Если Не общ.ЭтоЗаполненнаяСсылка(данныеСсылка) Тогда
				Продолжить;
				
			КонецЕсли;
			мета = Метаданные.НайтиПоТипу(ТипЗнч(данныеСсылка));
			
		КонецЕсли;
		
		Если Не общ.ЭтоЗаполненнаяСсылка(данныеСсылка) Тогда
			Продолжить;
			
		КонецЕсли;
		
		ЗаписьЖурналаРегистрации(
			пИмяСобытия,
			пУровеньЖурнала,
			мета,
			данныеСсылка,
			комментарий,
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
			);

	КонецЦикла;
	данные = Неопределено;

КонецПроцедуры

Функция Группа_НайтиСоздать(пИмяГруппы, пТип, пВладелец = Неопределено) Экспорт
	
	// Имя группы должено быть заполненной строкой
	Если ТипЗнч(пИмяГруппы) <> Тип("Строка") Или ПустаяСтрока(пИмяГруппы) Тогда
		Возврат Неопределено;
		
	КонецЕсли; 
	
	корневойТип = общ.КорневойТипКонфигурации(пТип);
	Если корневойТип <> "Справочник" И корневойТип <> "ПланВидовХарактеристик" И корневойТип <> "ПланСчетов" Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	менеджер = общ.Менеджер_ПоОбъекту(пТип);
	мета = менеджер.ПустаяСсылка().Метаданные();
	Если (корневойТип = "Справочник" Или корневойТип = "ПланВидовХарактеристик") И Не мета.Иерархический Тогда
		Возврат Неопределено;
		
	КонецЕсли; 
	
	// 20230811 Заяш
	полеПредставления = "";
	
	Если мета.ДлинаНаименования > 0 Тогда
		полеПредставления = "Наименование";
		
	ИначеЕсли мета.ТипКода = Метаданные.СвойстваОбъектов.ТипКодаСправочника.Строка И мета.ДлинаКода > 0  Тогда
		полеПредставления = "Код";
		
	КонецЕсли;
	
	Если ПустаяСтрока(полеПредставления) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Для подчиненного справочника необходим владелец
	этоПодчиненныйСправочник = 
		корневойТип = "Справочник"
		И мета.Владельцы.Количество() > 0
		;
		
	Если этоПодчиненныйСправочник И Не общ.ЭтоЗаполненнаяСсылка(пВладелец) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	имяТаблицы = общ.Объект_ИмяТаблицы(пТип); 
	
	Если ПустаяСтрока(имяТаблицы) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	запрос = Новый Запрос;
	запрос.УстановитьПараметр("имяГруппы", пИмяГруппы);
	запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Т.Ссылка КАК Ссылка
	|ИЗ
	|	&Т КАК Т
	|ГДЕ
	|	&условиеИерархии
	|	И &условиеВладельца
	|	И Т.Наименование = &ИмяГруппы"; 
	
	запрос.Текст = СтрЗаменить(запрос.Текст, "Т.Наименование", "Т." + полеПредставления);
	
	запрос.Текст = СтрЗаменить(запрос.Текст, "&Т", имяТаблицы);
	
	иерархияГрупп = Ложь;
	Если корневойТип = "Справочник" Или корневойТип = "ПланВидовХарактеристик" Тогда 
		иерархияГрупп = мета.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов;
		
	КонецЕсли;
	
	условиеИерархии = "Истина";
	Если корневойТип = "ПланСчетов" Тогда
		условиеИерархии = "Истина";
		
	ИначеЕсли иерархияГрупп Тогда
		условиеИерархии = "Т.ЭтоГруппа";	
			
	Иначе 
		условиеИерархии = СтрШаблон("Т.Родитель = Значение(%1.ПустаяСсылка)", имяТаблицы);
			
	КонецЕсли; 
	запрос.Текст = СтрЗаменить(запрос.Текст, "&условиеИерархии", условиеИерархии);
	
	условиеВладельца = "Истина";
	Если этоПодчиненныйСправочник Тогда
		условиеВладельца = "Т.Владелец = &владелец";
		запрос.УстановитьПараметр("владелец", пВладелец);
			
	КонецЕсли;
	запрос.Текст = СтрЗаменить(запрос.Текст, "&условиеВладельца", условиеВладельца);

	выборка = запрос.Выполнить().Выбрать();
	
	Если выборка.Следующий() Тогда
		Возврат выборка.Ссылка;
		
	Иначе
		// Если группа не найдена, создать ее 
		Если иерархияГрупп Тогда
			группаОбъект = менеджер.СоздатьГруппу();
			
		ИначеЕсли корневойТип = "ПланСчетов" Тогда
			группаОбъект = менеджер.СоздатьСчет();
			
		Иначе
			группаОбъект = менеджер.СоздатьЭлемент();
			
		КонецЕсли;
		
		группаОбъект.Наименование = пИмяГруппы; 
		Если этоПодчиненныйСправочник Тогда
			группаОбъект.Владелец = пВладелец;
			
		КонецЕсли;
		группаОбъект.Родитель = Неопределено;
		группаОбъект.ОбменДанными.Загрузка = Истина;
		группаОбъект.Записать();
		
		Возврат группаОбъект.Ссылка;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ДатаУниверсальная() Экспорт

	Возврат ТекущаяУниверсальнаяДата();
	
КонецФункции

// Устанавливает ограничения в динамическогм списке на отборы, сортировки и группировку на все поля списка
// для ускорения поиска по строке поиска и уменьшает количество ошибочных настроек пользователя
// убирает из ограничений поля указанные в отборах условного оформления, т.к. это ломает оформление
// 
// Параметры:
//  пДинСписок	- ДинамическийСписок - Динамический список на который устанавливается отбор;
//  пРазрешенныеПоля	- Массив - состоящий из строк-имен полей по которым не устанавливаются ограничения;
// 						- Строка - имена полей, разделенные запятыми;
// 
// Публикация, взятая за основу:
// 		Ускоряем полнотекстовый поиск в динамических списках
// 		https://infostart.ru/1c/articles/1267438
// 
// Автор: PRO100_NigGaZ https://infostart.ru/profile/243518
// Исходное объявление метода:
// Процедура УстановитьОграничениеДинамическогоСписка(Список, РазрешенныеПоля) Экспорт
// 
// Заяш 250918 10:34
Процедура ДинамическийСписок_ОграничениеИспользованияДляУскоренияПоиска(пДинСписок, Знач пРазрешенныеПоля) Экспорт
	
	// Преобразование параметра к массиву, с разделением строки на части
	пРазрешенныеПоля = общ.Массив_ПоЗначению(пРазрешенныеПоля, "Строка", ",");
	
	// Резервные способы обхода ошибок в режиме совместимости выше 8.3.16
	// 1. https://forum.infostart.ru/forum86/topic244747/message3001222/
	//Для Каждого ЭлементОтбора Из Список.КомпоновщикНастроек.ФиксированныеНастройки.Отбор.Элементы Цикл
	//	пРазрешенныеПоля.Добавить(Строка(ЭлементОтбора.ЛевоеЗначение));
	//КонецЦикла;
	//
	// 2. Для формы списка справочника https://forum.infostart.ru/forum86/topic244747/message3004229/
	//пРазрешенныеПоля.Добавить("Ссылка");
	//пРазрешенныеПоля.Добавить("Код");
	//пРазрешенныеПоля.Добавить("Наименование");
	//пРазрешенныеПоля.Добавить("Родитель");
	//пРазрешенныеПоля.Добавить("ЭтоГруппа");
	//пРазрешенныеПоля.Добавить("ПометкаУдаления");
	//пРазрешенныеПоля.Добавить("Предопределенный");
	//пРазрешенныеПоля.Добавить("ИмяПредопределенныхДанных");
		
	// Добавить в разрешенные поля отборы условного оформления
	// Если их отключить, сломается условное оформление
	Для Каждого ЭлементНастроек Из пДинСписок.КомпоновщикНастроек.Настройки.УсловноеОформление.Элементы Цикл
		Для Каждого ЭлементОтбора Из ЭлементНастроек.Отбор.Элементы Цикл
			пРазрешенныеПоля.Добавить(Строка(ЭлементОтбора.ЛевоеЗначение));
		КонецЦикла;
	КонецЦикла;

	МассивПолей = Новый Массив;
	Для Каждого ЭлементСписка Из пДинСписок.КомпоновщикНастроек.Настройки.ДоступныеПоляВыбора.Элементы Цикл
		Если пРазрешенныеПоля.Найти(Строка(ЭлементСписка.Поле)) = Неопределено ИЛИ ЭлементСписка.Папка Тогда
			МассивПолей.Добавить(Строка(ЭлементСписка.Поле));
		КонецЕсли;
	КонецЦикла;
	
	пДинСписок.УстановитьОграниченияИспользованияВГруппировке(МассивПолей);
	пДинСписок.УстановитьОграниченияИспользованияВОтборе(МассивПолей);
	пДинСписок.УстановитьОграниченияИспользованияВПорядке(МассивПолей);
	
КонецПроцедуры // УстановитьОграничениеДинамическогоСписка()

// Возвращает первый элемент из массива, который является заполненным значением или объектом.
// В параметр можно передать любое значение, оно будет преобразовано в массив и безопасно обработано
//
// Параметры:
//   пПараметр - Произвольный - значение, которое может быть преобразовано в массив.
//     см. Модуль.Массив_ПоЗначению
//
// Возвращаемое значение:
//   Произвольный - первый заполненный элемент массива или объект,
//     либо Неопределено, если таких элементов не найдено.
//
Функция Значение_ПоМассиву(пПараметр) Экспорт
	
	массив = Массив_ПоЗначению(пПараметр);
	
	Для Каждого элемент Из массив Цикл
		осд = ОбъектСсылкаДругое(элемент);
		Если осд = "Объект" Или ЗначениеЗаполнено(элемент) Тогда
			Возврат элемент;
			
		КонецЕсли;
		
	КонецЦикла;
	элемент = Неопределено;
	
	Возврат Неопределено;
	
	
КонецФункции

Функция ЕслиПустое(пПроверяемоеЗначение, пЗначениеЗамены) Экспорт
	
	Если Не ЗначениеЗаполнено(пПроверяемоеЗначение) Тогда
		пПроверяемоеЗначение = пЗначениеЗамены;
		
	КонецЕсли;
	
	Возврат пПроверяемоеЗначение;
	
КонецФункции

Функция ИдентификаторСеанса() Экспорт
	
	Возврат общ_Кэш.ИдентификаторСеанса();
	
КонецФункции

#Область Интерфейсы

Функция Интерфейс_НайтиРеализации(пИнтерфейс, пВернутьСсылки = Ложь) Экспорт
	
	метаданныеИнтерфейса = Неопределено;
	Если типЗнч(пИнтерфейс) = Тип("ОбъектМетаданных") Тогда
		метаданныеИнтерфейса = пИнтерфейс;
		
	ИначеЕсли общ.КорневойТипКонфигурации(пИнтерфейс) = "Обработка" Тогда
		метаданныеИнтерфейса = пИнтерфейс.Метаданные();
		
	КонецЕсли;	
	
	ссылкиНаРеализации = Новый Массив;
	реализацииИнтерфейса = Новый Массив;
	Если ТипЗнч(метаданныеИнтерфейса) <> Тип("ОбъектМетаданных") Тогда
		Возврат реализацииИнтерфейса;
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	запрос = Новый Запрос;
	запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Т.Ссылка КАК Ссылка,
	|	Т.ВерсияДанных КАК ВерсияДанных
	|ИЗ
	|	Справочник.общ_Обработчики КАК Т
	|ГДЕ
	|	Т.ПометкаУдаления = ЛОЖЬ";
	
	выборка = запрос.Выполнить().Выбрать();

	Пока выборка.Следующий() Цикл
		кандидат = Справочники.общ_Обработчики.ОбработчикОдиночка(выборка.Ссылка, выборка.ВерсияДанных);
		
		Если кандидат = Неопределено Тогда
			Продолжить;
			
		КонецЕсли;
		
		Если кандидат.РеализованИнтерфейс(метаданныеИнтерфейса) Тогда
			реализацииИнтерфейса.Добавить(кандидат);
			ссылкиНаРеализации.Добавить(выборка.Ссылка);
			
		КонецЕсли;

	КонецЦикла;
	выборка = Неопределено;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Если пВернутьСсылки Тогда
		Возврат ссылкиНаРеализации;
		
	КонецЕсли;
	
	Возврат реализацииИнтерфейса;
	
КонецФункции

Функция Интерфейс_УстановитьРеализацию(пИнтерфейс, пРеализация) Экспорт
	реализация = Неопределено;
	Если типЗнч(пРеализация) = Тип("СправочникСсылка.общ_Обработчики") Тогда
		реализация = Справочники.общ_Обработчики.ОбработчикОдиночка(пРеализация, пРеализация.ВерсияДанных);
		
	Иначе
		реализация = пРеализация;
		
	КонецЕсли;
	
	метаданныеИнтерфейса = Метаданные.НайтиПоТипу(ТипЗнч(пИнтерфейс));
	
	Попытка
		Если Не пРеализация.РеализованИнтерфейс(метаданныеИнтерфейса) Тогда
			ссылкаНаРеализацию = Справочники.общ_Обработчики.НайтиСсылку(реализация);
			обОшибке = СтрШаблон(
					"Обработка %1 не является реализацией интерфейса обработки %2",
					ссылкаНаРеализацию, // %1
					метаданныеИнтерфейса.Имя // %2
					);
			
			ВызватьИсключение обОшибке;
			
		КонецЕсли;
		
	Исключение
		инфоОшибки = ИнформацияОбОшибке();
		обОшибке = СтрШаблон(
				"Ошибка при установке реализации интерфейса %1
				|по причине:
				|%2",
				метаданныеИнтерфейса.Имя, // %1
				ОбработкаОшибок.КраткоеПредставлениеОшибки(инфоОшибки) // %2
					);
					
		ВызватьИсключение обОшибке;
		
	КонецПопытки;
	
	пИнтерфейс.РеализацияИнтерфейса = пРеализация;
	
КонецФункции

#КонецОбласти // Интерфейсы

Функция ИдентификаторИнформационнойБазы() Экспорт
	
	Возврат общ_Кэш.ИдентификаторИнформационнойБазы();
	
КонецФункции

Функция ИнформационнаяБаза_Имя(Знач пСтрокаСоединенияИнформационнойБазы = Неопределено) Экспорт 
	
	Если ПустаяСтрока(пСтрокаСоединенияИнформационнойБазы) Тогда
		пСтрокаСоединенияИнформационнойБазы = СтрокаСоединенияИнформационнойБазы();
		
	КонецЕсли;
	
	Если ИнформационнаяБаза_Файловая(пСтрокаСоединенияИнформационнойБазы) Тогда
		кодПсевдоЯзыка = "File";
		
	Иначе
		кодПсевдоЯзыка = "Ref";
		
	КонецЕсли;
	
	имяИнформациннойБазы = НСтр(пСтрокаСоединенияИнформационнойБазы, кодПсевдоЯзыка);
	
	Возврат имяИнформациннойБазы;
	
КонецФункции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется пСтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  пСтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБаза_Файловая(Знач пСтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(пСтрокаСоединенияИнформационнойБазы) Тогда
		пСтрокаСоединенияИнформационнойБазы = СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	
	Возврат Найти(Врег(пСтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

Процедура Коллекция_Вставить(пКоллекция, пКлюч, пЗначение) Экспорт
	
	Если ТипЗнч(пКоллекция) = Тип("Соответствие") Тогда
		пКоллекция.Вставить(пКлюч, пЗначение);
	
	ИначеЕсли ТипЗнч(пКоллекция) = Тип("Структура") Тогда
		пКоллекция.Вставить(пКлюч, пЗначение);
		
	КонецЕсли;
	
КонецПроцедуры

Функция Коллекция_ЗаписатьJSONсСортировкой(пКоллекция, пКэш = Неопределено) Экспорт
	
	Возврат JSON_ПоКоллекции(пКоллекция, пКэш);
	
КонецФункции

Функция Коллекция_ЗначениеПоПути(пКоллекция, пПуть, пРазделитель = ".") Экспорт 
	
	Если Не общ.ЭтоКоллекцияКлючЗначение(пКоллекция) Тогда
		Возврат Null;
		
	КонецЕсли;

	ШагиПути = СтрРазделить(пПуть, пРазделитель);
	ВсегоШагов = ШагиПути.Количество();
	СчетчикШагов = 0;
	ЗначениеШага = пКоллекция;
	Для Каждого Шаг Из ШагиПути Цикл
		СчетчикШагов = СчетчикШагов + 1;
		ЭтоПоследнийШаг = СчетчикШагов = ВсегоШагов;
		
		ШагСуществует = общ.Коллекция_Свойство(ЗначениеШага, Шаг, ЗначениеШага);
		
		Если Не ШагСуществует Тогда
			Возврат Null;
			
		КонецЕсли;
		
		// Все шаги кроме последнего должны вернуть коллекцию
		// Иначе дальнейшая обработка не имеет смысла
		Если Не ЭтоПоследнийШаг И Не общ.ЭтоКоллекцияКлючЗначение(ЗначениеШага) Тогда
			Возврат Null;
			
		КонецЕсли;
		
		// Последний шаг содержит искомое значение
		Если ЭтоПоследнийШаг Тогда
			Возврат ЗначениеШага;
			
		КонецЕсли;
		
	КонецЦикла;
	Шаг = Неопределено; 
	
	Возврат Null;
	
КонецФункции

Функция Коллекция_ПоЗначению(пЗначение) Экспорт 
	коллекция = Новый Соответствие;
	Если Общ.ЭтоКоллекцияКлючЗначение(пЗначение) Тогда
		коллекция = пЗначение;
		
	ИначеЕсли ТипЗнч(пЗначение) = Тип("Строка") И Не ПустаяСтрока(пЗначение) Тогда
		именаСвойств = СтрРазделить(пЗначение, ",", Ложь);
		Для Каждого имяСвойства Из именаСвойств Цикл
			стрКлюч = СокрЛП(имяСвойства);
			коллекция.Вставить(стрКлюч, стрКлюч);
			
		КонецЦикла;
		имяСвойства = Неопределено;
		
	КонецЕсли; 
	
	Возврат коллекция;
	
КонецФункции

// Функция предназначена для создания структуры из строки ТЗ
// Ключи структуры соответствуют именам колонок
// Значения структуры соответствуют значенимя колонок
//
// Параметры:
//		СтрокаТЗ - Обязательный, строка таблицы значений
//
// Возвращает 
//		Струкутуру 
//
Функция Коллекция_ПоТаблице(пПараметр) Экспорт
	
	Если ТипЗнч(пПараметр) = Тип("ТаблицаЗначений") Тогда
		таблица = пПараметр;
		
		Если таблица.Количество() = 0 Тогда
			Возврат Неопределено;
			
		КонецЕсли;
		
		результат = Новый Массив;
		Для Каждого рядТаблицы Из таблица Цикл 
			образРяда = Коллекция_ПоТаблице(рядТаблицы);
			результат.Добавить(образРяда);
		КонецЦикла;
		рядТаблицы = Неопределено;
		
		Возврат результат;
		
	ИначеЕсли ТипЗнч(пПараметр) = Тип("СтрокаТаблицыЗначений") Тогда
		рядТаблицы = пПараметр;
		таблица = рядТаблицы.Владелец();
		
		Если таблица.Колонки.Количество() = 0 Тогда
			Возврат Неопределено;
			
		КонецЕсли;
		
		образРяда = Новый Структура;
		Для Каждого колонка из таблица.Колонки Цикл
			образРяда.Вставить(колонка.Имя, рядТаблицы[колонка.Имя]);
			
		КонецЦикла;
		колонка = Неопределено;
		
		Возврат образРяда;
		
	КонецЕсли;
	
	Возврат Неопределено;
		
КонецФункции

// Вспомогательная функция. Сортировать коллекцию не имеет смысла при операциях в программе,
// Но иногда нужно чтобы ключи коллекции при записи в JSON располагались по алфавиту
//
Функция Коллекция_Сортировать(пКоллекция, пСортироватьРекурсивно = Ложь) Экспорт

	Если ТипЗнч(пКоллекция) = Тип("Массив") И пСортироватьРекурсивно Тогда
		ОтсортированныйМассив = Новый Массив;
		Для Каждого ЭлементМассива Из пКоллекция Цикл
			ОтсортированныйЭлемент = Коллекция_Сортировать(ЭлементМассива, пСортироватьРекурсивно);
			ОтсортированныйМассив.Добавить(ОтсортированныйЭлемент);
			
		КонецЦикла;
		ЭлементМассива = Неопределено;
		
		Возврат ОтсортированныйМассив;
		
	ИначеЕсли Типзнч(пКоллекция) = Тип("Массив") Тогда
		Возврат пКоллекция;
		
	ИначеЕсли Проверка_Тип(пКоллекция, "Структура, Соответствие", Ложь) = "" Тогда	
		ТаблицаКлючей = Новый ТаблицаЗначений;
		ТаблицаКлючей.Колонки.Добавить("Ключ");
		
		Для Каждого Пара Из пКоллекция Цикл
			СтрокаТаблицыКлючей = ТаблицаКлючей.Добавить();
			СтрокаТаблицыКлючей.Ключ = Пара.Ключ;
			
		КонецЦикла;
		Пара = Неопределено;   
		
		// Соответсвие выводится в JSON в обратном порядке
		Если ТипЗнч(пКоллекция) = Тип("Соответствие") Тогда
			ТаблицаКлючей.Сортировать("Ключ Убыв");
			
		// Структура выводится в JSON в прямом порядке
		ИначеЕсли ТипЗнч(пКоллекция) = Тип("Структура") Тогда
			ТаблицаКлючей.Сортировать("Ключ");
			
		КонецЕсли;
		
		Если ТипЗнч(пКоллекция) = Тип("Структура") Тогда
			ОтсортированнаяКоллекция = Новый Структура;
			
		Иначе
			ОтсортированнаяКоллекция = Новый Соответствие;
			
		КонецЕсли;
		
		Для Каждого СтрокаТаблицыКлючей Из ТаблицаКлючей Цикл
			Ключ = СтрокаТаблицыКлючей.Ключ;
			Значение = пКоллекция[СтрокаТаблицыКлючей.Ключ]; 
			
			Если пСортироватьРекурсивно И общ.ЭтоКоллекцияКлючЗначение(Значение)	Тогда
				Значение = Коллекция_Сортировать(Значение, пСортироватьРекурсивно);	
			
			КонецЕсли;
			
			ОтсортированнаяКоллекция.Вставить(Ключ, Значение);
			
		КонецЦикла;
		СтрокаТаблицыКлючей = Неопределено; 
		
		Возврат ОтсортированнаяКоллекция;
	
	Иначе
		// Этот вид коллекции не сортируется
		Возврат пКоллекция;

	КонецЕсли;
	
КонецФункции

Функция Коллекция_Свойство(пКоллекция, пКлюч, пНайденноеЗначение = Неопределено) Экспорт
	
	ответПоУмолчанию = Ложь;

	Если ТипЗнч(пКоллекция) = Тип("Массив") Или ТипЗнч(пКоллекция) = Тип("ФиксированныйМассив") Тогда

		Если ТипЗнч(пКлюч) <> Тип("Число") Тогда
			Возврат ответПоУмолчанию;
			
		ИначеЕсли Цел(пКлюч) > пКоллекция.ВГраница() Тогда
			Возврат ответПоУмолчанию;
			
		Иначе
			индекс = Цел(пКлюч);
			пНайденноеЗначение = пКоллекция[индекс];
		
			Возврат Истина;
			
		КонецЕсли;

	ИначеЕсли ТипЗнч(пКоллекция) = Тип("Структура") Или ТипЗнч(пКоллекция) = Тип("ФиксированнаяСтруктура") Тогда
		Возврат пКоллекция.Свойство(пКлюч, пНайденноеЗначение);
			
	ИначеЕсли ТипЗнч(пКоллекция) = Тип("Соответствие") Тогда
		Если пКоллекция[пКлюч] <> Неопределено Тогда
			пНайденноеЗначение = пКоллекция[пКлюч];
			Возврат Истина;
			
		КонецЕсли;
		
		// Обработка случая, когда в соответствие вставлен ключ, но его значение равно "Неопределено"
		// Чтобы проверить такое, запомнить число пар, попытаться удалить пару по ключу
		// и если удаление произошло, значит есть ключ со значением "Неопределено"
		количествоПарДоУдаления = пКоллекция.Количество();
		пКоллекция.Удалить(пКлюч);
		количествоПарПослеУдаления = пКоллекция.Количество();
		естьКлюч = количествоПарДоУдаления > количествоПарПослеУдаления;
		Если естьКлюч Тогда
			пКоллекция.Вставить(пКлюч);
			пНайденноеЗначение = Неопределено;
			Возврат Истина;
			
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(пКоллекция) = Тип("ФиксированноеСоответствие") Тогда
		Если пКоллекция[пКлюч] <> Неопределено Тогда
			пНайденноеЗначение = пКоллекция[пКлюч];
			Возврат Истина;
			
		КонецЕсли;
		
		Для Каждого пара Из пКоллекция Цикл
			Если пара.Ключ = пКлюч Тогда
				пНайденноеЗначение = пара.Значение;
				Возврат Истина;
				
			КонецЕсли;
			
		КонецЦикла;
		пара = Неопределено;
			
	КонецЕсли;
	
	Возврат ответПоУмолчанию;
	
КонецФункции

Функция Коллекция_ЭтоОбразСсылки(пКоллекция) Экспорт 
	
	Если Не общ.ЭтоКоллекцияКлючЗначение(пКоллекция) Тогда
		Возврат Ложь;
		
	КонецЕсли;

	Если 	общ.Коллекция_Свойство(пКоллекция, "_Тип") 
		И 	общ.Коллекция_Свойство(пКоллекция, "_УникальныйИдентификатор") Тогда 
		Возврат Истина;
		
	ИначеЕсли 	общ.Коллекция_Свойство(пКоллекция,  "_ЭтоПеречисление") 
			И 	общ.Коллекция_Свойство(пКоллекция, "_Значение") Тогда
		Возврат Истина;
		
	КонецЕсли;

	Возврат Ложь;
	
КонецФункции

Функция КорневойТипКонфигурации(Знач пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеТипа = пОбъект;
	Иначе
		Если ТипЗнч(пОбъект) = Тип("ОписаниеТипов") Тогда
			Если пОбъект.Типы().Количество() > 0 Тогда 
				пОбъект = пОбъект.Типы()[0];
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		Если ТипЗнч(пОбъект) = Тип("Тип") Тогда
			МетаданныеТипа = Метаданные.НайтиПоТипу(пОбъект);
		Иначе
			МетаданныеТипа = Метаданные.НайтиПоТипу(ТипЗнч(пОбъект));
		КонецЕсли;
	КонецЕсли;
	Если МетаданныеТипа <> Неопределено Тогда 
		МассивФрагментов = СтрРазделить(МетаданныеТипа.ПолноеИмя(),".");
		Если МассивФрагментов.Количество() = 2 Тогда 
			Возврат МассивФрагментов[0];
		Иначе
			// Ссылка на субобъект
		КонецЕсли;
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции // ЛксПолучитьКорневойТипКонфигурации()

// Проверяет, является ли строка именем корневого типа объекта БД.
//
// Параметры:
//  пИмяКорневогоТипа - Строка, Неопределено - имя корневого типа.
//
// Возвращаемое значение:
//  Истина       – тип является корневым типом объекта БД;
//  Ложь         – иначе.
//
// 20140121 Заяш 
// Автор TormozIT
// Взято из подсистемы "ИнструментыРазработчика"
// ирГлобальный.ЛксЛиКорневойТипОбъектаБД
//
Функция КорневойТипКонфигурации_Проверить(пКорневойТип) Экспорт

	результат = Ложь
		ИЛИ пКорневойТип = "БизнесПроцесс" 
		ИЛИ пКорневойТип = "Задача" 
		ИЛИ пКорневойТип = "Документ"
		ИЛИ пКорневойТип = "Перечисление"
		ИЛИ пКорневойТип = "ПланВидовРасчета" 
		ИЛИ пКорневойТип = "ПланВидовХарактеристик" 
		ИЛИ пКорневойТип = "ПланОбмена"
		ИЛИ пКорневойТип = "ПланСчетов" 
		ИЛИ пКорневойТип = "Справочник"
		;
		
	Возврат результат;

КонецФункции // ЛксЛиКорневойТипОбъектаБД()

// Преобразует переданное значение в массив.
// Если значение уже является массивом, возвращает его.
// Если значение является строкой и задан разделитель, разбивает строку по разделителю.
// В противном случае создает массив из одного элемента.
// Дополнительно может отфильтровать элементы массива по заданным типам.
//
// Параметры:
//   пЗначение - Произвольный - значение, которое необходимо преобразовать в массив.
//   пТипыДляОтбораЭлементов - Массив из Строка - (Необязательный) массив строковых представлений типов,
//     по которым будут отбираться элементы. Например, "Строка", "Число".
//     Если не указан, отбор не производится.
//   пРазделительЗначений - Строка - (Необязательный) разделитель для строки, если пЗначение является строкой.
//     Если не указан или пустая строка, строка не будет разбиваться.
//
// Возвращаемое значение:
//   Массив - массив, полученный из пЗначение, возможно, отфильтрованный по типам.
//
Функция Массив_ПоЗначению(пЗначение, пТипыДляОтбораЭлементов = Неопределено, 
		пРазделительЗначений = Неопределено) Экспорт
	
	результат = Новый Массив;
	Если ТипЗнч(пЗначение) = Тип("Массив") Или ТипЗнч(пЗначение) = Тип("ФиксированныйМассив") Тогда
		результат = пЗначение;
		
	ИначеЕсли ТипЗнч(пЗначение) = Тип("Строка") И Не ПустаяСтрока(пРазделительЗначений) Тогда
		результат = СтрРазделить(пЗначение, пРазделительЗначений);
		
	Иначе
		результат.Добавить(пЗначение);
		
	КонецЕсли;
	
	Если пТипыДляОтбораЭлементов = Неопределено Тогда
		Возврат результат;
		
	КонецЕсли;
	
	результатСОтбором = Новый Массив;
	Для Каждого элемент Из результат Цикл
		Если общ.Проверка_Тип(элемент, пТипыДляОтбораЭлементов, Ложь) = "" Тогда
			результатСОтбором.Добавить(элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	элемент = Неопределено;
	
	Возврат результатСОтбором;
	
КонецФункции

// Определяет, реализован ли метод у объекта.
//
// Параметры:
//   пОбъект - Произвольный - Объект, у которого проверяется наличие метода.
//   пИмяМетода - Строка - Имя метода, наличие которого проверяется.
//
// Возвращаемое значение:
//   Булево - Истина, если метод реализован у объекта, Ложь в противном случае.
//   Для Объект = Неопределено возвращает Ложь, работает только для русского и английского языков платформы
//
// 20211030 Заяш
// Автор TormozIT
// Взято из подсистемы "ИнструментыРазработчика"
// ирОбщий.МетодРеализованЛкс
//
Функция МетодРеализован(пОбъект, пИмяМетода) Экспорт
	
	Если пОбъект = Неопределено Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	Выражение = "пОбъект." + пИмяМетода + "("
		+ ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"
		+ ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)"		;
	
	Попытка
		Выполнить(Выражение);
		
	Исключение
		Инфо = ИнформацияОбОшибке();
		описаниеОшибки = Инфо.Описание;
		
	КонецПопытки;
	
	подстрокаПоиска = "(" + НРег(пИмяМетода) + ")";
	
	методСуществует = СтрНайти(НРег(описаниеОшибки), подстрокаПоиска) = 0;
	
	Возврат методСуществует;
	
КонецФункции

// Функция возвращает менеджер объекта по переданному значению
// Значение может быть типом или ссылкой
//
// Параметры:
//  пОбъект  - Тип, Ссылка - Обязательный параметр
//           Объект, для которого необходимо определить менеджер
//
// Возвращаемое значение:
//   Произвольный   
//		- менеджер объетка при успешном выполнении (ДокументМенеджер, СправочникМенеджер и т.д.)
//	    или Неопределено, если получение менеджера для переданного значения невозможно
//
// 20140121 Заяш 
//
Функция Менеджер_ПоОбъекту(Знач пОбъект) Экспорт

	Если ТипЗнч(пОбъект) = Тип("Тип") Тогда
		типОбъекта = пОбъект;
	ИначеЕсли ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда
		типОбъекта = Тип_ПоМетаданным(пОбъект);
	Иначе
		типОбъекта = ТипЗнч(пОбъект);
	КонецЕсли;
	
	метаОбъекта = Метаданные.НайтиПоТипу(типОбъекта);
	Если метаОбъекта = Неопределено Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	типСсылки = Тип_ПоМетаданным(метаОбъекта);
	
	имяОбъекта = метаОбъекта.Имя;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат Справочники[имяОбъекта];
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат Документы[имяОбъекта];
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат ПланыВидовХарактеристик[имяОбъекта];
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат ПланыСчетов[имяОбъекта];
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат ПланыВидовРасчета[имяОбъекта];
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат БизнесПроцессы[имяОбъекта];
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат Задачи[имяОбъекта];
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат ПланыОбмена[имяОбъекта];
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(типСсылки) Тогда
		Возврат Перечисления[имяОбъекта];
	Иначе
		Возврат НеОпределено;
	КонецЕсли;

КонецФункции

// Функция получает ссылку, объект которой заведомо не существует в базе
// Т.е. битую ссылку
//
// 20230601 05:56 Павел Заяш
// 
Функция Менеджер_БитаяСсылка(пМенеджер, пКандидат = Неопределено) Экспорт
	
	этоПеречисление = общ.КорневойТипКонфигурации(пМенеджер) = "Перечисление";
	Если этоПеречисление Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	ссылкаРезультат = Неопределено;
	
	// Получить уид кандидата, если возможно
		уид = Неопределено;  
		Если ТипЗнч(пКандидат) = Тип("УникальныйИдентификатор") Тогда
			уид = пКандидат;
			
		ИначеЕсли общ.ОбъектСсылкаДругое(пКандидат) = "Ссылка" Тогда
			уид = пКандидат.УникальныйИдентификатор();
			
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(уид) Тогда
			уид = Неопределено;
			
		КонецЕсли;

	Пока Истина Цикл
		
		Если ТипЗнч(уид) <> Тип("УникальныйИдентификатор") Тогда
			уид = Новый УникальныйИдентификатор;
			
		КонецЕсли;
		
		ссылкаРезультат = пМенеджер.ПолучитьСсылку(уид);
		уид = Неопределено;
		
		Если Ссылка_Существует(ссылкаРезультат) Тогда
			Продолжить;
			
		Иначе
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла; // Пока Истина Цикл
	
	Возврат ссылкаРезультат;
	
КонецФункции

Функция Менеджер_СоздатьОбъект(пМенеджер, Знач пСоздатьГруппу = Ложь) Экспорт 
	
	// Привести параметр к Булево
	пСоздатьГруппу = пСоздатьГруппу = Истина; 
	
	корневойТип = КорневойТипКонфигурации(пМенеджер.ПустаяСсылка());
	
	// Проверить иерархию
	Если пСоздатьГруппу Тогда 
		мета = пМенеджер.ПустаяСсылка().Метаданные(); 
		пСоздатьГруппу = 
				(корневойТип <> "Справочник" ИЛи корневойТип <> "ПланВидовХарактеристик")
			И	мета.Иерархический 
			И	мета.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов
			;

	КонецЕсли;
	
	Если корневойТип = "БизнесПроцесс" Тогда 
		новыйОбъект = пМенеджер.СоздатьБизнесПроцесс();
		
	ИначеЕсли корневойТип = "Задача" Тогда
		новыйОбъект = пМенеджер.СоздатьЗадачу();
		
	ИначеЕсли корневойТип = "Документ" Тогда
		новыйОбъект = пМенеджер.СоздатьДокумент();
		
	ИначеЕсли корневойТип = "ПланВидовРасчета" Тогда 
		новыйОбъект = пМенеджер.СоздатьВидРасчета();
		
	ИначеЕсли корневойТип = "ПланВидовХарактеристик" И пСоздатьГруппу Тогда
		новыйОбъект = пМенеджер.СоздатьГруппу();
			
	ИначеЕсли корневойТип = "ПланВидовХарактеристик" Тогда
		новыйОбъект = пМенеджер.СоздатьЭлемент();

	ИначеЕсли корневойТип = "ПланОбмена" Тогда
		новыйОбъект = пМенеджер.СоздатьУзел();
		
	ИначеЕсли корневойТип = "ПланСчетов" Тогда 
		новыйОбъект = пМенеджер.СоздатьСчет();
		
	ИначеЕсли корневойТип = "Справочник" И пСоздатьГруппу Тогда
		новыйОбъект = пМенеджер.СоздатьГруппу();	
		
	ИначеЕсли корневойТип = "Справочник" Тогда
		новыйОбъект = пМенеджер.СоздатьЭлемент();
		
	КонецЕсли;
	
	Возврат новыйОбъект;
	
КонецФункции

// Безопасное получение навигационной ссылки, 
// не зависит от типа параметра
Функция НавигационнаяСсылка(пОбъект) Экспорт
	
	ссылкаНаОбъект = Ссылка_ПоОбъекту(пОбъект);
	
	Если ссылкаНаОбъект = Неопределено Тогда
		Возврат Неопределено;
		
	КонецЕсли; 
			
	Попытка
		Возврат ПолучитьНавигационнуюСсылку(ссылкаНаОбъект);
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки; 
	
	Возврат Неопределено;
	
КонецФункции

Функция НеРеализовано() Экспорт
	
	ВызватьИсключение "Не реализовано";
	
КонецФункции 

Функция Объект_Метаданные_ЕстьРеквизит(пОбъект, пИмяРеквизита) Экспорт 
	
	объектСсылкаДругое = общ.ОбъектСсылкаДругое(пОбъект);
	
	Если объектСсылкаДругое = "Другое" Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	объектМетаданных = пОбъект.Метаданные();

	Если объектМетаданных.Реквизиты.Найти(пИмяРеквизита) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого СтандартныйРеквизит Из объектМетаданных.СтандартныеРеквизиты Цикл
		Если СтандартныйРеквизит.Имя = пИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	СтандартныйРеквизит = Неопределено;
	
	Возврат Ложь;
	
КонецФункции

Функция Объект_ИмяТаблицы(пОбъект) Экспорт
	
	результат = Неопределено;
	
	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда
		результат = пОбъект.ПолноеИмя(); 
		
	ИначеЕсли ТипЗнч(пОбъект) = Тип("Тип") Тогда
		результат = Общ.Менеджер_ПоОбъекту(пОбъект).ПустаяСсылка().Метаданные().ПолноеИмя();
		
	ИначеЕсли ОбъектСсылкаДругое(пОбъект) <> "Другое" Тогда
		результат = пОбъект.Метаданные().ПолноеИмя();
		
	Иначе 
		результат = Неопределено;
		
	КонецЕсли;
	
	Возврат результат;
	
КонецФункции

// Функция - Объект получить коллекцию ссылок в объекте
//
// Параметры:
//  пОбъектСсылочный					 - Произвольный - Ссылки или объект, в котором необходимо найти другие ссылки 
//  пОписаниеТиповДляРекурсивнойОбработки- ОписаниетТипов - 
//  				Необязательный. Коллекция типов, для которых нужно рекурсивно искать ссылки
//  пКоллекцияОбработанных		 - Соответствие - Не использовать, для рекурсивного вызова функции
//  КоллекцияСсылокВОбъекте				 - Соответствие - Не использовать, для рекурсивного вызова функции 
// 
// Возвращаемое значение:
// Соответствие - Коллекция ссылок в объекте
//
Функция Объект_КоллекцияСсылокВОбъекте(пОбъектСсылочный, пОписаниеТиповДляРекурсивнойОбработки = Неопределено, 
	пКоллекцияОбработанных = Неопределено, КоллекцияСсылокВОбъекте = Неопределено) Экспорт 
	
	Если ТипЗнч(пОписаниеТиповДляРекурсивнойОбработки) <> Тип("ОписаниеТипов") Тогда
		пОписаниеТиповДляРекурсивнойОбработки = Новый ОписаниеТипов;
		
	КонецЕсли;  
	
	Если ТипЗнч(пКоллекцияОбработанных) <> Тип("Соответствие") Тогда
		пКоллекцияОбработанных = Новый Соответствие;
		
	КонецЕсли;
	
	Если ТипЗнч(КоллекцияСсылокВОбъекте) <> Тип("Соответствие") Тогда
		КоллекцияСсылокВОбъекте = Новый Соответствие; 
		
	КонецЕсли; 
	
	// Проверки, предотвращение бесконечной рекурсии
	Если 
			общ.ОбъектСсылкаДругое(пОбъектСсылочный) = "Другое" // Не ссылка
		Или общ.Коллекция_Свойство(пКоллекцияОбработанных, пОбъектСсылочный.Ссылка) // Объект уже выгружен	
	Тогда
		Возврат КоллекцияСсылокВОбъекте;
		
	КонецЕсли;  

	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗнч(пОбъектСсылочный)); 
	
	Если МетаданныеОбъекта = Неопределено Тогда
		Возврат КоллекцияСсылокВОбъекте;
		
	КонецЕсли;
	
	// Ссылка на сам объект
	КоллекцияСсылокВОбъекте.Вставить(пОбъектСсылочный.Ссылка, пОбъектСсылочный.Ссылка);
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		ЗначениеРеквизита = пОбъектСсылочный[Реквизит.Имя];
		Если общ.ОбъектСсылкаДругое(ЗначениеРеквизита) <> "Другое" И ЗначениеЗаполнено(ЗначениеРеквизита.Ссылка) Тогда
			КоллекцияСсылокВОбъекте.Вставить(ЗначениеРеквизита.Ссылка, ЗначениеРеквизита.Ссылка);
			
			// Если реквизит находится в коллекции выгружаемых по сслке, рекурсивно выгрузить его
			ВыгружатьПоСсылке = пОписаниеТиповДляРекурсивнойОбработки.СодержитТип(ТипЗнч(ЗначениеРеквизита)); 
				
			Если ВыгружатьПоСсылке Тогда
				Объект_КоллекцияСсылокВОбъекте(
					ЗначениеРеквизита,
					пОписаниеТиповДляРекурсивнойОбработки,
					пКоллекцияОбработанных,
					КоллекцияСсылокВОбъекте
					);
					
			КонецЕсли;
				
		КонецЕсли;
			
	КонецЦикла;

	Для Каждого МетаданныеТЧ Из МетаданныеОбъекта.ТабличныеЧасти Цикл
		ТЧ = пОбъектСсылочный[МетаданныеТЧ.Имя];
		
		Для Каждого СтрокаТЧ Из ТЧ Цикл
			Для Каждого РеквизитТЧ Из МетаданныеТЧ.Реквизиты Цикл 
				ЗначениеРеквизита = СтрокаТЧ[РеквизитТЧ.Имя];
				Если 	общ.ОбъектСсылкаДругое(ЗначениеРеквизита) <> "Другое" 
					И 	ЗначениеЗаполнено(ЗначениеРеквизита.Ссылка) Тогда
					КоллекцияСсылокВОбъекте.Вставить(ЗначениеРеквизита.Ссылка, ЗначениеРеквизита.Ссылка);
					
					// Если реквизит находится в коллекции выгружаемых по сслке, рекурсивно выгрузить его
					ВыгружатьПоСсылке = пОписаниеТиповДляРекурсивнойОбработки.СодержитТип(ТипЗнч(ЗначениеРеквизита)); 
						
					Если ВыгружатьПоСсылке Тогда
						Объект_КоллекцияСсылокВОбъекте(
							ЗначениеРеквизита,
							пОписаниеТиповДляРекурсивнойОбработки,
							пКоллекцияОбработанных,
							КоллекцияСсылокВОбъекте
							);
							
					КонецЕсли;
					
				КонецЕсли;

			КонецЦикла;
			РеквизитТЧ = Неопределено;
			
		КонецЦикла;
		СтрокаТЧ = Неопределено;
		
	КонецЦикла;
	МетаданныеТЧ = Неопределено; 
	
	пКоллекцияОбработанных.Вставить(пОбъектСсылочный.Ссылка);

	Возврат КоллекцияСсылокВОбъекте;	
	
КонецФункции

Функция Объект_ПоТипу(пТипСсылкиОбъекта, пСсылка = Неопределено, Знач пУИДКандидат = Неопределено, 
	пЭтоГруппа = Неопределено) Экспорт
	
	Проверка_Тип(пТипСсылкиОбъекта, Тип("Тип"));

	менеджер = Менеджер_ПоОбъекту(пТипСсылкиОбъекта);
	
	Если общ.ЭтоЗаполненнаяСсылка(пСсылка, пТипСсылкиОбъекта)  Тогда
		Если общ.Ссылка_Существует(пСсылка) Тогда
			Возврат пСсылка.ПолучитьОбъект();

		// Если ссылка битая
		// То создать новый объект и установить ему ссылку нового
		Иначе
			новыйОбъект = Менеджер_СоздатьОбъект(менеджер);
			новыйОбъект.УстановитьСсылкуНового(пСсылка);
			Возврат новыйОбъект;
			
		КонецЕсли;
		
	КонецЕсли;

	// Нужно создать заведомо не используемую в БД ссылку, битую ссылку
	// и по возможности использовать УИД-кандидат
	уидКандидат = Неопределено;
	Если ТипЗнч(пУИДКандидат) = Тип("УникальныйИдентификатор") Тогда
		уидКандидат = пУИДКандидат;
			
	ИначеЕсли общ.Строка_ЭтоУникальныйИдентификатор(пУИДКандидат) Тогда
		уидКандидат = Новый УникальныйИдентификатор(пУИДКандидат);
			
	КонецЕсли;
		
	Если ТипЗнч(уидКандидат) <> Тип("УникальныйИдентификатор") Или Не ЗначениеЗаполнено(уидКандидат) Тогда
		уидКандидат = Новый УникальныйИдентификатор;
			
	КонецЕсли;
	
	ссылкаНового = Менеджер_БитаяСсылка(менеджер, уидКандидат);
	новыйОбъект = Менеджер_СоздатьОбъект(менеджер, пЭтоГруппа);
	новыйОбъект.УстановитьСсылкуНового(ссылкаНового);
	
	Возврат новыйОбъект;
	
КонецФункции

Функция ОбъектСсылкаДругое(пОбъект) Экспорт
	
	ВариантыРезультата = Новый ФиксированнаяСтруктура("Объект, Ссылка, Другое", "Объект", "Ссылка", "Другое");
	
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(пОбъект));

	Если ТипЗнч(ОбъектМетаданных) <> Тип("ОбъектМетаданных") Тогда
		Возврат ВариантыРезультата.Другое;
		
	КонецЕсли;

	Если КорневойТипКонфигурации(ОбъектМетаданных) = Неопределено Тогда
		Возврат ВариантыРезультата.Другое;
		
	КонецЕсли;

	Если ЭтоСсылка(пОбъект) Тогда
		Возврат ВариантыРезультата.Ссылка;
		
	Иначе
		Возврат ВариантыРезультата.Объект;
		
	КонецЕсли;
	
	Возврат ВариантыРезультата.Другое;	
	
КонецФункции

Функция ОписаниеТиповСтроки(ДлинаСтроки = 1000) Экспорт

	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));

КонецФункции // ОписаниеТиповСтроки()

Процедура Ошибка_ВЖурналРегистрации(пИмяСобытия, пКомментарийОшибки, Знач пСсылкиДанных = Неопределено) Экспорт
	
	комментарийОшибки = "";
	Если ТипЗнч(пКомментарийОшибки) = Тип("ИнформацияОбОшибке") Тогда
		комментарийОшибки = общ.Ошибка_ПодробноеПредставление(пКомментарийОшибки);
		
	Иначе
		комментарийОшибки = Строка(пКомментарийОшибки);
		
	КонецЕсли;
	
	ВЖурнал(пИмяСобытия, пКомментарийОшибки, УровеньЖурналаРегистрации.Ошибка, пСсылкиДанных);
	
КонецПроцедуры

Функция Ошибка_КраткоеПредставление(пИнфоОшибки) Экспорт 
	
	Если ВерсияПлатформыНеНижеУказанной("8.3.17.0") Тогда
		Возврат ОбработкаОшибок.КраткоеПредставлениеОшибки(пИнфоОшибки);
		
	КонецЕсли;
	
	Возврат КраткоеПредставлениеОшибки(пИнфоОшибки);
	
КонецФункции

// Эмуляция системной функции ОписаниеОшибки,
// Которая доступна только внутри операторных скобок Исключение-КонецПопытки
Функция Ошибка_Описание(пИнфоОшибки) Экспорт 
	
	Проверка_Тип(пИнфоОшибки, Тип("ИнформацияОбОшибке"));
	
	представлениеОшибки = 
		СтрШаблон(
			"%1
			|{%2(%3)}: %4",
			пИнфоОшибки.Описание, // %1
			пИнфоОшибки.ИмяМодуля, // %2
			пИнфоОшибки.НомерСтроки, // %3
			пИнфоОшибки.ИсходнаяСтрока // %4
			);

	Возврат представлениеОшибки;
	
КонецФункции

Функция Ошибка_ПодробноеПредставление(пИнфоОшибки) Экспорт 
	
	Если ВерсияПлатформыНеНижеУказанной("8.3.17.0") Тогда
		Возврат ОбработкаОшибок.ПодробноеПредставлениеОшибки(пИнфоОшибки);
		
	КонецЕсли;
	
	Возврат ПодробноеПредставлениеОшибки(пИнфоОшибки);
	
КонецФункции

// Функция проверяет тип объекта
// Если тип не соответсвует вызывается исключение, или возвращается сообщение об ошибке.
Функция Проверка_Тип(пЗначение, Знач пПроверяемыйТип, пВызыватьИсключение = Истина) Экспорт
	
	// ПРОВЕРКА ВХОДНЫХ ПАРАМЕТРОВ 
	ожидаемыйТипПараметра2 = Новый ОписаниеТипов("Строка,Тип,ОписаниеТипов");
	Если пПроверяемыйТип = Неопределено Или Не ожидаемыйТипПараметра2.СодержитТип(ТипЗнч(пПроверяемыйТип)) Тогда
		ВызватьИсключение 
			СтрШаблон(
				"Неверный тип параметра #2 '%1'. Параметр может иметь тип 'Строка', 'Тип' или 'ОписаниеТипов'",
				Тип_Представление(пПроверяемыйТип) );
	КонецЕсли;
	
	допустимоНеопределено = ТипЗнч(пПроверяемыйТип) = Тип("Строка") И СтрНайти(ВРЕГ(пПроверяемыйТип), "НЕОПРЕДЕЛЕНО");

	// Привести проверяемый тип к описанию типов
	Если ТипЗнч(пПроверяемыйТип) = Тип("Тип") Тогда
		типыДляОписания = Новый Массив;
		типыДляОписания.Добавить(пПроверяемыйТип);
		пПроверяемыйТип = Новый ОписаниеТипов(типыДляОписания);
		
	ИначеЕсли ТипЗнч(пПроверяемыйТип) = Тип("Строка") Тогда
		пПроверяемыйТип = Новый ОписаниеТипов(пПроверяемыйТип);
		
	КонецЕсли;

	// Обработка массива переменных
	Если ТипЗнч(пЗначение) = Тип("Массив") И Не пПроверяемыйТип.СодержитТип(Тип("Массив")) Тогда
		проверяемыеЗначения = пЗначение;
		
	Иначе
		проверяемыеЗначения = Новый Массив;
		проверяемыеЗначения.Добавить(пЗначение);
		
	КонецЕсли;
	
	// ОСНОВНОЙ АЛГОРИТМ
	индексыПлохихЗначений = Новый Массив;
	индекс = -1;
	Для Каждого значение Из проверяемыеЗначения Цикл
		индекс = индекс + 1;
		Если значение = Неопределено И допустимоНеопределено Тогда
			Продолжить;
			
		КонецЕсли;
		
		значениеСоответствует = значение <> Неопределено И пПроверяемыйТип.СодержитТип(ТипЗнч(значение));
		Если значениеСоответствует Тогда
			Продолжить;
			
		КонецЕсли; 
		
		индексыПлохихЗначений.Добавить(индекс);
		
	КонецЦикла;
	значение = Неопределено;
	
	Если индексыПлохихЗначений.Количество() = 0 Тогда
		Возврат "";
		
	КонецЕсли;

	именаТипов  = Новый Массив;
	Для Каждого Тип Из пПроверяемыйТип.Типы() Цикл
		именаТипов.Добавить(Тип_Представление(Тип));
		
	КонецЦикла;
	
	Если допустимоНеопределено Тогда
		именаТипов.Добавить("Неопределено");
		
	КонецЕсли;
	
	типыСтрокой = СокрЛП(СтрСоединить(именаТипов, Символы.ПС));
	имяТипаЗначения = Тип_Представление(ТипЗнч(значение));
	текстыОшибок = Новый Массив;
	Для Каждого индекс Из индексыПлохихЗначений Цикл
		текстОшибкиЗначения = 
			СтрШаблон(
				"[%1] Тип значения '%2' = '%3' не соответствует допустимому '%4'.",
				Формат(индекс, "ЧГ=0"), // %1
				значение, // %2 
				имяТипаЗначения, // %3
				типыСтрокой);
					
		текстыОшибок.Добавить(текстОшибкиЗначения);
		
	КонецЦикла;
		
	всеОшибки = СтрСоединить(текстыОшибок, Символы.ПС);
	
	Если пВызыватьИсключение Тогда
		ВызватьИсключение всеОшибки;
		
	КонецЕсли;
		
	Возврат всеОшибки;
	
КонецФункции

// @ Клиент-сервер
//
// На основании процедуры модуля унсКлиент.ДобавитьЭлементОтбораКомпоновкиДанныхВКоллекцию
// Из работы Максима Зайцеа https://infostart.ru/1c/tools/93883/ 
// "Подсистема сохранения и восстановления настроек динамических списков"
Функция СКД_Отбор_Копировать(пОтборПриемник, пОтборИсточник) Экспорт 
	
	пОтборПриемник.Элементы.Очистить(); 
	
	// Перенести элементы отбора в массив, чтобы с его помощью избавиться от рекурсивного обхода
	массивИсточника = Новый Массив;
	Для Каждого элементИсточника Из пОтборИсточник.Элементы Цикл
		// Соответствие хранит элемент и его родителя
		местоВставки = пОтборПриемник.Элементы;
		коллекцияЭлементИМестоВставки = ОтборСКД_коллекцияЭлементИМестоВставки(элементИсточника, местоВставки);
		массивИсточника.Добавить(коллекцияЭлементИМестоВставки);
		
	КонецЦикла;
	элементИсточника = Неопределено;
	
	Для Каждого коллекцияЭлементИМестоВставки Из массивИсточника Цикл
		Для Каждого пара Из коллекцияЭлементИМестоВставки Цикл
			элементИсточника = пара.Ключ;
			местоВставки = пара.Значение; 
			Прервать;
			
		КонецЦикла;
		пара = Неопределено;
		
		Если ТипЗнч(элементИсточника) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			новаяГруппаПриемника = местоВставки.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных") );
			ЗаполнитьЗначенияСвойств(новаяГруппаПриемника, элементИсточника);
			Для Каждого элементПотомок Из элементИсточника.Элементы Цикл
				коллекцияПотомокИРодитель = ОтборСКД_коллекцияЭлементИМестоВставки(	элементПотомок, 
																					новаяГруппаПриемника.Элементы	);
				массивИсточника.Добавить(коллекцияПотомокИРодитель);
				
			КонецЦикла;
			элементПотомок = Неопределено;
			
		Иначе // добавляем элемент отбора 
			новыйЭлементПриемника = местоВставки.Добавить( Тип("ЭлементОтбораКомпоновкиДанных") );
			ЗаполнитьЗначенияСвойств(новыйЭлементПриемника, элементИсточника );
			
		КонецЕсли;

	КонецЦикла; 
	коллекцияЭлементИМестоВставки = Неопределено;
	
КонецФункции

	// Вспомогательная функция для СКД_Отбор_Копировать
	Функция ОтборСКД_коллекцияЭлементИМестоВставки(пЭлемент, пРодительЭлемента)
		
		описаниеЭлемента = Новый Соответствие;
		описаниеЭлемента.Вставить(пЭлемент, пРодительЭлемента);
		
		Возврат описаниеЭлемента;
		
	КонецФункции

// Процедура устанавливает отбор СКД. Используется для СКД и отборов динамических списков
//
// Параметры:
//		ОтборСКД
//			Обязательный, отбор СКД или группа элементов отбора компоновки данных
//			Отбор, в котором необходимо установить элемент
//		ЛевоеЗначение
//			Обязательный, Строка или ПолеКомпоновкиДанных
//			Поле, по которому будет происходить отбор
//		ПравоеЗначение
//			Обязательный, произвольный
//			Значение для отбора
//		ВидСравненияСКД
//			Необязательный, ВидСравненияКомпоновкиДанных
//			По умолчанию неопределено
//			Если значение не заполнено, будет взят вид сравнения "Равно".
//		Использование
//			Необязательный, Булево
//			По умолчанию Истина
//			Признак, использовать параметр или нет
// 		ЭлементОтбораДанных
//			Необязательный, не заполнять
//			Нужен для рекурсивной работы процедуры
//
// 20120905103206 Заяш
// 
Процедура СКД_Отбор_Установить(
		ОтборСКД, 
		знач ЛевоеЗначение, 
		знач ПравоеЗначение, 
		ВидСравненияСКД = Неопределено, 
		Использование = Истина, 
		ЭлементОтбораДанных = Неопределено
		) Экспорт
	
	Проверка_Тип(Использование, Тип("Булево"));
	
	Если ТипЗнч(ЛевоеЗначение) = Тип("Строка") Тогда
		ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ЛевоеЗначение);
	КонецЕсли;
	   
	Если ВидСравненияСКД = Неопределено Тогда
		ВидСравненияСКД = ВидСравненияКомпоновкиДанных.Равно;
	КонецЕсли;
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			// Вызвать рекурсивно эту процедуру
			СКД_Отбор_Установить(	ЭлементОтбора, 
									ЛевоеЗначение, 
									ПравоеЗначение, 
									ВидСравненияСКД, 
									Использование, 
									ЭлементОтбораДанных		);
			Продолжить;
		КонецЕсли;
		
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			Если ЭлементОтбораДанных = Неопределено Тогда
				ЭлементОтбораДанных = ЭлементОтбора;
				ЭлементОтбораДанных.ВидСравнения = ВидСравненияСКД;
				ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
				ЭлементОтбораДанных.Использование = Использование;
			Иначе
				ЭлементОтбора.Использование = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Если элемент отбора не найден, добавить новый в корень и установить ему значения
	Если ЭлементОтбораДанных = Неопределено И ТипЗнч(ОтборСКД) = Тип("ОтборКомпоновкиДанных") Тогда
		ЭлементОтбораДанных = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбораДанных.ЛевоеЗначение = ЛевоеЗначение;
		ЭлементОтбораДанных.ВидСравнения = ВидСравненияСКД;
		ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
		ЭлементОтбораДанных.Использование = Использование;
	КонецЕсли;
	
КонецПроцедуры

Процедура СправочникОбъект_УстановитьУИДкакКод(СправочникОбъект) Экспорт

	ИДСтрокой = "";
	
	Если СправочникОбъект.ЭтоНовый() И Не ЗначениеЗаполнено(СправочникОбъект.Ссылка) Тогда
		СсылкаНового = Неопределено;
		
		Если СправочникОбъект.ДополнительныеСвойства.Свойство("СсылкаНового") Тогда
			СсылкаНового = СправочникОбъект.ДополнительныеСвойства.СсылкаНового;
			
		КонецЕсли;
		
		Если
					ТипЗнч(СсылкаНового) <> ТипЗнч(СправочникОбъект.Ссылка)
			 ИЛИ	Не ЗначениеЗаполнено(СсылкаНового)
 		Тогда
			СправочникМенеджер = Менеджер_ПоОбъекту(СправочникОбъект.Ссылка);
			СсылкаНового = СправочникМенеджер.ПолучитьСсылку();
			
		КонецЕсли;

		СправочникОбъект.УстановитьСсылкуНового(СсылкаНового);
		
		ИДСтрокой = Строка(СсылкаНового.УникальныйИдентификатор());
		
	КонецЕсли;
	
	Если СправочникОбъект.ЭтоНовый() Тогда
		СправочникОбъект.ДополнительныеСвойства.Вставить("ЭтоНовый", Истина);
		
	КонецЕсли;

	// Установить код равный уникальному идентификатору
	Если ЗначениеЗаполнено(СправочникОбъект.Ссылка) Тогда
		ИДСтрокой = Строка(СправочникОбъект.Ссылка.УникальныйИдентификатор());
		
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(ИДСтрокой) И СправочникОбъект.Код <> ИДСтрокой Тогда
		СправочникОбъект.Код = ИДСтрокой;
		
	КонецЕсли;
	
КонецПроцедуры

Функция Ссылка_ЕстьРеквизит(Ссылка, знач ИмяРеквизита = "") Экспорт
	
	ИмяРеквизита = СокрЛП(ИмяРеквизита);		
	
	Если Не ЭтоСсылка(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Ссылка_Метаданные = Ссылка.Метаданные();
	
	Если Ссылка_Метаданные.Реквизиты.Найти(ИмяРеквизита) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого СтандартныйРеквизит Из Ссылка_Метаданные.СтандартныеРеквизиты Цикл
		Если СтандартныйРеквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	СтандартныйРеквизит = Неопределено;
	
	Возврат Ложь;

КонецФункции

Функция Ссылка_ЗначениеРеквизита(Ссылка, ИмяРеквизита = "") Экспорт
	
	Если Не ЭтоСсылка(Ссылка) Тогда
		ВызватьИсключение "Параметр #1 должен иметь ссылочный тип";
	КонецЕсли;
	
	// Если ссылка не записана, вернуть неопределено
	Если Не ЗначениеЗаполнено(Ссылка.Ссылка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Если имя реквизита не заполнено, вернем неопределено
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	// Если у документа нет реквизита, вернем неопределено
	Если Не Ссылка_ЕстьРеквизит(Ссылка, ИмяРеквизита) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		СтрШаблон(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|%1 КАК ЗначениеРеквизита 
		|ИЗ %2.%3
		|ГДЕ Ссылка = &Ссылка",
		ИмяРеквизита, // %1
		КорневойТипКонфигурации(Ссылка), // %2
		Ссылка.Метаданные().Имя // %3
		);
	Запрос.УстановитьПараметр("Ссылка", Ссылка.Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ЗначениеРеквизита;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

// Фунция преобразует строку навигационной ссылки и ссылку БД
// https://1c-bezproblem.ru/blog/v-pomoshch-1s-programmistu/1s-poluchit-ssylku-na-ob-ekt-po-navigatsionnoj-ssylke
//
// Параметры:
//  НавигационнаяСсылка	 - Строка - навигационная ссылка 1С 
// 
// Возвращаемое значение:
//  Ссылка - Результат преобразования навигационной ссылки 
//
Функция Ссылка_ПоНавигационнойСсылке(пНавигационнаяСсылка) Экспорт

	Если ТипЗнч(пНавигационнаяСсылка) <> Тип("Строка") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	точка1 = Найти(пНавигационнаяСсылка, "e1cib/data/");
	
	Если точка1 = 0 Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	точка2 = Найти(пНавигационнаяСсылка, "?ref=");
	Если точка2 = Неопределено Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	результат = Неопределено;

	ПредставлениеТипа = Сред(пНавигационнаяСсылка, точка1 + 11, точка2 - точка1 - 11);
	ШаблонЗначения = ЗначениеВСтрокуВнутр(ПредопределенноеЗначение(ПредставлениеТипа + ".ПустаяСсылка"));
	ЗначениеСсылки = СтрЗаменить(	ШаблонЗначения, 
									"00000000000000000000000000000000", 
									Сред(пНавигационнаяСсылка, точка2 + 5)		);
	результат = ЗначениеИзСтрокиВнутр(ЗначениеСсылки); 
	
	Возврат результат;

КонецФункции

Функция Ссылка_ИмяТаблицы(пСсылка) Экспорт
	
	Возврат Объект_ИмяТаблицы(пСсылка);
	
КонецФункции

Функция Ссылка_ПоОбъекту(пОбъект) Экспорт
	
	результат = Неопределено;
	
	объектСсылкаДругое = общ.ОбъектСсылкаДругое(пОбъект);
	
	Если объектСсылкаДругое = "Объект" Тогда
		результат = пОбъект.Ссылка;
		
	ИначеЕсли объектСсылкаДругое = "Ссылка" Тогда 
		результат = пОбъект;
		
	КонецЕсли;
		
	Если Не общ.ЭтоЗаполненнаяСсылка(результат) Тогда
		результат = Неопределено;
		
	КонецЕсли;
	
	Возврат результат;
	
КонецФункции

// Разделяет строку на части по заданному разделителю, удаляя лишние пробелы.
// В результат не попадают пустые строки
//
// Параметры:
//   пСтрока - Строка - исходная строка для разделения
//   пРазделитель - Строка - разделитель, по умолчанию ","
//
// Возвращаемое значение:
//   Массив из Строка - строки, полученные в результате разделения
Функция Строка_РазделитьСокрЛП(пСтрока, пРазделитель = ",") Экспорт
	частиСтроки = СтрРазделить(пСтрока, пРазделитель);
	
	результат = Новый Массив;
	
	Для Каждого часть из частиСтроки Цикл
		часть = СокрЛП(часть);
		Если ПустаяСтрока(часть) Тогда
			Продолжить;
			
		КонецЕсли;
		
		результат.Добавить(часть);
		
	КонецЦикла;
	часть = Неопределено;
	
	Возврат результат;
	
КонецФункции

Функция Ссылка_Существует(пСсылка) Экспорт 
	
	// 20230830 Заяш // Исправлены ошибка, когда в функцию передается перечисление
	корневойТип = Общ.КорневойТипКонфигурации(пСсылка);
	Если корневойТип = "Перечисление" Тогда
		Возврат ЗначениеЗаполнено(пСсылка);
		
	КонецЕсли;
	
	Если Не общ.ЭтоЗаполненнаяСсылка(пСсылка) Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	запроc = Новый Запрос;
	запроc.УстановитьПараметр("СсылкаНаОбъект", пСсылка);
	запроc.Текст = 
		СтрШаблон(
			"Выбрать Таб.Ссылка ИЗ %1 КАК Таб ГДЕ Таб.Ссылка = &СсылкаНаОбъект",
			Объект_ИмяТаблицы(пСсылка),
			);
			
	УстановитьПривилегированныйРежим(Истина);
	
	рез = Не запроc.Выполнить().Пустой();

	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат рез;
	
КонецФункции

Функция Строка_ИзBase64(пСтрокаBase64) Экспорт
	
	дд = Base64Значение(пСтрокаBase64);
	Если дд = Неопределено Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	тмп = ПолучитьИмяВременногоФайла();
	дд.Записать(тмп);
	чтениеТекста = Новый ЧтениеТекста(тмп);
	
	строкаРезультат = чтениеТекста.Прочитать();
	
	чтениеТекста.Закрыть();
	Файл_Удалить(тмп);

	Возврат строкаРезультат;
	
КонецФункции 

// Удаляет сдвоенные пустые строки в тексте
// Параметры:
//  пСтрока	 - Строка - Текст, в котором надо удалить сдвоенные пустые строки
// 
// Возвращаемое значение:
//  Строка - очищенный от двойных строк текст
//
// Заяш 250902 03:14
Функция Строка_УдалитьДвойныеСимволыПС(пТекст) Экспорт
	
	строкиТекста = СтрРазделить(пТекст, Символы.ПС, Ложь);
	индекс = строкиТекста.Количество();
	предыдущаяЧасть = Неопределено;
	Пока индекс > 0 Цикл
		индекс = индекс - 1;
		текущаяЧасть = СокрЛП(строкиТекста[индекс]);
		Если ПустаяСтрока(текущаяЧасть) И ПустаяСтрока(предыдущаяЧасть) Тогда
			строкиТекста.Удалить(индекс);
			Продолжить;
			
		КонецЕсли;
		
		предыдущаяЧасть = текущаяЧасть;
		
	КонецЦикла;
	индекс = Неопределено;
	
	очищенныйТекст = СтрСоединить(строкиТекста, Символы.ПС);
	
	Возврат очищенныйТекст;
	
КонецФункции

Функция Строка_УдалитьНедопустимыеСимволы(стр, ДопустимыеСимволы) Экспорт

	Возврат СтрСоединить(СтрРазделить(стр, СтрСоединить(СтрРазделить(стр, ДопустимыеСимволы))))

КонецФункции

// Проверяет, является ли строка уникальным идентификатором.
// В качестве уникального идентификатора предполагается строка вида
// "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX", где X = [0..9,a..f].
//
// Параметры:
//  Значение - Строка - проверяемая строка.
//
// Возвращаемое значение:
//  Булево - Истина, если переданная строка является уникальным идентификатором.
//
// 20230601 Заяш: функция взята из СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор
//
Функция Строка_ЭтоУникальныйИдентификатор(Знач пСтрока) Экспорт
	
	Если ТипЗнч(пСтрока) <> Тип("Строка") Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(пСтрока) Тогда
		Возврат Ложь;
	КонецЕсли;
	Для Позиция = 1 По СтрДлина(пСтрока) Цикл
		кодСимволаПлохой =  КодСимвола(Шаблон, Позиция) = 88 // X
			И ((КодСимвола(пСтрока, Позиция) < 48 Или КодСимвола(пСтрока, Позиция) > 57) // 0..9
			И (КодСимвола(пСтрока, Позиция) < 97 Или КодСимвола(пСтрока, Позиция) > 102) // a..f
			И (КодСимвола(пСтрока, Позиция) < 65 Или КодСимвола(пСтрока, Позиция) > 70)) // A..F
			Или КодСимвола(Шаблон, Позиция) = 45 И КодСимвола(пСтрока, Позиция) <> 45 // -
			;
			
		Если кодСимволаПлохой Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

Функция Структура_ИзСоответствия(пСоответсвие) Экспорт 
	
	общ.Проверка_Тип(пСоответсвие, "Соответствие");

	структураРезультат = Новый Структура; 
	
	текстJSON = общ.JSON(пСоответсвие);
	чтение = Новый ЧтениеJSON;
	чтение.УстановитьСтроку(текстJSON); 
	структураРезультат = ПрочитатьJSON(чтение, Ложь);
	
	Возврат структураРезультат;
	
КонецФункции

// Функция предназначена для вывода СКД в таблицу значений
// Используется, например, для использования отчета как источника данных
//
// Параметры:
//  пСхемаКомпоновкиДанных	 - СхемаКомпоновкиДанных - Схема, из которой необходимо получить таблицу значений
//  пНастройкиКД			 - НастройкиСхемыКомпоновкиДанных - суть в названии
// 
// Возвращаемое значение:
//  ТаблицаЗначений - результат компоновки СКД
//
Функция Таблица_ПоСКД(пСхемаКомпоновкиДанных, пНастройкиКД) Экспорт
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(	пСхемаКомпоновкиДанных, 
													пНастройкиКД,
													,
													,
													Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений")		);
		
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	тзРезультат = Новый ТаблицаЗначений;
	ПроцессорВывода.УстановитьОбъект(тзРезультат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	Возврат тзРезультат;
	
КонецФункции

// Возвращает количество строк динамического списка
// https://koder.by/poluchit_kolichestvo_strok_dinamicheskogo_spiska.php
//
// Параметры:
//	ЭтаФорма - ФормаКлиентскогоПриложения - Форма клиентского приложения
//	Список - строка - имя динамического списка
//
// Возвращаемое значение:
//	Строка - количество строк в динамическом списке
//
Функция ТаблицаФормыДинамическийСписок_Количество(пТаблицаФормы) Экспорт
	
	//Получаем СКД с текстом запроса:
	СКД_запрос = пТаблицаФормы.ПолучитьИсполняемуюСхемуКомпоновкиДанных();
	//Получаем настройки пользователя (отборы, сортировки и т.п.):
	Настройки = пТаблицаФормы.ПолучитьИсполняемыеНастройкиКомпоновкиДанных();
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных();
	МакетКомпоновки = КомпоновщикМакета.Выполнить(	СКД_запрос, 
													Настройки, 
													, 
													, 
													Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений")		);
	
	Запрос = Новый Запрос;
	Запрос.Текст = МакетКомпоновки.НаборыДанных.НаборДанныхДинамическогоСписка.Запрос;
	
	ПозВыбратьНачало = СтрНайти(Запрос.Текст, "ВЫБРАТЬ ", НаправлениеПоиска.СКонца);
	Пока НЕ ПозВыбратьНачало = 1
		и НЕ Сред(Запрос.Текст, ПозВыбратьНачало - 1, 1) = Символы.ПС Цикл
		ПозВыбратьНачало = СтрНайти(Запрос.Текст, "ВЫБРАТЬ ", НаправлениеПоиска.СКонца, ПозВыбратьНачало - 1);
	КонецЦикла;
	ПозВыбратьКонец = СтрНайти(Запрос.Текст, Символы.ПС,, ПозВыбратьНачало);
	
	СтрокаВЫБРАТЬ = Лев(Запрос.Текст, ПозВыбратьКонец);
	СтрокаИз = Сред(Запрос.Текст, СтрНайти(Запрос.Текст, Символы.ПС + "ИЗ" + Символы.ПС,, ПозВыбратьКонец));
	
	Если СтрНайти(СтрокаИз, Символы.ПС + "СГРУППИРОВАТЬ") Тогда
		СтрокаИз = Лев(СтрокаИз, СтрНайти(СтрокаИз, Символы.ПС + "СГРУППИРОВАТЬ"));
	КонецЕсли;
	
	Запрос.Текст = СтрокаВЫБРАТЬ + "Количество(*) КАК Кол" + СтрокаИз;
	Если СтрНайти(Запрос.Текст, Символы.ПС + "УПОРЯДОЧИТЬ ПО",, ПозВыбратьКонец) Тогда
		Запрос.Текст = Лев(Запрос.Текст, СтрНайти(Запрос.Текст, Символы.ПС + "УПОРЯДОЧИТЬ ПО",, ПозВыбратьКонец));
	КонецЕсли;
	
	Для Каждого парам Из МакетКомпоновки.ЗначенияПараметров Цикл
		Запрос.УстановитьПараметр(парам.Имя, парам.Значение);
	КонецЦикла;

	Выборка = Запрос.Выполнить().Выбрать();
	результат = 0;
	Если Выборка.Следующий() Тогда
		результат = Выборка.Кол;
		
	КонецЕсли;
	
	Возврат результат;
	
КонецФункции

// Функция для преобразования табличного документа в таблицу значений.
// Предполагается, что в первой строке табличного документа содержаться имена колонок.
//
// Параметры
//  ТабличныйДокумент
//		Обязательный, ТабличныйДокумент
//		Табличный документ, который нужно преобразовать в таблицу значений
//
// Возвращаемое значение:
//   ТаблицаЗначений
//
// 20121010 Заяш
//
Функция ТабличныйДокумент_ВТаблицуЗначений(ТабличныйДокумент) Экспорт
	
	ТЗ=Новый ТаблицаЗначений();
	
	//Считываем колонки
	Для Стр=1 По ТабличныйДокумент.ВысотаТаблицы Цикл
		#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
		#КонецЕсли
		Если Стр>1 Тогда
			ТекСтр=ТЗ.Добавить();
		КонецЕсли;
		ПустаяСтрока=истина;
		Для Кол=1 По ТабличныйДокумент.ШиринаТаблицы Цикл
			Яч=ТабличныйДокумент.Область(Стр, Кол);
			Если Яч.СодержитЗначение Тогда
				Зн=Яч.Значение;
			Иначе
				Зн=Яч.Текст;
			КонецЕсли;
			Если ТипЗнч(Зн)=Тип("Строка") И ПустаяСтрока(Зн) Тогда
				Зн=Неопределено;
			КонецЕсли;
			
			//Добавляем колонку
			Если Стр=1 Тогда
				
				// В имени колонки убрать пробелы
				Зн = СокрЛП(Зн);
				Зн = СтрЗаменить(Зн, " ", "_");
				Зн = СтрЗаменить(Зн, Символы.ПС, "");
				Зн = СтрЗаменить(Зн, "-", "");
				Зн = СтрЗаменить(Зн, "№", "_N0_");
				
				// Если в таблице уже есть колонка стаким именем, добавить номер
				Если ТЗ.Колонки.Найти(Зн) <> Неопределено Тогда
					Счетчик = 0;
					
					Пока Истина Цикл
						Счетчик = Счетчик + 1;
						
						ЗнСоСчетчиком = Зн + "_" + Счетчик;
						
						НайденнаяКолонка = ТЗ.Колонки.Найти(ЗнСоСчетчиком);
						
						Если НайденнаяКолонка = Неопределено Тогда
							Зн = ЗнСоСчетчиком;
							Прервать;
							
						Иначе
							Продолжить;
							
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
				ТЗ.Колонки.Добавить(Зн, ОписаниеТиповСтроки(255));
				
			Иначе
				ТекСтр[Кол-1]=Зн;
				
			КонецЕсли;
			
		КонецЦикла;
		Кол = Неопределено;
		
	КонецЦикла;
	Стр = Неопределено;
	
	Возврат ТЗ;
	
КонецФункции // ТабличныйДокумент_ВТаблицуЗначений()

// Возвращает строковое представление типа значения 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
// Параметры:
//  пТип - Тип, произвольный - значение, для которого надо получить представление типа
// 
// Возвращаемое значение:
// 	Строка - представление типа строкой
// 
Функция Тип_Представление(Знач пТип) Экспорт

	Если Не ТипЗнч(пТип) = Тип("Тип") Тогда
		пТип = ТипЗнч(пТип);
	КонецЕсли;
	
	поУмолчанию = Строка(пТип);
	
	Если Не Тип_ЭтоСсылка(пТип) Тогда
		Возврат поУмолчанию;
		
	КонецЕсли;
	
	ПолноеИмя = Метаданные.НайтиПоТипу(пТип).ПолноеИмя();
	ИмяОбъекта = СтрРазделить(ПолноеИмя, ".")[1];
	
	Если Справочники.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "СправочникСсылка";
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "ДокументСсылка";
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "БизнесПроцессСсылка";
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "ПланВидовХарактеристикСсылка";
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "ПланСчетовСсылка";
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "ПланВидовРасчетаСсылка";
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "ЗадачаСсылка";
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "ПланОбменаСсылка";
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(пТип) Тогда
		Представление = "ПеречислениеСсылка";
		
	Иначе
		Возврат поУмолчанию;
		
	КонецЕсли;
	
	Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
	
	Возврат Результат;
	
КонецФункции

Функция Тип_ПоИмениТаблицы(пИмяТаблицы) Экспорт
	
	запрос = Новый Запрос;
	запрос.Текст = СтрШаблон("ВЫБРАТЬ РАЗРЕШЕННЫЕ Значение(%1.ПустаяСсылка) КАК ПустаяСсылка", пИмяТаблицы);
	
	Попытка
		выборка = Запрос.Выполнить().Выбрать();
		Если выборка.Следующий() Тогда 
			рез = ТипЗнч(выборка.ПустаяСсылка);
			Возврат рез;
		КонецЕсли;
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Возврат Неопределено;
	
КонецФункции

// Получает ссылочный тип по метаданным.
//
// Параметры:
//  пМетаданные  – ОбъектМетаданных.
//
// Возвращаемое значение:
//               – Тип - ссылочный;
//  Неопределено – тип нельзя получить.
//
// 20140121 Заяш 
// Автор TormozIT
// Взять из подситстемы ИнструментыРазработчика
// ирГлобальный.ЛксПолучитьСсылочныйТипПоМетаданным(пМетаданные)
//
Функция Тип_ПоМетаданным(пМетаданные) Экспорт

	Результат = Неопределено;
	КорневойТип = КорневойТипКонфигурации(пМетаданные);
	Если КорневойТипКонфигурации_Проверить(КорневойТип) Тогда 
		Результат = Тип(КорневойТип + "Ссылка." + пМетаданные.Имя);
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Безопасное преобразование строки в тип
// Если строка неправильная, будет возвращено неопределено
Функция Тип_ПоСтроке(пИмяТипа) Экспорт
	
	Если типЗнч(пИмяТипа) <> Тип("Строка") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	Попытка
		Возврат Тип(пИмяТипа);
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Возврат Неопределено;
	
КонецФункции

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция Тип_ПустоеЗначение(пТип) Экспорт
	
	Если пТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли пТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли пТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли пТип = Тип("Булево") Тогда
		Возврат Ложь;
	ИначеЕсли пТип = Тип("Неопределено") Тогда
		Возврат Неопределено;
	ИначеЕсли ТипЗнч(пТип) = Тип("ОписаниеТипов") Тогда
		Если пТип.Типы().Количество() = 0 Тогда
			Возврат Неопределено;
		Иначе
			Возврат Тип_ПустоеЗначение(пТип.Типы()[0]);
		КонецЕсли;
	ИначеЕсли ТипЗнч(пТип) = Тип("Тип") Тогда
		Возврат Новый(пТип);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Проверка того, что тип имеет ссылочный тип данных
//
// Параметры:
//	Тип — Тип или объект метаданных
//		необходимо проверить, педставляет ли этот тип
//
//	Возвращает:
//		Булево — признак того, что это ссылка
//
Функция Тип_ЭтоСсылка(Знач пТип) Экспорт 
	
	Если пТип = Неопределено Или пТип = Тип("Неопределено") Тогда
		Возврат Ложь;
		
	ИначеЕсли ТипЗнч(пТип) = Тип("Тип") Тогда
		Возврат 
			Справочники.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ Документы.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(пТип)
			ИЛИ Задачи.ТипВсеСсылки().СодержитТип(пТип)
			ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(пТип);
			
	ИначеЕсли ТипЗнч(пТип) = Тип("ОбъектМетаданных") Тогда
		Возврат
			Метаданные.Справочники.Содержит(пТип)
			ИЛИ Метаданные.Документы.Содержит(пТип)
			ИЛИ Метаданные.Перечисления.Содержит(пТип)
			ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(пТип)
			ИЛИ Метаданные.ПланыСчетов.Содержит(пТип)
			ИЛИ Метаданные.ПланыВидовРасчета.Содержит(пТип)
			ИЛИ Метаданные.БизнесПроцессы.Содержит(пТип)
			ИЛИ Метаданные.Задачи.Содержит(пТип)
			ИЛИ Метаданные.ПланыОбмена.Содержит(пТип);
			
	Иначе
		Возврат Ложь;
		
	КонецЕсли; 
	
	Возврат Ложь;
	
КонецФункции

// Создает структурированное имя файла, пригодное содержащее идентификатор
// структура имени:
//		ЧеловекочитаемоеИмя.Идентификатор.Расширение
//
Функция Файл_ИмяДополненноеИдентификатором(пИмяФайла, пИденитфикатор, пРасширение) Экспорт
	
	частиИмени = Новый Массив;
	
	// %1 Человекочитаемое имя файла
	имяФайла = СтрЗаменить(общ.Файл_ПодготовитьИмя(пИмяФайла)	, ".", "_");
	частиИмени.Добавить(имяФайла);
	
	// %2 ГУИД файла
	идентификатор = СтрЗаменить(СокрЛП(пИденитфикатор)			, ".", "_");
	частиИмени.Добавить(идентификатор);
	
	// %3 РасширениеФайла. В расширении могут быть '.', например 'xml.txt'	
	расширение = СокрЛП(пРасширение);
	Если Лев(расширение, 1) = "." Тогда
		расширение = Сред(расширение, 2);
		
	КонецЕсли;
	частиИмени.Добавить(расширение);
	
	имяФайла = СтрСоединить(частиИмени, "."); 
			
	Возврат имяФайла;
	
КонецФункции

Функция Файл_ПодготовитьИмя(Знач ИмяФайла) Экспорт
	
	ИмяФайла = СтрЗаменить(ИмяФайла, "/", "%");
	ИмяФайла = СтрЗаменить(ИмяФайла, "\", "%");
	ИмяФайла = СтрЗаменить(ИмяФайла, ":", ";");
	ИмяФайла = СтрЗаменить(ИмяФайла, "*", "x");
	ИмяФайла = СтрЗаменить(ИмяФайла, "?", "&");
	ИмяФайла = СтрЗаменить(ИмяФайла, """", "'");
	ИмяФайла = СтрЗаменить(ИмяФайла, ">", "{");
	ИмяФайла = СтрЗаменить(ИмяФайла, "<", "}");
	ИмяФайла = СтрЗаменить(ИмяФайла, "|", "!");
	ИмяФайла = СтрЗаменить(ИмяФайла, Символы.Таб, " ");
	ИмяФайла = СтрЗаменить(ИмяФайла, Символы.НПП, " ");
	ИмяФайла = СокрЛП(ИмяФайла);
	
	Возврат ИмяФайла;
	
КонецФункции

// Извлекает параметры из имени файла, если имя подготовлено функцией общ.Файл_ИмяДополненноеИдентификатором
	// Примеры имен файлов:
	// ИмяФайла.guid.EPF
Функция Файл_ПараметрыИмени(Знач пИмяФайла) Экспорт
	
	
	пИмяФайла = НРег(пИмяФайла);
	
	структураИмени = Новый Структура;
	структураИмени.Вставить("ПолноеИмя", пИмяФайла);
	структураИмени.Вставить("Имя", "");
	структураИмени.Вставить("ИД", "");
	структураИмени.Вставить("Расширение", "");
	структураИмени.Вставить("Отказ", Ложь);
	структураИмени.Вставить("ЭтоОбработка", Ложь);
	структураИмени.Вставить("ЭтоДанныеXML", Ложь); 
	
	частиИмени = СтрРазделить(пИмяФайла, ".");
	Если частиИмени.Количество() <> 3 Тогда
		структураИмени.Вставить("Отказ", Истина);
		Возврат структураИмени;
		
	КонецЕсли;
	
	структураИмени.Вставить("Имя", СокрЛП(частиИмени[0]));
	
	ИД = частиИмени[1];
	Если Не общ.Строка_ЭтоУникальныйИдентификатор(ИД) Тогда
		ИД = Неопределено;
		
	КонецЕсли;
	структураИмени.Вставить("ИД", ИД);
	
	Если ИД = Неопределено Тогда
		структураИмени.Вставить("Отказ", Истина);
		
	КонецЕсли;
	
	Файл_Расширение = частиИмени[2];
	структураИмени.Вставить("Расширение", Файл_Расширение);
	
	Возврат структураИмени;
	
КонецФункции

Процедура Файл_Удалить(пИмяФайла, пВызыватьИсключениеВнеТранзакции = Ложь) Экспорт
	
	Попытка
		УдалитьФайлы(пИмяФайла);
	Исключение
		выброситьИсключение = ТранзакцияАктивна() Или пВызыватьИсключениеВнеТранзакции;
		Если выброситьИсключение Тогда 
			ВызватьИсключение;
			
		КонецЕсли;
		
		инфоОшибки = ИнформацияОбОшибке();
		Ошибка_ВЖурналРегистрации("Файл_Удалить", инфоОшибки);
		
	КонецПопытки;
	
КонецПроцедуры

// Добавляет содержимое одного форматированного документа в другой.
//
// Параметры:
//	пДокументПриемник - ФорматированныйДокумент - Документ, в который добавляются элементы
//	пДобавляемыйДокумент - ФорматированныйДокумент - Документ, элементы которого добавляются в приемник
//
// На основании https://forum.infostart.ru/forum9/topic145576/message3056107/
// Александра Синцова https://infostart.ru/profile/60910
Процедура ФорматированныйДокумент_Добавить(пДокументПриемник, пДобавляемыйДокумент) Экспорт
	
	Для Каждого элемент Из пДобавляемыйДокумент.Элементы Цикл
		приемник = пДокументПриемник.Элементы.Добавить();
		ЗаполнитьЗначенияСвойств(приемник, элемент);
		
		Для Каждого вложенныйЭлемент Из элемент.Элементы Цикл
			
			Если Тип(вложенныйЭлемент) = Тип("ТекстФорматированногоДокумента") Тогда
				приемникТекст = приемник.Элементы.Добавить(вложенныйЭлемент.Текст);
				приемникТекст.НавигационнаяСсылка = вложенныйЭлемент.НавигационнаяСсылка;
				приемникТекст.ЦветТекста = вложенныйЭлемент.ЦветТекста;
				приемникТекст.ЦветФона = вложенныйЭлемент.ЦветФона;
				//@skip-check new-font
				приемникТекст.Шрифт = Новый Шрифт(вложенныйЭлемент.Шрифт);
				
			ИначеЕсли Тип(вложенныйЭлемент) = Тип("ПереводСтрокиФорматированногоДокумента") Тогда
				приемник.Элементы.Добавить(, Тип("ПереводСтрокиФорматированногоДокумента"));
				
			ИначеЕсли Тип(вложенныйЭлемент) = Тип("КартинкаФорматированногоДокумента") Тогда
				приемникКартинка = приемник.Элементы.Добавить(вложенныйЭлемент.Картинка, Тип("КартинкаФорматированногоДокумента"));
				приемникКартинка.НавигационнаяСсылка = вложенныйЭлемент.НавигационнаяСсылка;
				приемникКартинка.Ширина = вложенныйЭлемент.Ширина;
				приемникКартинка.Высота = вложенныйЭлемент.Высота;
				
			КонецЕсли;
			
		КонецЦикла;
		вложенныйЭлемент = Неопределено;
		
	КонецЦикла;
	элемент = Неопределено;
	
КонецПроцедуры

// Форма списка как форма выбора
// https://infostart.ru/1c/articles/549160/
Процедура ФормаСпискаКакФормаВыбора(пФорма) Экспорт
	
	// Элементы.Список - основной реквизит с динамическим списком
	пФорма.Элементы.Список.РежимВыбора = пФорма.Параметры.РежимВыбора;
	Если пФорма.Параметры.МножественныйВыбор <> Неопределено Тогда
		пФорма.Элементы.Список.МножественныйВыбор = пФорма.Параметры.МножественныйВыбор;
	КонецЕсли;
	
	// обход автоматического сохранения пользовательских настроек для разных режимов, спасибо @stolya
	Если пФорма.Параметры.РежимВыбора И Не ЗначениеЗаполнено(пФорма.Параметры.КлючПользовательскихНастроек) Тогда
		пФорма.Параметры.КлючПользовательскихНастроек = "РежимВыбора";
		пФорма.Список.АвтоматическоеСохранениеПользовательскихНастроек = Ложь;
		
	КонецЕсли;
	
КонецПроцедуры

Функция Число_ПоСтроке_ДополнитьЛидирующимиНулями(пЧисло, КоличествоСимволов) Экспорт
	
	Проверка_Тип(пЧисло, "Число"); 
	Проверка_Тип(КоличествоСимволов, "Число");
	
	ФорматнаяСтрока = 
		СтрШаблон(
			"ЧЦ=%1; ЧВН=; ЧГ=0",
			Формат(КоличествоСимволов, "ЧДЦ=0; ЧГ=0")
			);
	
	Возврат Формат(пЧисло, ФорматнаяСтрока);
	
КонецФункции

// Проверяет, является ли переданная коллекция заполненной.
//
// Параметры:
//   пКоллекция - <Тип> - Коллекция для проверки
//
// Возвращаемое значение:
//   Булево - Признак заполненности коллекции
Функция ЭтоЗаполненнаяКоллекция(пКоллекция) Экспорт
	
	Если Не ЭтоКоллекцияКлючЗначение(пКоллекция) Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	коллекцияЗаполнена = пКоллекция.Количество() > 0;
	
	Возврат коллекцияЗаполнена;
	
КонецФункции

// Определяет, является ли переданное значение заполненным массивом.
//
// Параметры:
//   пЗначение - Произвольный - Проверяемое значение.
//
// Возвращаемое значение:
//   Булево - Истина, если значение является массивом и содержит элементы, иначе - Ложь.
//
Функция ЭтоЗаполненныйМассив(пЗначение) Экспорт
	
	Возврат ТипЗнч(пЗначение) = Тип("Массив") И пЗначение.Количество() > 0;
	
КонецФункции

// Проверяет, является ли переданное значение заполненной ссылкой указанного типа.
//
// Параметры:
//   пСсылка - ЛюбаяСсылка - проверяемое значение
//   пПроверяемыйТип - Тип - ожидаемый тип ссылки (по умолчанию Неопределено)
//
// Возвращаемое значение:
//   Булево - Истина, если значение является заполненной ссылкой указанного типа
Функция ЭтоЗаполненнаяСсылка(пСсылка, пПроверяемыйТип = Неопределено) Экспорт

	// Если передан параметр ПроверяемыйТип, проверить, соответствует ли ему ПроверяемоеЗначение
	Если пПроверяемыйТип <> Неопределено Тогда 
		типСоответствует = Проверка_Тип(пСсылка, пПроверяемыйТип, Ложь) = "";
		
		Если Не типСоответствует Тогда
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ЭтоСсылка(пСсылка) И ЗначениеЗаполнено(пСсылка);
	
КонецФункции

Функция ЭтоКоллекцияКлючЗначение(пЗначение) Экспорт 
	
	типЗначения = Неопределено;
	Если ТипЗнч(пЗначение) = Тип("Тип") Тогда
		типЗначения = пЗначение;
		
	Иначе
		типЗначения = ТипЗнч(пЗначение);
		
	КонецЕсли;
	
	Возврат
			типЗначения = Тип("Структура") 
		Или	типЗначения = Тип("ФиксированнаяСтруктура") 
		Или типЗначения = Тип("Соответствие") 
		Или типЗначения = Тип("ФиксированноеСоответствие") 
		;

КонецФункции

Функция ЭтоСсылка(пЗначение) Экспорт
	
	Если ТипЗнч(пЗначение) = Тип("Тип") Тогда
		Возврат Тип_ЭтоСсылка(пЗначение);	
		
	Иначе
		Возврат Тип_ЭтоСсылка(ТипЗнч(пЗначение));
		
	КонецЕсли;

КонецФункции

Функция ЭтоТестоваяБаза() Экспорт
	
	Возврат общ_Кэш.ЭтоТестоваяБаза();
	
КонецФункции

Функция ЭтоФоновоеЗадание() Экспорт
	
	Возврат общ_кэш.ЭтоФоновоеЗадание();
	
КонецФункции

#Область JSON 

Функция UnJSON(СтрJSON, ПрочитатьВСоответствие = Истина) Экспорт

	ЧтениеJSON = Новый ЧтениеJSON();
	ЧтениеJSON.УстановитьСтроку(СтрJSON);
	результат = ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие);
	ЧтениеJSON.Закрыть();

	Возврат результат;

КонецФункции

Функция JSON(пЗначение, пЭкранироватьСимволы = Истина, Знач пОтступ = "", пКэш = Неопределено) Экспорт
	
	Если ТипЗнч(пКэш) <> Тип("Соответствие") Тогда
		пКэш = Новый Соответствие;
		
	КонецЕсли;
	
	стр = ""; // Значение на возврат
	
	// Поиск в кэше
	значениеВКэше = пКэш[пЗначение];
	Если значениеВКэше <> Неопределено Тогда
		стр = СтрЗаменить(значениеВКэше, Символы.ПС, Символы.ПС + пОтступ);
		Возврат стр;
		
	КонецЕсли;	
	
	отступСледующего = пОтступ + Символы.Таб;
	
	типЗначения = ТипЗнч(пЗначение);

	Если типЗначения = Тип("Строка") Тогда
		Если пЭкранироватьСимволы Тогда
			стр = """" + JSON_ЭкранироватьНедопустимыеСимволы(пЗначение) + """";
			пКэш.Вставить(пЗначение, стр);

		Иначе
			стр = пЗначение;	
			
		КонецЕсли;
		
		стр = СтрЗаменить(стр, Символы.ПС, Символы.ПС + пОтступ);

	ИначеЕсли типЗначения = Тип("Число") ИЛИ ТипЗнч(пЗначение)=Тип("Булево") Тогда
		стр = XMLСтрока(пЗначение);
		пКэш.Вставить(пЗначение, стр);

	ИначеЕсли типЗначения = Тип("Дата") Тогда
		стр= """"+?(ЗначениеЗаполнено(пЗначение),XMLСтрока(пЗначение),"")+"""";
		пКэш.Вставить(пЗначение, стр);

	ИначеЕсли типЗначения = Тип("Массив") Тогда 
		Для Каждого эл Из пЗначение Цикл
			// %1 Разделитель элементов, выводить после первого
			разделитель = ?(ПустаяСтрока(стр), "", стр + ","  + Символы.ПС);
			сериализованный = JSON(эл, пЭкранироватьСимволы, отступСледующего, пКэш);
			стр = СтрШаблон("%1%2	%3", разделитель, сериализованный, пОтступ);
					
		КонецЦикла;
		эл = Неопределено;
		
		Если ПустаяСтрока(стр) Тогда
			стр = пОтступ + "[]";  
			
		Иначе
			стр = СтрШаблон(	"%2[
								|%1
								|%2	]", 
								стр, // %1
								пОтступ // %2
								);
					
		КонецЕсли;
		
	ИначеЕсли общ.ЭтоКоллекцияКлючЗначение(пЗначение) Тогда 
		стр = общ.JSON_ПоКоллекции(пЗначение, пКэш);
		
	ИначеЕсли типЗначения = Тип("СписокЗначений") Тогда
		пЗначение.СортироватьПоПредставлению();
		
		Для Каждого элемент Из пЗначение Цикл 
			стрКлюч = СокрЛП(элемент.Представление);
			
			Если ПустаяСтрока(стрКлюч) Тогда
				Продолжить;
				
			КонецЕсли;
			
			значение = JSON(элемент.Значение, пЭкранироватьСимволы, отступСледующего, пКэш);
			
			// Пустые строки
			Если значение = "" Тогда
				значение = """""";
				
			КонецЕсли;

			стр = 
				СтрШаблон(
					"%1%2	""%3"": %4",
					?(ПустаяСтрока(стр), "", стр + ","  + Символы.ПС), // %1 Разделитель элементов, после первого 
					пОтступ, // %2
					стрКлюч, // %3
					значение // %4
					);
					
		КонецЦикла;
		элемент = Неопределено;
		
		Если ПустаяСтрока(стр) Тогда
			стр = пОтступ + "{}";  
			
		Иначе
			стр = 
				СтрШаблон(
					"%2{
					|%1
					|%2	}", 
					стр, // %1
					пОтступ // %2
					);
					
		КонецЕсли;
		
	ИначеЕсли типЗначения = Тип("ТаблицаЗначений") Тогда
		МассивОбразовСтрокТЗ = Новый Массив;
		Для Каждого СтрокаТЗ Из пЗначение Цикл
			ОбразСтрокиТЗ = Новый Структура;
			Для Каждого Колонка Из пЗначение.Колонки Цикл
				ОбразСтрокиТЗ.Вставить(Колонка.Имя, СтрокаТЗ[Колонка.Имя])
				
			КонецЦикла;
			Колонка = Неопределено;
			
			МассивОбразовСтрокТЗ.Добавить(ОбразСтрокиТЗ);
			
		КонецЦикла;
		СтрокаТЗ = Неопределено;
		
		стр = JSON(МассивОбразовСтрокТЗ, пЭкранироватьСимволы, отступСледующего, пКэш);
	
	ИначеЕсли пЗначение = Неопределено Или пЗначение = Null Тогда 
		стр = "null";
		пКэш.Вставить(пЗначение, стр);
		
	ИначеЕсли ТипЗнч(пЗначение) = Тип("УникальныйИдентификатор") Тогда
		стр = СтрШаблон("""%1""", Строка(пЗначение));
		пКэш.Вставить(пЗначение, стр);

	Иначе
		стр = "";
		
	КонецЕсли;
	
	Если Не ПустаяСтрока(стр) Тогда
		Возврат стр;
		
	КонецЕсли;
	
	сериализоватьЧерезXDTO = типЗначения = Тип("ТабличныйДокумент") Или типЗначения = Тип("ХранилищеЗначения")
		Или типЗначения = Тип("ОписаниеТипов")
		Или типЗначения = Тип("Тип")
		;
		
	Если сериализоватьЧерезXDTO Тогда
		писатель = Новый ЗаписьJSON;
		писатель.УстановитьСтроку();
		СериализаторXDTO.ЗаписатьJSON(писатель, пЗначение, НазначениеТипаXML.Явное);
		стр = писатель.Закрыть();
		
		Если типЗначения = Тип("ОписаниеТипов") Или типЗначения = Тип("Тип") Тогда
			пКэш.Вставить(пЗначение, стр);
			
		КонецЕсли;
		
	КонецЕсли;

	Возврат стр;

КонецФункции

Функция JSON_ПоКоллекции(пКоллекция, пКэш = Неопределено) Экспорт
	
	Если Ложь Тогда 
		пКоллекция = Новый СписокЗначений;
		
	КонецЕсли;
	
	типКоллекции = ТипЗнч(пКоллекция);
	этоСписокЗначений = типКоллекции = Тип("СписокЗначений");
	Если этоСписокЗначений Тогда
		пКоллекция.СортироватьПоПредставлению();
		стрJSON = JSON(пКоллекция, Ложь, , пКэш);
		
		Возврат стрJSON;
		
	КонецЕсли; // Если этоСписокЗначений
	
	этоМассив = типКоллекции = Тип("Массив");
	этоКоллекция = общ.ЭтоКоллекцияКлючЗначение(типКоллекции);
	Если Не этоМассив И Не этоКоллекция Тогда
		Возврат Неопределено;
		
	КонецЕсли; 
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(,Символы.Таб);
	
	сортировщик = Новый ТаблицаЗначений;
	сортировщик.Колонки.Добавить("Значение");
	сортировщик.Колонки.Добавить("КолонкаСортировки");

	Для Каждого элемент Из пКоллекция Цикл
		
		Если этоМассив Тогда
			элемент_значение = элемент;
			
		Иначе // Структура, соответствие
			элемент_значение = элемент.Значение;
			
		КонецЕсли;
		
		элемент_JSON = JSON(элемент_значение, , , пКэш);

		элемент_ключ = Неопределено;
		номерСтроки = Неопределено;
		элемент_значение_ЭтоКоллекция = 	общ.ЭтоКоллекцияКлючЗначение(элемент_значение) 
										Или ТипЗнч(элемент_значение) = Тип("Массив");
		Если 
				этоМассив
			И	элемент_значение_ЭтоКоллекция
			И	Общ.Коллекция_Свойство(элемент_значение, "_НомерСтроки", номерСтроки)
		Тогда
			элемент_ключ = номерСтроки;
			
		ИначеЕсли этоМассив Тогда
			элемент_ключ = элемент_JSON; 
			
		Иначе // Структура, соответствие
			элемент_ключ = элемент.Ключ;
			
		КонецЕсли;
		
		рядСортировщика = сортировщик.Добавить(); 
		рядСортировщика.Значение = элемент_JSON; 
		рядСортировщика.КолонкаСортировки = элемент_ключ;

	КонецЦикла;
	элемент = Неопределено;  
		
	сортировщик.Сортировать("КолонкаСортировки");
	
	// Начало записи
	Если этоМассив Тогда
		упорядоченнаяКоллекция = сортировщик.ВыгрузитьКолонку("Значение");
		
	Иначе // Структура, соответствие
		упорядоченнаяКоллекция = Новый СписокЗначений;
		Для Каждого рядСортировщика Из сортировщик Цикл
			упорядоченнаяКоллекция.Добавить(рядСортировщика.Значение, рядСортировщика.КолонкаСортировки);
			
		КонецЦикла;
		
	КонецЕсли; 
	
	стрJSON = JSON(упорядоченнаяКоллекция, Ложь, , пКэш);
		
	Возврат стрJSON;
	
КонецФункции

Функция JSON_ЭкранироватьНедопустимыеСимволы(пСтр)
	
	Х = пСтр;
	Х=СтрЗаменить(Х,"\","\\");  
	Х=СтрЗаменить(Х,Символ(8),"\b");
	Х=СтрЗаменить(Х,Символы.ПФ,"\f");
	Х=СтрЗаменить(Х,Символы.ПС,"\n");
	Х=СтрЗаменить(Х,Символы.ВК,"\r");
	Х=СтрЗаменить(Х,Символы.ВТаб,"\t");
	Х=СтрЗаменить(Х,"""","\""");
	Х=СтрЗаменить(Х,"/","\/");

	Возврат Х
	
КонецФункции

#КонецОбласти // JSON

#Область RS256 
// Исходный код взят из https://infostart.ru/public/805071/
// Автор uno-c 

// возвращает двоичную подпись
Функция ПодписьSHA256RSA(пДляПодписи, пЗакрытыйКлючPEM) Экспорт
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA256);
	Хеширование.Добавить(пДляПодписи);
	ХешДвоичный = Хеширование.ХешСумма;
		
	ХешХексСтрока = ПолучитьHexСтрокуИзДвоичныхДанных(ХешДвоичный);
	
	// PKCS #1 v2.2: RSA Cryptography Standard, 9.2 EMSA-PKCS1-v1_5
	// перед подписанием хеш дополняется данными
	// EM  = 0x00 || 0x01 ||PS  || 0x00 ||T
	// T SHA-256:  (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H
	ЕМ = "0001" + "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"+
	"00" + "3031300D060960864801650304020105000420" + ХешХексСтрока; 
	
	ХешХексСтрока = ЕМ;
  	хешчисло = ЧислоИзШестнадцатеричнойСтроки("0x"+ХешХексСтрока);
	
	СтрукСерт = ПолучитьСтруктуруСертификата(пЗакрытыйКлючPEM);	
	dP 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.DP);
	p 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.P);
	dQ	 		= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.DQ);
	q 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Q);
	qInv 		= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.InverseQ);
	Exponent 	= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Exponent); //открытый параметр ключа
	Modulus 	= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Modulus); //открытый параметр ключа
	
	//s1 = pow(хешчисло,DP_Число)% P_Число;//переполнение десятичной арифметики
	
	// ↓ вычисление подписи по ускоренному алгоритму
	s1 = ВозведениеВСтепеньПоМодулю (хешчисло, dP, p);
	s2 = ВозведениеВСтепеньПоМодулю (хешчисло, dQ, q);
	Если s1>s2 Тогда
		h = ((s1-s2)*qInv)%p
	Иначе
		h = ((s1-s2+p)*qInv)%p
	КонецЕсли;
	s = s2 + q*h; //подпись - число
	// ↑
	
	//ПроверкаПодписиЧисло = ВозведениеВСтепеньПоМодулю (s, Exponent, Modulus);
	//подписьВерна = (ПроверкаПодписиЧисло = хешчисло);
	//Сообщить ("Подпись верна:" + подписьВерна); 
	
	Возврат ДвоичныеИзЧисла(s)
	
КонецФункции 

// существует изменённый Base64 для URL, где не используется заполнение символом = 
// и символы + и / соответственно заменяются на * и -
// -------- подошел второй ↓ вариант плюс убраны заполнения символом "=" ----------
// Base64-кодирования URL адресов признается вариант, 
// когда символы + и / заменяются, соответственно, на - и _ (RFC 3548, раздел 4). 
Функция Base64Url(пДвоичныеДанные) Экспорт
	
	бейс64строка = Base64Строка(пДвоичныеДанные);
	бейс64строка = стрЗаменить(бейс64строка, "+", "-");
	бейс64строка = стрЗаменить(бейс64строка, "/", "_");
	бейс64строка = стрЗаменить(бейс64строка, Символы.ВК, "");
	бейс64строка = стрЗаменить(бейс64строка, Символы.ПС, "");
	
	Если Прав(бейс64строка, 2) = "==" Тогда
		бейс64строка = Лев(бейс64строка,СтрДлина(бейс64строка)-2);
		
	ИначеЕсли Прав(бейс64строка, 1) = "=" Тогда
		бейс64строка = Лев(бейс64строка,СтрДлина(бейс64строка)-1);
	КонецЕсли;
	
	Возврат бейс64строка;
	
КонецФункции 

Функция ПолучитьСтруктуруСертификата(пЗакрытыйКлючPEM)

	пЗакрытыйКлючPEM = СтрЗаменить(пЗакрытыйКлючPEM,"-----BEGIN PRIVATE KEY-----","");
	пЗакрытыйКлючPEM = СтрЗаменить(пЗакрытыйКлючPEM,"-----BEGIN RSA PRIVATE KEY-----","");
	пЗакрытыйКлючPEM = СтрЗаменить(пЗакрытыйКлючPEM,"-----END PRIVATE KEY-----","");
	пЗакрытыйКлючPEM = СтрЗаменить(пЗакрытыйКлючPEM,"-----END RSA PRIVATE KEY-----","");
	ХексСтрокаКлюча = ПолучитьHexСтрокуИзДвоичныхДанных(Base64Значение(пЗакрытыйКлючPEM));
	Тэги = Новый Соответствие;
	Тэги.Вставить("30","SEQUENCE");
	Тэги.Вставить("02","INTEGER");
	Тэги.Вставить("06","OBJECT IDENTIFIER");
	Тэги.Вставить("04","OCTET STRING");
	Тэги.Вставить("05","NULL");
	
	ДлинаАдресаОдинБайт = "81";
	ДлинаАдресаДваБайта = "82";
	
	парс = Новый ДеревоЗначений;
	парс.Колонки.Добавить("Класс",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(2)));
	парс.Колонки.Добавить("ИмяКласса",Новый ОписаниеТипов("Строка"));
	парс.Колонки.Добавить("ПредбайтДлины",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(2)));
	парс.Колонки.Добавить("БайтДлины",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(4)));
	парс.Колонки.Добавить("ДлинаЧисло", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0)));
	парс.Колонки.Добавить("Значение",Новый ОписаниеТипов("Строка"));
	
	СтрокаOCTET_STRING = Неопределено; //в октетстринг лежит RSAPrivateKey по RFC 3447
	ПарсХекс(парс, ХексСтрокаКлюча, СтрокаOCTET_STRING);
	
	// Для "-----BEGIN RSA PRIVATE KEY-----" OCTET_STRING лежит на верхнем уровне
	Если СтрокаOCTET_STRING = Неопределено Тогда 
		СтрокаOCTET_STRING = парс;	
		
	КонецЕсли;	
	
	RSAPrivateKey_SEQUENCE = СтрокаOCTET_STRING.Строки[0];
	// единственный элемент внутри OCTET_STRING, является RSAPrivateKey ::= SEQUENCE {...
	PKey_SEQUENCE_fields = RSAPrivateKey_SEQUENCE.Строки;
	
	СтруктураСертификата = Новый Структура;
	//PKey_SEQUENCE_fields[0] - version не нужна
	СтруктураСертификата.Вставить("Modulus",	PKey_SEQUENCE_fields[1].Значение);
	СтруктураСертификата.Вставить("Exponent",	PKey_SEQUENCE_fields[2].Значение);
	СтруктураСертификата.Вставить("D",			PKey_SEQUENCE_fields[3].Значение);
	СтруктураСертификата.Вставить("P",			PKey_SEQUENCE_fields[4].Значение);
	СтруктураСертификата.Вставить("Q",			PKey_SEQUENCE_fields[5].Значение);
	СтруктураСертификата.Вставить("DP",			PKey_SEQUENCE_fields[6].Значение);
	СтруктураСертификата.Вставить("DQ",			PKey_SEQUENCE_fields[7].Значение);
	СтруктураСертификата.Вставить("InverseQ",	PKey_SEQUENCE_fields[8].Значение);
	
	Возврат СтруктураСертификата;
	
	//RFC 3447
   // A.1.2 RSA private key syntax

   //An RSA private key should be represented with the ASN.1 Категория
   //RSAPrivateKey:

   //   RSAPrivateKey ::= SEQUENCE {
   //  0     version           Version,
   //  1     modulus           INTEGER,  -- n
   //  2     publicExponent    INTEGER,  -- e
   //  3     privateExponent   INTEGER,  -- d
   //  4     prime1            INTEGER,  -- p
   //  5     prime2            INTEGER,  -- q
   //  6     exponent1         INTEGER,  -- d mod (p-1)
   //  7     exponent2         INTEGER,  -- d mod (q-1)
   //  8     coefficient       INTEGER,  -- (inverse of q) mod p
   //  9     otherPrimeInfos   OtherPrimeInfos OPTIONAL
   //   }

   //The fields of Категория RSAPrivateKey have the following meanings:

   // * version is the version number, for compatibility with future
   //   revisions of this document.  It shall be 0 for this version of the
   //   document, unless multi-prime is used, in which case it shall be 1.

   //         Version ::= INTEGER { two-prime(0), multi(1) }
   //            (CONSTRAINED BY
   //            {-- version must be multi if otherPrimeInfos present --})

   // * modulus is the RSA modulus n.

   // * publicExponent is the RSA public exponent e.

   // * privateExponent is the RSA private exponent d.

   // * prime1 is the prime factor p of n.

   // * prime2 is the prime factor q of n.

   // * exponent1 is d mod (p - 1).

   // * exponent2 is d mod (q - 1).

   // * coefficient is the CRT coefficient q^(-1) mod p.

   // * otherPrimeInfos contains the information for the additional primes
   //   r_3, ..., r_u, in order.  It shall be omitted if version is 0 and
   //   shall contain at least one instance of OtherPrimeInfo if version
   //   is 1.
	
КонецФункции 

Процедура ПарсХекс(Родитель, ХексСтрокаКлюча, СтрокаOCTET_STRING)
	Тэги = Новый Соответствие;
	Тэги.Вставить("30","SEQUENCE");
	Тэги.Вставить("02","INTEGER");
	Тэги.Вставить("06","OBJECT IDENTIFIER");
	Тэги.Вставить("04","OCTET STRING");
	Тэги.Вставить("05","NULL");
	
	Позиция = 1;
	//Родитель = парс;
	Пока Позиция < СтрДлина(ХексСтрокаКлюча) Цикл
		сПарс = Родитель.Строки.Добавить(); 
		сПарс.Класс = Сред(ХексСтрокаКлюча, Позиция, 2);
		Позиция = Позиция + 2;
		сПарс.ИмяКласса = Тэги.Получить(сПарс.Класс);
		
		байт = Сред(ХексСтрокаКлюча, Позиция, 2);
		Если байт = "81" или байт = "82" Тогда
			сПарс.ПредбайтДлины = байт;
			Позиция = Позиция + 2;
			
			КолвоБайтАдресации = Число(байт) - 80;
			сПарс.БайтДлины = Сред(ХексСтрокаКлюча, Позиция, 2 * КолвоБайтАдресации);
			Позиция = Позиция + 2 * КолвоБайтАдресации;
			сПарс.ДлинаЧисло = ЧислоИзШестнадцатеричнойСтроки("0x"+сПарс.БайтДлины);
			
			сПарс.Значение = Сред(ХексСтрокаКлюча, Позиция, 2 * сПарс.ДлинаЧисло);
			Позиция = Позиция + 2 * сПарс.ДлинаЧисло;
			//последнюю позицию сдвинем/несдвинем после Если
			
		Иначе
			сПарс.ПредбайтДлины = ""; //отсутствует
			
			сПарс.БайтДлины = Сред(ХексСтрокаКлюча, Позиция, 2);
			Позиция = Позиция + 2;
			сПарс.ДлинаЧисло = ЧислоИзШестнадцатеричнойСтроки("0x"+сПарс.БайтДлины);
			
			сПарс.Значение = Сред(ХексСтрокаКлюча, Позиция, 2 * сПарс.ДлинаЧисло);
			Позиция = Позиция + 2 * сПарс.ДлинаЧисло;

		КонецЕсли;
		
		Если сПарс.ИмяКласса = "OCTET STRING" Тогда
			СтрокаOCTET_STRING = сПарс;
		КонецЕсли;
		
		Если сПарс.ИмяКласса = "SEQUENCE" или сПарс.ИмяКласса = "OCTET STRING" Тогда
			// эти классы содержат подклассы, разбираем подветки рекурсивно
			ПарсХекс(сПарс, сПарс.Значение, СтрокаOCTET_STRING);
		КонецЕсли;

	КонецЦикла; 
	
	
	
КонецПроцедуры

Функция ВозведениеВСтепеньПоМодулю (Основание, Степень, Модуль)
	
	// Двоичное представление степени переведем в массив нулей и единиц в обратном порядке
	МассивЕдиниц = Новый Массив;
	Значение = Степень;
    Пока Значение>0 цикл
        Остат = Значение%2;
		МассивЕдиниц.Добавить(Остат);
        Значение = (Значение-Остат)/2;
	КонецЦикла;
	
	//Основание переведем в массив по хитрому правилу
	МассивИзОснования = Новый Массив;
	Для сч=0 по МассивЕдиниц.ВГраница() Цикл
		Если сч = 0 тогда
			МассивИзОснования.Добавить(Основание);
		Иначе
			МассивИзОснования.Добавить(ВозведениеВСтепеньБинарное(МассивИзОснования[сч-1],2)%Модуль);
		КонецЕсли;
	КонецЦикла;
	
	//Вычислим произведение степеней 
	таблицаСтепеней = Новый ТаблицаЗначений;
	таблицаСтепеней.Колонки.Добавить("Степень", Новый ОписаниеТипов("Число"));
	Произведение = 1;
	Карацуба = 1;
	Для сч=0 по МассивЕдиниц.ВГраница() Цикл 
		степень = ВозведениеВСтепеньБинарное(МассивИзОснования[сч],МассивЕдиниц[сч]); 
		Произведение = Произведение * степень; 
	КонецЦикла;
	
	остатокДеления = Произведение%Модуль;

	Возврат остатокДеления;
	
КонецФункции  

Функция ВозведениеВСтепеньБинарное (пОснование, пСтепень) Экспорт
	Если пСтепень = 0 Тогда
		Возврат 1;
		
	ИначеЕсли пСтепень % 2 = 1 Тогда
		Возврат ВозведениеВСтепеньБинарное (пОснование, пСтепень-1) * пОснование;
		
	Иначе
		b = ВозведениеВСтепеньБинарное (пОснование, пСтепень/2);
		Возврат b * b; 
		
	КонецЕсли;

КонецФункции

Функция ДвоичныеИзЧисла(знач мЧисло)
	МассивЧиселБайт = Новый Массив;
	Пока мЧисло>0 Цикл
		ТекущийБайт = мЧисло%256;
		МассивЧиселБайт.Добавить(ТекущийБайт);
		мЧисло = (мЧисло - ТекущийБайт)/256;
	КонецЦикла;
	РазмерБайт = МассивЧиселБайт.Количество();
	Буфер = Новый БуферДвоичныхДанных(РазмерБайт);
	Для сч = 0 по РазмерБайт-1 Цикл
		Буфер.Установить(РазмерБайт-1-сч, МассивЧиселБайт[сч]);
	КонецЦикла;

	Возврат ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
	
КонецФункции

#КонецОбласти // RS256

// Функции из типовых конфигураций и БСП
#Область Типовые

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2022, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

// Проверяет, что используемая версия платформы не ниже указанной.
//
// Параметры:
//	Версия - Строка - номер версии Платформы
//
// Возвращаемое значение:
//	Булево - Истина, если используемая версия не младше указанной в параметре Версия
// 
// Заяш 251209 10:24 Добавил проверку режима совместимости
//
Функция ВерсияПлатформыНеНижеУказанной(пВерсия) Экспорт
	
	оСистеме = Новый СистемнаяИнформация;
	версияПриложенияНиже = (СравнитьВерсии(оСистеме.ВерсияПриложения, пВерсия) < 0);
	Если версияПриложенияНиже Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	режимСовместимости = Строка(Метаданные.РежимСовместимости);
	режимСтрокой = общ.Строка_УдалитьНедопустимыеСимволы(режимСовместимости,"01234567890_");
	режимСтрокой = СтрЗаменить(режимСтрокой, "_", ".");
	
	режимСовместимостиНиже = (СравнитьВерсии(режимСтрокой, пВерсия) < 0);
	Если режимСовместимостиНиже Тогда
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив - массив значений для заполнения.
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут включены только уникальные значения.
//
// ОбщегоНазначенияКлиентСервер
// 
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Экспорт
	
	Если ТолькоУникальныеЗначения Тогда
		
		УникальныеЗначения = Новый Соответствие;
		
		Для Каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
		
		Для Каждого Значение Из МассивИсточник Цикл
			Если УникальныеЗначения[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				УникальныеЗначения.Вставить(Значение, Истина);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Для Каждого Значение Из МассивИсточник Цикл
			МассивПриемник.Добавить(Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Проверяет наличие реквизита или свойства у произвольного объекта без обращения к метаданным.
//
// Параметры:
//  Объект       - Произвольный - объект, у которого нужно проверить наличие реквизита или свойства;
//  ИмяРеквизита - Строка       - имя реквизита или свойства.
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
// 
Функция ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита) Экспорт
	
	// ИЗ БСП
	///////////////////////////////////////////////////////////////////////////////////////////////////////
	// Copyright (c) 2023, ООО 1С-Софт
	// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
	// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
	// Текст лицензии доступен по ссылке:
	// https://creativecommons.org/licenses/by/4.0/legalcode
	///////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	
	КлючУникальности   = Новый УникальныйИдентификатор; 
	Попытка
		СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
		
	Исключение
		Возврат Ложь;
		
	КонецПопытки;
	
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

// Создает массив и помещает в него переданное значение.
//
// Параметры:
//  Значение - Произвольный - любое значение.
//
// Возвращаемое значение:
//  Массив - массив из одного элемента.
//  
// Из модуля ОбщегоНазначенияКлиентСервер
//
Функция ЗначениеВМассиве(Знач Значение)
	
	Результат = Новый Массив;
	Результат.Добавить(Значение);
	Возврат Результат;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  ИмяРеквизита       - Строка - имя получаемого реквизита.
//                                Допускается указание имени реквизита через точку, но при этом параметр КодЯзыка для
//                                такого реквизита учитываться не будет.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то возвращается Неопределено;
//                                если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Произвольный - если в параметр Ссылка передана пустая ссылка, то возвращается Неопределено.
//                 Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//                 то возвращается Неопределено.
//
// Из модуля ОбщегоНазначения
//
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Имя реквизита должно быть заполнено.'"), "ИмяРеквизита", "ОбщегоНазначения.ЗначениеРеквизитаОбъекта");
	КонецЕсли;
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные, КодЯзыка);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы по ссылке на объект.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, "Код, Наименование, Родитель".
//            - Структура
//            - ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//                       Допускается указание имени поля через точку, но при этом параметр КодЯзыка для такого поля
//                       учитываться не будет.
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя;
//                                если есть ограничение на уровне записей, то все реквизиты вернутся со 
//                                значением Неопределено; если нет прав для работы с таблицей, то возникнет исключение;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//              Если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//              Если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	// Если передано имя предопределенного.
	Если ТипЗнч(Ссылка) = Тип("Строка") Тогда
		
		ПолноеИмяПредопределенногоЭлемента = Ссылка;
		
		// Вычисление ссылки по имени предопределенного.
		// - дополнительно выполняет проверку метаданных предопределенного, выполняется предварительно.
		Попытка
			Ссылка = ПредопределенноеЗначение(ПолноеИмяПредопределенногоЭлемента);
		Исключение
			инфоОшибки = ИнформацияОбОшибке();
			ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Неверный первый параметр %1 в функции %2:
				|%3'"), "Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", 
				общ.Ошибка_КраткоеПредставление(инфоОшибки)
				);
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
		
		// Разбор полного имени предопределенного.
		ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенногоЭлемента, ".");
		ПолноеИмяОбъектаМетаданных = ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1];
		
		// Если предопределенный не создан в ИБ, то требуется выполнить проверку доступа к объекту.
		// В других сценариях проверка доступа выполняется в момент исполнения запроса.
		Если Ссылка = Неопределено Тогда 
			МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			Если Не ПравоДоступа("Чтение", МетаданныеОбъекта) Тогда 
				ВызватьИсключение СтрШаблон(
					НСтр("ru = 'Недостаточно прав для работы с таблицей ""%1""'"), ПолноеИмяОбъектаМетаданных);
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли общ.ЭтоЗаполненнаяСсылка(Ссылка) Тогда // Если передана ссылка.
		
		Попытка
			ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя(); 
		Исключение
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значение должно быть ссылкой или именем предопределенного элемента.'"), 
				"Ссылка", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта");
			КонецПопытки;
			
	Иначе
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		Для Индекс = 0 По Реквизиты.ВГраница() Цикл
			Реквизиты[Индекс] = СокрЛП(Реквизиты[Индекс]);
		КонецЦикла;
	КонецЕсли;
	
	МультиязычныеРеквизиты = Новый Соответствие;
	СуффиксЯзыка = "";
	
	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		Для Каждого КлючИЗначение Из Реквизиты Цикл
			СтруктураПолей.Вставить(КлючИЗначение.Ключ, СокрЛП(КлючИЗначение.Значение));
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		Для Каждого Реквизит Из Реквизиты Цикл
			Реквизит = СокрЛП(Реквизит);
			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ".", "");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение 
				// Если псевдоним не является ключом.
				
				// Поиск ошибки доступности полей.
				Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда 
					ВызватьИсключение СтрШаблон(
						НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"),
						"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки);
				КонецЕсли;
				
				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;
			
			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неверный тип второго параметра %1 в функции %2: %3.'"), 
			"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;
	
	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = "";
	Для каждого КлючИЗначение Из СтруктураПолей Цикл
		
		ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
		ПсевдонимПоля = КлючИЗначение.Ключ;
		
		Если МультиязычныеРеквизиты[ИмяПоля] <> Неопределено Тогда
			ИмяПоля = ИмяПоля + СуффиксЯзыка;
		КонецЕсли;
		
		ТекстЗапросаПолей = 
			ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + ПсевдонимПоля;
		
		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);
		
	КонецЦикла;
	
	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда 
		Возврат Результат;
	КонецЕсли;
	
	Если Тип("Структура") = ТипЗнч(Реквизиты)
		Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
		Реквизиты = Новый Массив;
		Для Каждого КлючИЗначение Из СтруктураПолей Цикл
			ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
			Реквизиты.Добавить(ИмяПоля);
		КонецЦикла;
	КонецЕсли;
	
	РеквизитыЧерезТочку = Новый Массив;
	Для Индекс = -Реквизиты.ВГраница() По 0 Цикл
		ИмяПоля = Реквизиты[-Индекс];
		Если СтрНайти(ИмяПоля, ".") Тогда
			РеквизитыЧерезТочку.Добавить(ИмяПоля);
			Реквизиты.Удалить(-Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Реквизиты) Тогда
		ЗначенияРеквизитовОбъекта = ЗначенияРеквизитовОбъектов(ЗначениеВМассиве(Ссылка), Реквизиты, ВыбратьРазрешенные, КодЯзыка)[Ссылка];
		Если ЗначенияРеквизитовОбъекта <> Неопределено Тогда
			Для Каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Если СтрНайти(ИмяПоля, ".") = 0 И ЗначенияРеквизитовОбъекта.Свойство(ИмяПоля) Тогда
					Результат[КлючИЗначение.Ключ] = ЗначенияРеквизитовОбъекта[ИмяПоля];
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(РеквизитыЧерезТочку) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Реквизиты = РеквизитыЧерезТочку;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|&ТекстЗапросаПолей
		|ИЗ
		|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка";
	
	Если Не ВыбратьРазрешенные Тогда 
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекстЗапросаПолей", ТекстЗапросаПолей);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
	
	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип("Структура") = ТипЗнч(Реквизиты)
			Или Тип("ФиксированнаяСтруктура") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;
		
		// Поиск ошибки доступности полей.
		Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъекта", Результат.ОписаниеОшибки);
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значения реквизитов, прочитанные из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылки - Массив из ЛюбаяСсылка
//         - ФиксированныйМассив из ЛюбаяСсылка - ссылки на объекты.
//           Если массив пуст, то результатом будет пустое соответствие.
//  Реквизиты - Строка - имена реквизитов перечисленные через запятую, в формате требований к свойствам
//                       структуры. Например, "Код, Наименование, Родитель".
//            - Массив из Строка
//            - ФиксированныйМассив из Строка - имена реквизитов в формате требований к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя;
//                                если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                будет исключен и из результата;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//  КодЯзыка - Строка - код языка для мультиязычного реквизита. Значение по умолчанию - основной язык конфигурации.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
// 
// Из модуля ОбщегоНазанчения
//
Функция ЗначенияРеквизитовОбъектов(Ссылки, Знач Реквизиты, ВыбратьРазрешенные = Ложь, Знач КодЯзыка = Неопределено) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Реквизиты = СтрСоединить(Реквизиты, ",");
	КонецЕсли;
	
	Если ПустаяСтрока(Реквизиты) Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Поле объекта должно быть указано.'"), "Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
	КонецЕсли;
	
	Если СтрНайти(Реквизиты, ".") <> 0 Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Неверный второй параметр %1 в функции %2: 
				|Обращение через точку не поддерживается.'"), "Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
	КонецЕсли;
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(КодЯзыка) Тогда
		КодЯзыка = СтрРазделить(КодЯзыка, "_", Истина)[0];
	КонецЕсли;
	
	РеквизитыТекстЗапроса = Реквизиты;
	
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого Ссылка Из Ссылки Цикл
		Тип = ТипЗнч(Ссылка);
		Если СсылкиПоТипам[Тип] = Неопределено Тогда
			СсылкиПоТипам[Тип] = Новый Массив;
		КонецЕсли;
		ЭлементПоТипу = СсылкиПоТипам[Тип]; // Массив
		ЭлементПоТипу.Добавить(Ссылка);
	КонецЦикла;
	
	ТекстыЗапросов = Новый Массив;
	ПараметрыЗапроса = Новый Структура;
	
	ИменаОбъектовМетаданных = Новый Массив;
	
	Для Каждого СсылкиПоТипу Из СсылкиПоТипам Цикл
		Тип = СсылкиПоТипу.Ключ;
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Неверный первый параметр %1 в функции %2: 
					|Значения массива должны быть ссылками.'"), "Ссылки", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов");
		КонецЕсли;
		
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
		ИменаОбъектовМетаданных.Добавить(ПолноеИмяОбъектаМетаданных);
		
		ТекстЗапроса =
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	Ссылка,
			|	&Реквизиты
			|ИЗ
			|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
			|ГДЕ
			|	ПсевдонимЗаданнойТаблицы.Ссылка В (&Ссылки)";
		Если Не ВыбратьРазрешенные Или ТекстыЗапросов.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Реквизиты", РеквизитыТекстЗапроса);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
		ИмяПараметра = "Ссылки" + СтрЗаменить(ПолноеИмяОбъектаМетаданных, ".", "");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Ссылки", "&" + ИмяПараметра); // @Query-part-1
		ПараметрыЗапроса.Вставить(ИмяПараметра, СсылкиПоТипу.Значение);
		
		ТекстыЗапросов.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	ТекстЗапроса = СтрСоединить(ТекстыЗапросов, Символы.ПС + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("КодЯзыка", КодЯзыка);
	Для Каждого Параметр Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
		
		// Поиск ошибки доступности полей.
		СписокОшибок = Новый Массив;
		Для Каждого ПолноеИмяОбъектаМетаданных Из ИменаОбъектовМетаданных Цикл
			Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
			Если Результат.Ошибка Тогда 
				СписокОшибок.Добавить(Результат.ОписаниеОшибки);
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СписокОшибок) Тогда
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Неверный второй параметр %1 в функции %2: %3'"), 
				"Реквизиты", "ОбщегоНазначения.ЗначенияРеквизитовОбъектов", СтрСоединить(СписокОшибок, Символы.ПС));
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(Реквизиты);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
		
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Выполняет поиск проверяемых выражений среди реквизитов объекта метаданных.
// 
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
// 
// Возвращаемое значение:
//  Структура:
//   * Ошибка         - Булево - найдена ошибка.
//   * ОписаниеОшибки - Строка - описание найденных ошибок.
//
// Пример:
//  
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.НайтиОшибкуДоступностиРеквизитовОбъекта("Документ._ДемоЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
// Из модуля ОбщегоНазанчения
// 
Функция НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения)
	
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина, 
			СтрШаблон(
				НСтр("ru = 'Ошибка получения метаданных ""%1"".'"), ПолноеИмяОбъектаМетаданных));
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Схема = Новый СхемаЗапроса;
	Пакет = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);
	
	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";
	
	Для Каждого ТекущееВыражение Из ПроверяемыеВыражения Цикл
		
		Если Не ПолеИсточникаСхемыЗапросаДоступно(Источник, ТекущееВыражение) Тогда 
			ТекстОшибки = 
				ТекстОшибки + Символы.ПС + 
				СтрШаблон(
					НСтр("ru = 'Поле объекта ""%1"" не существует.'"), ТекущееВыражение
					);
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);
	
КонецФункции 

// Используется в НайтиОшибкуДоступностиРеквизитовОбъекта.
// Выполняет проверку доступности поля проверяемого выражения в источнике оператора схемы запроса.
//
// Из модуля ОбщегоНазанчения
//
Функция ПолеИсточникаСхемыЗапросаДоступно(ИсточникОператора, ПроверяемоеВыражение)
	
	ЧастиИмениПоля = СтрРазделить(ПроверяемоеВыражение, ".");
	ДоступныеПоля = ИсточникОператора.Источник.ДоступныеПоля;
	
	ТекущаяЧастьИмениПоля = 0;
	Пока ТекущаяЧастьИмениПоля < ЧастиИмениПоля.Количество() Цикл 
		
		ТекущееПоле = ДоступныеПоля.Найти(ЧастиИмениПоля.Получить(ТекущаяЧастьИмениПоля)); 
		
		Если ТекущееПоле = Неопределено Тогда 
			Возврат Ложь;
		КонецЕсли;
		
		// Инкрементация следующей части имени поля и соответствующего списка доступности полей.
		ТекущаяЧастьИмениПоля = ТекущаяЧастьИмениПоля + 1;
		ДоступныеПоля = ТекущееПоле.Поля;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ПолноеИмяНеУказанногоПользователя() Экспорт
	
	Возврат НСтр("ru = '<Не указан>'");
	
КонецФункции

// Из модуля ОбщегоНазначения
Функция СкопироватьРекурсивно(Источник, ФиксироватьДанные = Неопределено) Экспорт
	
	Перем Приемник;
	
	ТипИсточника = ТипЗнч(Источник);
	
	Если ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Возврат Источник.Скопировать();
	КонецЕсли;
	
	Если ТипИсточника = Тип("Структура")
		Или ТипИсточника = Тип("ФиксированнаяСтруктура") Тогда
		Приемник = СкопироватьСтруктуру(Источник, ФиксироватьДанные);
	ИначеЕсли ТипИсточника = Тип("Соответствие")
		Или ТипИсточника = Тип("ФиксированноеСоответствие") Тогда
		Приемник = СкопироватьСоответствие(Источник, ФиксироватьДанные);
	ИначеЕсли ТипИсточника = Тип("Массив")
		Или ТипИсточника = Тип("ФиксированныйМассив") Тогда
		Приемник = СкопироватьМассив(Источник, ФиксироватьДанные);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		Приемник = СкопироватьСписокЗначений(Источник, ФиксироватьДанные);
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

Функция СкопироватьСтруктуру(СтруктураИсточник, ФиксироватьДанные)
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого КлючИЗначение Из СтруктураИсточник Цикл
		СтруктураРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение, ФиксироватьДанные));
	КонецЦикла;
	
	Если ФиксироватьДанные = Истина 
		Или ФиксироватьДанные = Неопределено
		И ТипЗнч(СтруктураИсточник) = Тип("ФиксированнаяСтруктура") Тогда 
		
		Возврат Новый ФиксированнаяСтруктура(СтруктураРезультат);
	КонецЕсли;
	
	Возврат СтруктураРезультат;
	
КонецФункции

Функция СкопироватьСоответствие(СоответствиеИсточник, ФиксироватьДанные)
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение, ФиксироватьДанные));
	КонецЦикла;
	
	Если ФиксироватьДанные = Истина 
		Или ФиксироватьДанные = Неопределено
		И ТипЗнч(СоответствиеИсточник) = Тип("ФиксированноеСоответствие") Тогда 
		Возврат Новый ФиксированноеСоответствие(СоответствиеРезультат);
	КонецЕсли;
	
	Возврат СоответствиеРезультат;
	
КонецФункции

Функция СкопироватьМассив(МассивИсточник, ФиксироватьДанные)
	
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент Из МассивИсточник Цикл
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент, ФиксироватьДанные));
	КонецЦикла;
	
	Если ФиксироватьДанные = Истина 
		Или ФиксироватьДанные = Неопределено
		И ТипЗнч(МассивИсточник) = Тип("ФиксированныйМассив") Тогда 
		Возврат Новый ФиксированныйМассив(МассивРезультат);
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции

Функция СкопироватьСписокЗначений(СписокИсточник, ФиксироватьДанные)
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение, ФиксироватьДанные), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

// Определяет смещение времени сервера относительно времени программы.
//
// Возвращаемое значение:
//   Число - смещение времени в секундах.
//       Может использоваться для приведения фильтров, применяемых к журналу, к дате сервера,
//       а также для приведения дат, полученных из журнала, к датам программы.
//
// Из модуля ЖурналРегистрации
//
Функция СмещениеВремениСервера() Экспорт
	
	СмещениеВремениСервера = ТекущаяДата() - ТекущаяДатаСеанса(); // АПК:143 Требуется дата компьютера
	Если СмещениеВремениСервера >= -1 И СмещениеВремениСервера <= 1 Тогда
		СмещениеВремениСервера = 0;
	КонецЕсли;
	Возврат СмещениеВремениСервера;
	
КонецФункции

// Из модуля ОбщегоНазначенияСлужебныйКлиентСервер
Функция СообщениеПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных,
		Знач Поле,
		Знач ПутьКДанным = "",
		Отказ = Ложь,
		ЭтоОбъект = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
	
	Отказ = Истина;
	
	Возврат Сообщение;
	
КонецФункции

// Формирует и выводит сообщение, которое может быть связано с элементом управления формы.
// В фоновом задании длительной операции отправляет сообщение сразу на клиент,
// если подключена система взаимодействия.
//
// АПК:142-выкл 4 необязательных параметра для совместимости 
// с устаревшей процедурой ОбщегоНазначенияКлиентСервер.СообщитьПользователю.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле - Строка - наименование реквизита формы.
//  ПутьКДанным - Строка - путь к данным (путь к реквизиту формы).
//  Отказ - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначения.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимого.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
// Из модуля ОбщегоНазначения
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю, Знач КлючДанных = Неопределено,	Знач Поле = "",
	Знач ПутьКДанным = "", Отказ = Ложь) Экспорт
	
	ЭтоОбъект = Ложь;
	
	Если КлючДанных <> Неопределено
		И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
	
	Сообщение = 
		общ.СообщениеПользователю(
			ТекстСообщенияПользователю,
			КлючДанных, 
			Поле, 
			ПутьКДанным, 
			Отказ, 
			ЭтоОбъект
			);
		
	Сообщение.Сообщить();

КонецПроцедуры

// Сравнить две строки версий.
//
// Параметры:
//  СтрокаВерсии1  - Строка - номер версии в формате РР.{П|ПП}.ЗЗ.СС.
//  СтрокаВерсии2  - Строка - второй сравниваемый номер версии.
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//  
// Заяш 251209 10:25 Добавил обработку случая передачи версии без номера сборки
// формата "0.0.0", РР.{П|ПП}.ЗЗ
//
Функция СравнитьВерсии(Знач пВерсия1, Знач пВерсия2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(пВерсия1), "0.0.0.0", пВерсия1);
	Строка2 = ?(ПустаяСтрока(пВерсия2), "0.0.0.0", пВерсия2);
	частиВерсии1 = СтрРазделить(Строка1, ".");
	Если частиВерсии1.Количество() = 3 Тогда
		частиВерсии1.Добавить("0");
		
	КонецЕсли;
	
	Если частиВерсии1.Количество() <> 4 Тогда
		ВызватьИсключение СтрШаблон("Неправильный формат параметра %1: %2", "СтрокаВерсии1", пВерсия1);
		
	КонецЕсли;
	
	частиВерсии2 = СтрРазделить(Строка2, ".");
	Если частиВерсии2.Количество() = 3 Тогда
		частиВерсии2.Добавить("0");
		
	КонецЕсли;
	
	Если частиВерсии2.Количество() <> 4 Тогда
		ВызватьИсключение СтрШаблон("Неправильный формат параметра %1: %2", "СтрокаВерсии2", пВерсия2);
		
	КонецЕсли;
	
	разницаВерсий = 0;
	Для индекс = 0 По 3 Цикл
		разницаВерсий = Число(частиВерсии1[индекс]) - Число(частиВерсии2[индекс]);
		
		Если разницаВерсий <> 0 Тогда
			Возврат разницаВерсий;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат разницаВерсий;
	
КонецФункции

#КонецОбласти  // Типовые




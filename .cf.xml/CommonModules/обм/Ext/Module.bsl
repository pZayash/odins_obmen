// BSLLS:IncorrectLineBreak-off

#Область ПрограммныйИнтерфейс

#Область ФорматОбмАльфа

Функция ОбразОбъекта_СоздатьВФорматеОбмАльфа(пИсточник) Экспорт
	образ = общ.Коллекция_ПоСсылке(пИсточник);
	уровень = 2;
	общ.Коллекция_РазвернутьСсылки(образ, уровень);
	ОбразОбъекта_ПодписатьМетаданнымиОбмАльфа(образ);
	
	образ.Вставить("_Формат", обм_лит.ФорматОбмАльфа());
	
	Возврат Образ_ПривестиКСтроке(образ);
	
КонецФункции

// @TODO 250728 Заяш: заменяет общ.Ссылка_ПоКоллекции. Найти и удалить старое
// Функция обратная ЗначениеВJSON для ссылочных объектов
Функция Ссылка_ПоОбразуВФорматеОбмАльфа(пОбразАльфа) Экспорт
	
	Если НЕ общ.ЭтоКоллекцияКлючЗначение(пОбразАльфа) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	типСсылки = Неопределено;
	стрТипСсылки = Неопределено;
	Если общ.Коллекция_Свойство(пОбразАльфа, "_Тип", стрТипСсылки) Тогда
		типСсылки = общ.Тип_ПоСтроке(стрТипСсылки);
	КонецЕсли;
	
	Если НЕ общ.Тип_ЭтоСсылка(типСсылки) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// 0. Значение перечисления
	этоПеречисление = Перечисления.ТипВсеСсылки().СодержитТип(типСсылки);
	Если этоПеречисление Тогда
		перечисление_менеджер = общ.Менеджер_ПоОбъекту(типСсылки);
		Если Общ.Коллекция_Свойство(пОбразАльфа, "_ПустаяСсылка") Тогда
			Возврат перечисление_менеджер.ПустаяСсылка();
			
		КонецЕсли;
		
		имяПеречисления = "";
		Если НЕ общ.Коллекция_Свойство(пОбразАльфа, "_Значение") Тогда
			Возврат Неопределено;
			
		КонецЕсли;
		
		мета = перечисление_менеджер.пустаяСсылка().Метаданные();
		перечисление_существует = мета.ЗначенияПеречисления.Найти(имяПеречисления) <> Неопределено;
		Если перечисление_существует Тогда
			Возврат перечисление_менеджер[имяПеречисления];
			
		Иначе
			Возврат Неопределено;
			
		КонецЕсли;
		
	КонецЕсли; // этоПеречисление
	
	// 1. Искать по навигационной ссылке
	навигационнаяСсылка = Неопределено;
	естьНавигационнаяСсылка =
		общ.Коллекция_Свойство(пОбразАльфа, "_НавигационнаяСсылка", навигационнаяСсылка)
		И ЗначениеЗаполнено(навигационнаяСсылка)
		;
	
	Если естьНавигационнаяСсылка Тогда
		ссылкаРезультат = общ.Ссылка_ПоНавигационнойСсылке(навигационнаяСсылка);
		Если общ.ЭтоЗаполненнаяСсылка(ссылкаРезультат) Тогда
			Возврат ссылкаРезультат;
			
		Иначе
			ссылкаРезультат = Неопределено;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// 2. Искать по типу и уникальному идентификатору
	менеджер = общ.Менеджер_ПоОбъекту(типСсылки);
	
	уид = Неопределено;
	Если 	общ.Коллекция_Свойство(пОбразАльфа, "_УникальныйИдентификатор", уид) 
		И 	общ.Строка_ЭтоУникальныйИдентификатор(уид) 
		Тогда
		ссылкаРезультат = менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(пОбразАльфа["_УникальныйИдентификатор"]));
		
	Иначе
		ссылкаРезультат = менеджер.ПустаяСсылка();
		
	КонецЕсли;
	
	Возврат ссылкаРезультат;
	
КонецФункции

#КонецОбласти // ФорматОбмАльфа

#Область Отправка

// Для использования в переопределяемых обработчиках интерфейсов
Функция Отправить_HTTP_POST(пСообщение, пПараметры, текстОтвета = Неопределено) Экспорт
	
		кодСостояния = 501; // Не выполнено
		
		адресРесурса = общ.Коллекция_ЗначениеПоПути(пПараметры, "АдресРесурса");
		
		Если НЕ ЗначениеЗаполнено(адресРесурса) Тогда
			кодСостояния = 422; // 422 Unprocessable Entity
			Возврат кодСостояния;
			
		КонецЕсли;
		
		заголовки = Новый Соответствие;
		заголовки.Вставить("Content-Charset", "utf-8");
		заголовки.Вставить("Content-Type", "text/plain; charset=utf-8");
		
		// Добавить в заголовки элементы, если они переданы в параметрах
		пЗаголовки = общ.Коллекция_ЗначениеПоПути(пПараметры, "Заголовки");
		Если общ.ЭтоКоллекцияКлючЗначение(пЗаголовки) Тогда
			Для Каждого пара Из пЗаголовки Цикл
				заголовки.Вставить(пара.Ключ, пара.Значение);
				
			КонецЦикла;
			пара = Неопределено;
			
		КонецЕсли;
		
		запрос = Новый HTTPЗапрос(адресРесурса, заголовки);
		
		// Сформировать сообщение
		стрСообщение = "";
		Если
			общ.ЭтоКоллекцияКлючЗначение(пСообщение)
			ИЛИ общ.ЭтоСсылка(пСообщение)
			Тогда
			стрСообщение = общ.JSON(пСообщение);
			заголовки.Вставить("Content-Type", "application/json");
			
		ИначеЕсли ТипЗнч(пСообщение) = Тип("Строка") Тогда
			стрСообщение = пСообщение;
			
		Иначе
			стрСообщение = Строка(пСообщение);
			
		КонецЕсли;
		
		запрос.УстановитьТелоИзСтроки(стрСообщение, КодировкаТекста.UTF8);
		
		сервер = общ.Коллекция_ЗначениеПоПути(пПараметры, "Сервер");
		
		соединение = Новый HTTPСоединение(сервер);
		ЗаполнитьЗначенияСвойств(соединение, пПараметры);
		
		ответ = соединение.ВызватьHTTPМетод("POST", запрос);
		
		// Получить тело ответа из временного файла
		кодировка = КодировкаТекста.UTF8; // Кодировка по умолчанию
		
		// Если в заголовка ответа есть свойство "Content-Encoding", то из него получить кодировку
		Если ответ.Заголовки.Получить("Content-Encoding") = "ANSI" Тогда
			кодировка = "windows-1251"; // указывать кодировку явно, на Linux сервере кодировка ANSI не 1251
			
		КонецЕсли;
		
		имяСобытия = ИмяСобытияЖурналаРегистрации("Отправка.Отправить_HTTP_POST"); 
		текстОтвета = ответ.ПолучитьТелоКакСтроку(кодировка);
		уровеньЖурнала = ?(кодСостояния = 200, УровеньЖурналаРегистрации.Информация, УровеньЖурналаРегистрации.Ошибка);
		общ.ВЖурнал(имяСобытия, текстОтвета, уровеньЖурнала);

		Возврат кодСостояния;
	
КонецФункции

#КонецОбласти // Отправка

#Область Получение

// Обработать все необработанные запросы
Процедура Получение_ОбработатьОчередь(пИзвлечьПакетыДанных = Истина, пОбработатьПакетыДанных = Истина) Экспорт
	
	// 0. Запрос поиска входящих запросов в определенном статусе
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 100
		|	Т.ВходящееСообщение КАК Ссылка
		|ИЗ
		|	РегистрСведений.обм_ВходящиеСообщения_Статусы.СрезПоследних КАК Т
		|ГДЕ
		|	Т.Статус В(&СтатусДляПоиска)
		|	И НЕ Т.ВходящееСообщение.ПометкаУдаления
		|
		|УПОРЯДОЧИТЬ ПО
		|	Т.Период";
	
	Пока Истина Цикл
		счетчик = 0;
		
		// 1. Сначала найти все входящие запросы в статусе "Ждет обработки" и завершить их обработку
		Если пОбработатьПакетыДанных Тогда
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.ЖдетОбработки);
			входящиеСообщения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
			
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Обработать(входящиеСообщения);
			
			счетчик = счетчик + входящиеСообщения.Количество();
			
		КонецЕсли;
		
		// 2. Найти все входящие запросы в статусе "Получен" и обработать их
		Если пИзвлечьПакетыДанных Тогда
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.Получен);
			входящиеСообщения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
			
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Извлечь(входящиеСообщения);
			
			счетчик = счетчик + входящиеСообщения.Количество();
			
		КонецЕсли;
		
		Если счетчик = 0 Тогда
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла; // Пока Истина Цикл
	счетчик = Неопределено;
	
КонецПроцедуры

Процедура Получение_ФоновоеЗадание() Экспорт
	
	метаЗадания = Метаданные.РегламентныеЗадания.обм_Получение_2_ПакетыДанных_Обработать;
	Ключ = метаЗадания.Ключ;
	Наименование = метаЗадания.Наименование;
	
	Если общ.ИнформационнаяБаза_Файловая() Тогда
		Получение_ОбработатьОчередь();
		Возврат;
		
	КонецЕсли;
	
	Активно = Ложь;
	Для Каждого ФЗ Из ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Ключ", Ключ)) Цикл
		Если ФЗ.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			Активно = Истина; Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	ФЗ = Неопределено;
	
	Если НЕ Активно Тогда
		ФоновыеЗадания.Выполнить(
			"обм.Получение_ОбработатьОчередь", // ИмяМетода
			Новый Массив, // Параметры
			Ключ, // Ключ
			Наименование // Наименование
		);
		
	КонецЕсли;
	
КонецПроцедуры

// Обертка функций модуля менеджера справочника обм_ВходящиеСообщения,
// чтобы их можно было вызывать с клиента
#Область ВходящиеСообщения_ИнтерфейсДляКлиента

Функция ВходящееСообщение_Параметр_Значение(пВходящееСообщениеСсылка, КлючПараметра) Экспорт
	
	Возврат Справочники.обм_ВходящиеСообщения.Параметр_Значение(пВходящееСообщениеСсылка, КлючПараметра);
	
КонецФункции

Функция ВходящееСообщение_СсылкаПоHTTPСервисОтвет(пОтветХТТП) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off
	
	#Если ВнешнееСоединение Тогда
	Возврат Неопределено;
	
	#Иначе
	общ.Проверка_Тип(пОтветХТТП, Тип("HTTPСервисОтвет"));
	
	#КонецЕсли
	
	Если пОтветХТТП.КодСостояния <> Код200() Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Тело ответа содержит:
	//ТекстОтвета =
	//	СтрШаблон(
	//		"{""Status"":""RequestReceived"",
	//		|""Ticket"":""%1""
	//		|}",
	//		Строка(ВходящийЗапрос_Объект.Ссылка.УникальныйИдентификатор())
	//		);
	// см. функцию Запрос_Записать
	
	стрОтвет = пОтветХТТП.ПолучитьТелоКакСтроку();
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		образ = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Если ТипЗнч(образ) <> Тип("Соответствие") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	стрИД = образ["Ticket"];
	
	Если стрИД = Неопределено Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Справочники.обм_ВходящиеСообщения.ПолучитьСсылку(Новый УникальныйИдентификатор(стрИД));
	
КонецФункции

Функция ВходящееСообщение_ОшибкаИзHTTPСервисОтвет(пОтветХТТП) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off
	
	#Если ВнешнееСоединение Тогда
	Возврат Неопределено;
	
	#Иначе
	общ.Проверка_Тип(пОтветХТТП, Тип("HTTPСервисОтвет"));
	
	#КонецЕсли
	
	// 200 значит нет ошибки
	Если пОтветХТТП.КодСостояния = Код200() Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Тело ответа содержит:
	//ТекстОтвета =
	//СтрШаблон(
	//	"{""Error"":""%1""}",
	//	
	// см. функцию Запрос_Записать
	
	стрОтвет = пОтветХТТП.ПолучитьТелоКакСтроку();
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		образ = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Если ТипЗнч(образ) <> Тип("Соответствие") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	обОшибке = образ["Error"];
	
	Если обОшибке = Неопределено ИЛИ ПустаяСтрока(обОшибке) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат обОшибке;
	
КонецФункции

Функция ВходящееСообщение_Создать(	пХТТПСервисЗапрос, 
									пНаименованиеЗапроса = Неопределено, 
									пОбработатьВФоне = Истина
									) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	имяСобытия = ИмяСобытияЖурналаРегистрации("Получение.ВходящееСообщение_Создать");
	
	HTTPСервисЗапрос_ЗарегистрироватьВЖурнале(имяСобытия, пХТТПСервисЗапрос);
	
	кодСостояния = 400;
	текстОтвета = "";
	
	Попытка
		ВходящееСообщение_Объект = Справочники.обм_ВходящиеСообщения.СоздатьЭлемент();
		СсылкаНового = Справочники.обм_ВходящиеСообщения.ПолучитьСсылку();
		ВходящееСообщение_Объект.ДополнительныеСвойства.Вставить("СсылкаНового", СсылкаНового);
		ВходящееСообщение_Объект.УстановитьСсылкуНового(СсылкаНового);
		
		Если НЕ ПустаяСтрока(пНаименованиеЗапроса) Тогда
			ВходящееСообщение_Объект.Наименование = СокрЛП(пНаименованиеЗапроса);
			
		Иначе
			ВходящееСообщение_Объект.Наименование = Строка(ТипЗнч(пХТТПСервисЗапрос));
			
		КонецЕсли;
		ВходящееСообщение_Объект.Наименование = СтрШаблон(	"%1 %2",
															ВходящееСообщение_Объект.Наименование, // %1
															Строка(СсылкаНового.УникальныйИдентификатор()) // %2
															);
		
		ВходящееСообщение_Объект.ДатаВремя = общ.ДатаУниверсальная();
		ВходящееСообщение_Объект.Запрос = пХТТПСервисЗапрос.ПолучитьТелоКакСтроку();
		
		ЗаполнитьЗначенияСвойств(ВходящееСообщение_Объект, пХТТПСервисЗапрос);
		
		Для Каждого КлючИЗначение Из пХТТПСервисЗапрос.ПараметрыURL Цикл
			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = КлючИЗначение.Ключ;
			тчПараметры_Строка.Значение = КлючИЗначение.Значение;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.URL;
			
		КонецЦикла;
		КлючИЗначение = Неопределено;
		
		Для Каждого КлючИЗначение Из пХТТПСервисЗапрос.ПараметрыЗапроса Цикл
			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = КлючИЗначение.Ключ;
			тчПараметры_Строка.Значение = КлючИЗначение.Значение;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.Запрос;
			
		КонецЦикла;
		
		// Добавить текущего пользователя
		тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
		тчПараметры_Строка.Ключ = "ТекущийПользователь_Имя";
		тчПараметры_Строка.Значение = ТекущийПользователь_Имя();
		тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
		
		Если ТипЗнч(пНаименованиеЗапроса) = Тип("Строка") И ЗначениеЗаполнено(пНаименованиеЗапроса) Тогда
			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = "Метод";
			тчПараметры_Строка.Значение = пНаименованиеЗапроса;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
			
		ИначеЕсли ТипЗнч(пНаименованиеЗапроса) = Тип("Структура") Тогда
			Для Каждого Пара Из пНаименованиеЗапроса Цикл
				тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
				тчПараметры_Строка.Ключ = Пара.Ключ;
				тчПараметры_Строка.Значение = Пара.Значение;
				тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
				
			КонецЦикла;
			Пара = Неопределено;
			
		КонецЕсли;
		
		Для Каждого КлючИЗначение Из пХТТПСервисЗапрос.Заголовки Цикл
			
			// Данные авторизации не фиксировать
			Если НРег(КлючИЗначение.Ключ) = "authorization" Тогда
				Продолжить;
				
			КонецЕсли;
			
			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = КлючИЗначение.Ключ;
			тчПараметры_Строка.Значение = КлючИЗначение.Значение;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.ЗаголовокHTTP;
			
		КонецЦикла;
		КлючИЗначение = Неопределено;
		
		// Чтобы запрос не обрабатывался регламентным заданием, пометить его на удаление
		// см. Получение_ОбработатьОчередь
		Если НЕ пОбработатьВФоне Тогда
			ВходящееСообщение_Объект.ПометкаУдаления = Истина;
			
		КонецЕсли;
		
		ВходящееСообщение_Объект.Параметры.Сортировать("Ключ");
		
		ВходящееСообщение_Объект.Записать();
		
		кодСостояния = 200;
		уид = Строка(ВходящееСообщение_Объект.Ссылка.УникальныйИдентификатор());
		текстОтвета =
			СтрШаблон(
				"{""Status"":""RequestReceived"",
				|""Ticket"":""%1""
				|}",
				уид // %1
			);
		
	Исключение
		инфоОшибки = ИнформацияОбОшибке();
		общ.Ошибка_ВЖурналРегистрации(имяСобытия, инфоОшибки);
		
		кодСостояния = 500;
		текстОтвета =
			СтрШаблон(
				"{""Error"":""%1""}",
				общ.Ошибка_КраткоеПредставление(инфоОшибки) // %1
			);

	КонецПопытки;
	
	#Если ВнешнееСоединение Тогда
	Ответ = текстОтвета;
	
	#Иначе
	Ответ = Новый HTTPСервисОтвет(кодСостояния);
	Ответ.Заголовки.Вставить("Content-Type", "text/html; charset=utf-8");
	Ответ.УстановитьТелоИзСтроки(текстОтвета);
	
	#КонецЕсли
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Ответ;
	
КонецФункции

Функция ВходящееСообщение_СоздатьЧерезHTTPЗапросЭмуляция(	пУРЛ,  // BSLLS:LatinAndCyrillicSymbolInWord-off
															пДанные,
															пПараметрыЗапроса = Неопределено, 
															пНаименованиеЗапроса = Неопределено, 
															пОбработатьСразу = Ложь
															) Экспорт
	
	общ.Проверка_Тип(пПараметрыЗапроса, "Структура, Соответствие, Неопределено");
	
	эмулятор = Обработки.обм_HTTPЗапросЭмуляция.Создать();
	
	эмулятор.HTTPМетод = "POST";
	
	эмулятор.БазовыйURL = "emul://" + пУРЛ;
	эмулятор.ОтносительныйURL = пУРЛ;
	
	Если ТипЗнч(пДанные) = Тип("Строка") Тогда
		эмулятор.Тело = пДанные;
		
	ИначеЕсли ТипЗнч(пДанные) = Тип("ДвоичныеДанные") Тогда
		эмулятор.Тело = Base64Строка(пДанные);
		
	ИначеЕсли 	ТипЗнч(пДанные) = Тип("Массив") 
			ИЛИ ТипЗнч(пДанные) = Тип("Структура") 
			ИЛИ ТипЗнч(пДанные) = Тип("Соответствие") 
			Тогда
		эмулятор.Тело = Общ.JSON(пДанные);
		
	Иначе
		эмулятор.Тело = Строка(пДанные);
		
	КонецЕсли;
	
	Если пПараметрыЗапроса <> Неопределено Тогда
		Для Каждого Пара Из пПараметрыЗапроса Цикл
			эмулятор.ПараметрыЗапроса.Вставить(Пара.Ключ, Пара.Значение);
			
		КонецЦикла;
		Пара = Неопределено;
		
	КонецЕсли;
	
	// Для предотвращения конфликта между регламентным заданием и обработкой при загрузке пользователем из формы
	// Запретить обработку регламентным заданием
	обработатьВФоне = НЕ пОбработатьСразу;
	ответОЗаписиЗапроса = ВходящееСообщение_Создать(эмулятор, пНаименованиеЗапроса, обработатьВФоне);
	
	Если ответОЗаписиЗапроса.КодСостояния = Код200() И пОбработатьСразу Тогда
		входящееСообщениеСсылка = ВходящееСообщение_СсылкаПоHTTPСервисОтвет(ответОЗаписиЗапроса);
		
		Если ЗначениеЗаполнено(входящееСообщениеСсылка) Тогда
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Извлечь(входящееСообщениеСсылка);
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Обработать(входящееСообщениеСсылка);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ответОЗаписиЗапроса;
	
КонецФункции

#КонецОбласти // ВходящиеСообщения_ИнтерфейсДляКлиента

#КонецОбласти // Получение

#Область Прочее

Процедура HTTPСервисЗапрос_ЗарегистрироватьВЖурнале(пИмяСобытия, пЗапросХТТП) Экспорт
	
	общ.Проверка_Тип(пЗапросХТТП, Тип("HTTPСервисЗапрос"));
	
	рез = "";
	
	рез = рез + пЗапросХТТП.HTTPМетод + Символы.ПС;
	рез = рез + пЗапросХТТП.БазовыйURL + Символы.ПС;
	рез = рез + пЗапросХТТП.ОтносительныйURL + Символы.ПС;
	рез = рез + "Заголовки:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.Заголовки Цикл
		
		// Данные авторизации не фиксировать
		Если НРег(Параметр.Ключ) = "authorization" Тогда
			Продолжить;
			
		КонецЕсли;
		
		Заг = СтрЗаменить(Параметр.Значение, ";", "");
		рез = рез + Параметр.Ключ + ":" + Заг + Символы.ПС;
	КонецЦикла;
	рез = рез + "Параметры URL:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.ПараметрыURL Цикл
		рез = рез + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;
	рез = рез + "Параметры запроса:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.ПараметрыЗапроса Цикл
		рез = рез + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;
	
	рез = рез + "BODY:" + пЗапросХТТП.ПолучитьТелоКакСтроку() + Символы.ПС;
	
	ЗаписьЖурналаРегистрации(пИмяСобытия, , , , рез);
	
КонецПроцедуры

Функция ИмяСобытияЖурналаРегистрации(пИмяСобытия = "") Экспорт
	
	результат = "обм";
	
	Если НЕ ПустаяСтрока(пИмяСобытия) Тогда
		результат = результат + "." + СокрЛП(пИмяСобытия);
		
	КонецЕсли;
	
	Возврат результат;
	
КонецФункции

Функция ТекущийПользователь_Имя() Экспорт
	
	// Если не найдено, возвращать текущего пользователя ИБ
	Возврат ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
	
КонецФункции

Функция УРИ(пУзел, пКатегория, пИдентификатор) Экспорт
	
	УзелПривести(пУзел);
	
	стрУРИ = СтрШаблон("odins_obmen/%1/%2/%3", пУзел, пКатегория, пИдентификатор);
	
	Возврат стрУРИ;
	
КонецФункции

Функция УзелПривести(пУзел) Экспорт
	
	пУзел = НРег(СокрЛП(пУзел));
	
	Если ПустаяСтрока(пУзел) Тогда
		пУзел = Неопределено;
		
	КонецЕсли;
	
	Возврат пУзел;
	
КонецФункции

#КонецОбласти // Прочее

#КонецОбласти // ВнешнийИнтерфейс

#Область СлужебныйПрограммныйИнтерфейс

#Область РегламентныеЗадания

Процедура Отправка_1_ИсходящиеСообщения_Создать() Экспорт
	
	РегистрыСведений.обм_Измененные.ОбработатьОчередьИзмененных();
	
КонецПроцедуры

Процедура Отправка_2_ИсходящиеСообщения_Отправить() Экспорт
	
	РегистрыСведений.обм_КОтправке.ОбработатьОчередьОтправки();
	
КонецПроцедуры

Процедура Получение_1_ПакетыДанных_Извлечь() Экспорт
	
	Получение_ОбработатьОчередь(
		Истина, // извлечь пакеты данных
		Ложь // обработать пакеты данных
	);
	
КонецПроцедуры

Процедура Получение_2_ПакетыДанных_Обработать() Экспорт
	
	Получение_ОбработатьОчередь(
			Ложь, // извлечь пакеты данных
			Истина // обработать пакеты данных
			);
	
КонецПроцедуры

#КонецОбласти // РегламентныеЗадания

#Область ПодпискиНаСобытия

Процедура ПриЗаписи(пИсточник, пОтказ = Ложь) Экспорт
	
	Если пИсточник.ОбменДанными.Загрузка Тогда
		Возврат;
		
	КонецЕсли;
	
	// Справочник общ.Обработчики пропускаем
	Если ТипЗнч(пИсточник) = Тип("СправочникОбъект.общ_Обработчики") Тогда
		Возврат;
		
	КонецЕсли;
	
	// В скрипты передаем не сам объект, а ссылку на него
	// Так надо, чтобы в скрипте было невозможно изменить объект или его свойства
	источникСсылка = пИсточник.Ссылка;
	
	узелОтправитель = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_УзелОтправитель(), узелОтправитель);
	УзелПривести(узелОтправитель);
	
	категорияОтправителя = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_КатегорияОтправителя(), категорияОтправителя);
	идентификаторОтправителя = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_ИдентификаторОтправителя(), идентификаторОтправителя);
		
	// т.к. у пользователя может не быть прав на РегистрыСведений.обм_Измененные
	УстановитьПривилегированныйРежим(Истина);
	РегистрыСведений.обм_Измененные.Зарегистрировать(	источникСсылка,
														узелОтправитель,
														категорияОтправителя,
														идентификаторОтправителя		);
	УстановитьПривилегированныйРежим(Ложь);

КонецПроцедуры

#КонецОбласти // Подписки на события

#КонецОбласти // СлужебныйПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

Функция Код200()
	
	Возврат 200;
	
КонецФункции

Процедура ОбразОбъекта_ПодписатьМетаданнымиОбмАльфа(пОбразОбъекта)
	
	обОтправителе = Новый Структура;
	обОтправителе.Вставить("Версия", Метаданные.Версия);
	обОтправителе.Вставить("Имя", Метаданные.Имя);
	обОтправителе.Вставить("Синоним", Метаданные.Синоним);
	обОтправителе.Вставить("ИмяКомпьютера", ИмяКомпьютера());
	обОтправителе.Вставить("ИмяПользователя", ИмяПользователя());
	обОтправителе.Вставить("ИмяИнформационнойБазы", общ.ИнформационнаяБаза_Имя());
	обОтправителе.Вставить("ПолноеИмяПользователя", ПолноеИмяПользователя());
	обОтправителе.Вставить("СтрокаСоединенияИнформационнойБазы", СтрокаСоединенияИнформационнойБазы());
	
	// Текущую дату сеанса не включать в сообщение, потому что она меняется
	// В приемнике изменяется хеш сообщения
	// И приемник считает каждое новое сообщение измененным
	//обОтправителе.Вставить("ТекущаяДатаСеанса", ТекущаяДатаСеанса());
	
	обОтправителе.Вставить("ЧасовойПоясСеанса", ЧасовойПоясСеанса());
	обОтправителе.Вставить("ИдентификаторИнформационнойБазы", общ.ИдентификаторИнформационнойБазы());
	обОтправителе.Вставить("ЭтоТестоваяБаза", общ.ЭтоТестоваяБаза());
	
	си = Новый СистемнаяИнформация;
	обОтправителе.Вставить("ВерсияОС", си.ВерсияОС);
	обОтправителе.Вставить("ВерсияПриложения", си.ВерсияПриложения);
	
	пОбразОбъекта.Вставить("_метаданныеОтправителя", обОтправителе);
	
КонецПроцедуры

Функция Образ_ПривестиКСтроке(пОбраз)
	
	// Формирование строки послания
	стрПослание = Неопределено;
	Если ТипЗнч(пОбраз) = Тип("Строка") Тогда
		стрПослание = пОбраз;
		
	ИначеЕсли общ.ЭтоКоллекцияКлючЗначение(пОбраз) Тогда
		стрПослание = общ.Коллекция_ЗаписатьJSONсСортировкой(пОбраз);
		
	Иначе
		стрПослание = Строка(пОбраз);
		
	КонецЕсли;
	
	Возврат стрПослание;
	
КонецФункции

#КонецОбласти // СлужебныеПроцедурыИФункции
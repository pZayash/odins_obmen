// Инструкции сервисам проверки кода по отступлению от стандартов
//
// BSLLS:IncorrectLineBreak-off // Использую свои методы переноса строк
// BSLLS:UsingServiceTag-off // Чтобы не срабатывали проверки на комментарии @skip-check
// 
// Использую имена переменных с маленькой буквы, чтобы понимать область видимости переменной
// @skip-check bsl-variable-name-invalid

#Область ПрограммныйИнтерфейс

#Область ФорматОбмАльфа

// Отправляет HTTP POST запрос на указанный ресурс
// Приводит сообщение к формату Альфа, если возможно
//
// Параметры:
//	пСообщение - Строка, ЛюбаяСсылка, Структура Из Произвольный - Данные, отправляемые в теле запроса
//	пПараметры - Структура - Параметры запроса (адрес ресурса, сервер и т.д.)
//	текстОтвета - Строка - Текст ответа сервера (по умолчанию Неопределено)
//
// Возвращаемое значение:
//   Число - Код состояния HTTP ответа
//
// Для использования в переопределяемых обработчиках интерфейсов
Функция Альфа_HTTP_POST(пСообщение, пПараметры, текстОтвета = Неопределено) Экспорт

	кодСостояния = 501; // Не выполнено

	адресРесурса = общ.Коллекция_ЗначениеПоПути(пПараметры, "АдресРесурса");

	Если Не ЗначениеЗаполнено(адресРесурса) Тогда
		кодСостояния = 422; // 422 Unprocessable Entity
		Возврат кодСостояния;

	КонецЕсли;

	заголовки = Новый Соответствие;
	заголовки.Вставить("Content-Charset", "utf-8");
	заголовки.Вставить("Content-Type", "text/plain; charset=utf-8");
		
	// Добавить в заголовки элементы, если они переданы в параметрах
	заголовкиВПараметрах = общ.Коллекция_ЗначениеПоПути(пПараметры, "Заголовки");
	Если общ.ЭтоКоллекцияКлючЗначение(заголовкиВПараметрах) Тогда
		//@skip-check bsl-legacy-check-for-each-statetement-collection
		Для Каждого пара Из заголовкиВПараметрах Цикл
			заголовки.Вставить(пара.Ключ, пара.Значение);

		КонецЦикла;
		пара = Неопределено;

	КонецЕсли;

	запрос = Новый HTTPЗапрос(адресРесурса, заголовки);
		
		// Сформировать сообщение
	стрСообщение = "";
	Если общ.ЭтоКоллекцияКлючЗначение(пСообщение) Или общ.ЭтоСсылка(пСообщение) Тогда
		стрСообщение = общ.JSON(пСообщение);
		заголовки.Вставить("Content-Type", "application/json");

	ИначеЕсли ТипЗнч(пСообщение) = Тип("Строка") Тогда
		стрСообщение = пСообщение;

	Иначе
		стрСообщение = Строка(пСообщение);

	КонецЕсли;

	запрос.УстановитьТелоИзСтроки(стрСообщение, КодировкаТекста.UTF8);

	адресСервера = общ.Коллекция_ЗначениеПоПути(пПараметры, "Сервер");
	таймаут = 15;
	соединение = Новый HTTPСоединение(адресСервера, , , , , таймаут);
	ЗаполнитьЗначенияСвойств(соединение, пПараметры);

	ответ = соединение.ВызватьHTTPМетод("POST", запрос);
		
	// Получить тело ответа из временного файла
	кодировка = КодировкаТекста.UTF8; // Кодировка по умолчанию
		
		// Если в заголовка ответа есть свойство "Content-Encoding", то из него получить кодировку
	Если ответ.Заголовки.Получить("Content-Encoding") = "ANSI" Тогда
		кодировка = "windows-1251"; // указывать кодировку явно, на Linux сервере кодировка ANSI не 1251

	КонецЕсли;

	имяСобытия = ИмяСобытияЖурналаРегистрации("Отправка.Отправить_HTTP_POST");
	текстОтвета = ответ.ПолучитьТелоКакСтроку(кодировка);
	уровеньЖурнала = ?(кодСостояния = Код200(), УровеньЖурналаРегистрации.Информация, УровеньЖурналаРегистрации.Ошибка);
	общ.ВЖурнал(имяСобытия, текстОтвета, уровеньЖурнала);

	Возврат кодСостояния;

КонецФункции

// Преобразует значение в JSON-строку по формату "Альфа".
//
// Параметры:
//   пЗначение - произвольный - Значение для преобразования в JSON-строку.
//
// Возвращаемое значение:
//   Строка - JSON-представление значения в формате "Альфа".
Функция Альфа_JSON(пЗначение) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off

	кэш = Новый Соответствие;

	стрОбраз = ""; // Результат
	
	// Для ссылок формат обм.Альфа
	Если общ.ЭтоСсылка(пЗначение) Тогда
		// Создать краткий образ ссылки без реквизитов, 
		// только необходимые для идентификации ссылки поля
		образСсылки = Альфа_Образ_ПоСсылке(пЗначение, "__Реквизиты__");
		
		// Развернуть все ссылки в коллекции без вложенных ссылок, 
		// чтобы избежать циклических ссылок при записи JSON
		Альфа_РазвернутьСсылки(образСсылки, 1, "__Реквизиты__");

		стрОбраз = общ.JSON_ПоКоллекции(образСсылки, кэш);

		Возврат стрОбраз;
		
	// Для прочих типов стандартный JSON
	Иначе
		стрОбраз = общ.JSON(пЗначение, , , кэш);

	КонецЕсли;

	Возврат стрОбраз;

КонецФункции

// Формирует строку в формате JSON по объекту обмена.
//
// Параметры:
//   пИсточник - произвольный - Источник данных для формирования JSON
//
// Возвращаемое значение:
//   Строка - JSON-представление объекта обмена в формате ОБМ Альфа
Функция Альфа_JSON_ПоОбъекту(пИсточник) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off
	образ = Альфа_Образ_ПоСсылке(пИсточник);
	уровень = 2;
	Альфа_РазвернутьСсылки(образ, уровень);
	Альфа_Образ_ДобавитьМетаданные(образ);

	образ.Вставить("_Формат", обм_лит.ФорматОбмАльфа());

	стрОбраз = Строка_ПоОбразу(образ);

	Возврат стрОбраз;

КонецФункции

// Формирует минимальную строку в формате JSON по объекту обмена.
//
// Параметры:
//   пИсточник - произвольный - Источник данных для формирования JSON
//
// Возвращаемое значение:
//   Строка - JSON-представление объекта обмена в формате ОБМ Альфа
Функция Альфа_Образ_Минимальный(пИсточник) Экспорт

	образ = Альфа_Образ_ПоСсылке(пИсточник, л__Все__());

	Возврат образ;

КонецФункции

// Формирует образ ссылки или объекта в виде структуры, содержащей основные свойства и реквизиты.
//
// Параметры:
//   пСсылкаИлиОбъект - ЛюбаяСсылка, СправочникОбъект, ДокументОбъект - объект, для которого формируется образ
//   пИсключаяСвойства - Неопределено, Строка, Массив из Строка - перечень свойств, которые нужно исключить из образа
//
// Возвращаемое значение:
//   Структура - образ ссылки или объекта
//
// Слишком сложная структура результата для описания
// @skip-check constructor-function-return-section
//
Функция Альфа_Образ_ПоСсылке(пСсылкаИлиОбъект, Знач пИсключаяСвойства = Неопределено) Экспорт

	образ = Новый Структура;
	
	// Подготовительные операции и классификация по входящим параметрам
	осд = общ.ОбъектСсылкаДругое(пСсылкаИлиОбъект);
	этотОбъектУдален = Ложь;
	этоНовый = Ложь;
	этоПеречисление = Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(пСсылкаИлиОбъект));
	Если этоПеречисление Тогда
		ссылкаОбъекта = пСсылкаИлиОбъект;

	ИначеЕсли осд = "Ссылка" Тогда
		ссылкаОбъекта = пСсылкаИлиОбъект;
		этотОбъектУдален = общ.ЭтоЗаполненнаяСсылка(ссылкаОбъекта) И Не общ.Ссылка_Существует(ссылкаОбъекта);

	ИначеЕсли осд = "Объект" Тогда
		ссылкаОбъекта = пСсылкаИлиОбъект.Ссылка;
		этоНовый = пСсылкаИлиОбъект.ЭтоНовый();
		этотОбъектУдален = Не этоНовый И общ.ЭтоЗаполненнаяСсылка(ссылкаОбъекта) И Не общ.Ссылка_Существует(
			ссылкаОбъекта);

	Иначе
		Возврат образ;

	КонецЕсли; 
	
	// Внимание! В коде ниже не должно быть переменной пСсылкаИлиОбъект
	// Дальше использовать только ссылкаОбъекта  

	типОбъекта = ТипЗнч(ссылкаОбъекта);
	образ.Вставить("_Тип", общ.Тип_Представление(типОбъекта));
	Если Не общ.Тип_ЭтоСсылка(типОбъекта) Тогда
		Возврат образ;

	КонецЕсли;

	этоПустаяСсылка = Не ЗначениеЗаполнено(ссылкаОбъекта);
	Если этоПустаяСсылка Тогда
		образ.Вставить("_ПустаяСсылка", Истина);
		Возврат образ;

	КонецЕсли;
	
	// Минимальный набор для определения ссылки
	Если этоПеречисление Тогда
		полноеИмяПеречисления = ПолучитьПолноеИмяПредопределенногоЗначения(ссылкаОбъекта);
		образ.Вставить("_Значение", СтрРазделить(полноеИмяПеречисления, ".")[2]);
		образ.Вставить("_ЭтоПеречисление", Истина);

	Иначе // Не перечисление
		образ.Вставить("_ИмяТаблицы", общ.Объект_ИмяТаблицы(ссылкаОбъекта));
		образ.Вставить("_НавигационнаяСсылка", общ.НавигационнаяСсылка(ссылкаОбъекта));
		образ.Вставить("_УникальныйИдентификатор", Строка(ссылкаОбъекта.УникальныйИдентификатор()));

		Если этотОбъектУдален Тогда
			образ.Вставить("_ОбъектУдален", Истина);
		Иначе
			образ.Вставить("_Представление", Строка(ссылкаОбъекта));
		КонецЕсли;

	КонецЕсли; 
	
	// Коллекция исключаемых свойств
	коллекцияИсключаемых = общ.Коллекция_ПоЗначению(пИсключаяСвойства); 
	
	// __Все__ эквивалентно "Исключить все"
	нуженМинимальныйОбраз = общ.Коллекция_Свойство(коллекцияИсключаемых, л__Все__());
	Если нуженМинимальныйОбраз Или этотОбъектУдален Или этоПустаяСсылка Тогда
		образ.Вставить("_ЭтоОбразБезРеквизитов", Истина);
		Возврат образ;

	КонецЕсли;

	// Реквизиты определяющие ссылку, нужны для поиска
#Область ОпределяющиеРеквизиты
	этоПВХ = ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(типОбъекта);
	этоПланСчетов = ПланыСчетов.ТипВсеСсылки().СодержитТип(типОбъекта);
	этоСпр = Справочники.ТипВсеСсылки().СодержитТип(типОбъекта);
	естьИерархия = этоСпр Или этоПВХ;

	исключитьВложенныеСсылки = общ.Коллекция_Свойство(коллекцияИсключаемых, "__ВложенныеСсылки__")
		Или общ.Коллекция_Свойство(коллекцияИсключаемых, "__МеняющиеХеш__");

	Если этоПланСчетов Или этоПВХ Или этоСпр Тогда
		образ.Вставить("_ИмяПредопределенныхДанных", ссылкаОбъекта.ИмяПредопределенныхДанных);

	КонецЕсли;
	
	// Выгрузить родителя и владельца
	// Для некоторых видов метаданных родитель/владелец является определяющим признаком, наравне с кодом или наименованием
	// Без него невозможно определить верный элемент справочника.
	// Например, такая ситуация в справочнике ВидыКонтактнойИнформации типовых бухгалтерий 3.0 для России
	// Там элементы без кода с одинаковыми наименованиями, отличаются только положением в иерархии, родитель у них разный
	Если этоСпр Тогда
		образ.Вставить("Наименование", ссылкаОбъекта.Наименование);

		владелец = ссылкаОбъекта.Владелец;
		исключитьВсеРеквизиты = исключитьВложенныеСсылки Или владелец = ссылкаОбъекта;
		образВладельца = Неопределено;
		Если исключитьВсеРеквизиты Тогда
			образВладельца = Альфа_Образ_Минимальный(владелец);

		Иначе
			образВладельца = владелец;

		КонецЕсли;
		образ.Вставить("Владелец", образВладельца);

	КонецЕсли;

	Если этоПланСчетов Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(типОбъекта) Тогда
		образ.Вставить("Наименование", ссылкаОбъекта.Наименование);

	КонецЕсли;

	Если естьИерархия Тогда
		образ.Вставить("_ЭтоГруппа", ссылкаОбъекта.ЭтоГруппа);
		образ.Вставить("ЭтоГруппа", ссылкаОбъекта.ЭтоГруппа);

		родитель = ссылкаОбъекта.Родитель;
		образРодителя = Неопределено;
		Если исключитьВложенныеСсылки Или родитель = ссылкаОбъекта Тогда
			образРодителя = Альфа_Образ_Минимальный(родитель);

		Иначе
			образРодителя = родитель;

		КонецЕсли;
		образ.Вставить("Родитель", образРодителя);

	КонецЕсли;

	этоДокумент = Документы.ТипВсеСсылки().СодержитТип(типОбъекта);

#Область исключитьМеняющиеХеш
	// Признак необходимости обезличить объект
	// Если равен истина, то не будут выгружены служебные реквизиты типа кода, номера, проведен, версия данных
	// Используется чтобы сравнивать объекты между собой, путем сравнения хешей коллекций или JSON коллекций
	исключитьМеняющиеХеш = общ.Коллекция_Свойство(коллекцияИсключаемых, "__МеняющиеХеш__");
	Если исключитьМеняющиеХеш Тогда
		образ.Удалить("_НавигационнаяСсылка");
		образ.Удалить("_УникальныйИдентификатор");
		образ.Вставить("_ЭтоОбразДляВычисленияХеша", Истина);

	Иначе // Не исключитьМеняющиеХеш
		вставитьКод = этоСпр Или этоПВХ Или этоПланСчетов Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(типОбъекта);
		Если вставитьКод Тогда
			образ.Вставить("Код", ссылкаОбъекта.Код);

		КонецЕсли;

		вставитьНомерДату = этоДокумент Или Задачи.ТипВсеСсылки().СодержитТип(типОбъекта)
			Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(типОбъекта);
		Если вставитьНомерДату Тогда
			образ.Вставить("Номер", ссылкаОбъекта.Номер);
			образ.Вставить("Дата", ссылкаОбъекта.Дата);

		КонецЕсли;

	КонецЕсли; // не для хеша

#КонецОбласти // неДляХеша  

#КонецОбласти // ОпределяющиеРеквизиты	

	выгружатьРеквизиты = Не общ.Коллекция_Свойство(коллекцияИсключаемых, "__Реквизиты__");
	Если Не выгружатьРеквизиты Или этоПеречисление Тогда
		Возврат образ;

	КонецЕсли; 
	
	// Далее полная выгрузка объекта, реквизитов и табличных частей 
	Если Не исключитьМеняющиеХеш Тогда
		образ.Вставить("ПометкаУдаления", ссылкаОбъекта.ПометкаУдаления);

		Если этоНовый Тогда
			образ.Вставить("ЭтоНовый", этоНовый);

		КонецЕсли;

		Если этоДокумент Тогда
			образ.Вставить("Проведен", ссылкаОбъекта.Проведен);

		КонецЕсли;

	КонецЕсли; // Если пВыгрузитьРеквизитыСостояния

	мета = Метаданные.НайтиПоТипу(типОбъекта);
	
	// Выгрузить реквизиты 
	выгружатьХранилищаЗначений = Не общ.Коллекция_Свойство(коллекцияИсключаемых, "__ХранилищаЗначений__");
	Для Каждого реквизитМетаданных Из мета.Реквизиты Цикл
		Если общ.Коллекция_Свойство(коллекцияИсключаемых, НРЕГ(реквизитМетаданных.Имя)) Тогда
			Продолжить;

		КонецЕсли;

		значениеРеквизита = ссылкаОбъекта[реквизитМетаданных.Имя];
		типРеквизита = ТипЗнч(значениеРеквизита);

		выгрузкаРазрешена = Истина;
		Если типРеквизита = Тип("ХранилищеЗначения") И Не выгружатьХранилищаЗначений Тогда
			выгрузкаРазрешена = Ложь;

		КонецЕсли;

		Если выгрузкаРазрешена Тогда
			
			// Запрет циклической ссылки самой на себя - например, ГоловнойКонтрагент у Контрагента это он сам
			исключитьВсеРеквизиты = 	(значениеРеквизита = ссылкаОбъекта) Или (исключитьВложенныеСсылки
				И общ.ЭтоСсылка(значениеРеквизита));
			Если исключитьВсеРеквизиты Тогда
				образ.Вставить(реквизитМетаданных.Имя, Альфа_Образ_Минимальный(значениеРеквизита));

			Иначе
				образ.Вставить(реквизитМетаданных.Имя, значениеРеквизита);

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;
	реквизитМетаданных = Неопределено;

	// Выгрузить табличные части
	выгружатьТабличныеЧасти = Не общ.Коллекция_Свойство(коллекцияИсключаемых, "__ТабличныеЧасти__");
	Если выгружатьТабличныеЧасти Тогда
		Для Каждого тчМетаданных Из мета.ТабличныеЧасти Цикл
			Если общ.Коллекция_Свойство(коллекцияИсключаемых, НРЕГ(тчМетаданных.Имя)) Тогда
				Продолжить;

			КонецЕсли;

			образТЧ = Новый Массив;
			ТЧ = ссылкаОбъекта[тчМетаданных.Имя];
			Для Каждого рядТЧ Из ТЧ Цикл
				образСтрокиТЧ = Новый Структура;

				// Нужен номер строки для сортировки результирующей ТЧ на выходе
				образСтрокиТЧ.Вставить("_НомерСтроки", рядТЧ.НомерСтроки);
				образСтрокиТЧ.Вставить("НомерСтроки", рядТЧ.НомерСтроки);

				Для Каждого реквизитТчМетаданных Из тчМетаданных.Реквизиты Цикл
					имяСвойства = НРЕГ(тчМетаданных.Имя + "." + реквизитТчМетаданных.Имя);
					Если общ.Коллекция_Свойство(коллекцияИсключаемых, имяСвойства) Тогда
						Продолжить;

					КонецЕсли;

					значениеРеквизитаТЧ = рядТЧ[реквизитТчМетаданных.Имя];
					типРеквизитаТЧ = ТипЗнч(значениеРеквизитаТЧ);

					Если общ.ЭтоСсылка(типРеквизитаТЧ) И (исключитьВложенныеСсылки Или значениеРеквизита
						= ссылкаОбъекта) Тогда
						образСтрокиТЧ.Вставить(реквизитТчМетаданных.Имя, Альфа_Образ_Минимальный(значениеРеквизитаТЧ));

					Иначе
						образСтрокиТЧ.Вставить(реквизитТчМетаданных.Имя, значениеРеквизитаТЧ);

					КонецЕсли;

				КонецЦикла;
				реквизитТчМетаданных = Неопределено;

				образТЧ.Добавить(образСтрокиТЧ);

			КонецЦикла;
			рядТЧ = Неопределено;

			образ.Вставить(тчМетаданных.Имя, образТЧ);

		КонецЦикла;
		тчМетаданных = Неопределено;

	КонецЕсли; // Если выгружатьТабличныеЧасти
		
	// Специфика плана счетов
	Если этоПланСчетов Тогда
		// Признаки учета
		Для Каждого признакУчета Из мета.ПризнакиУчета Цикл
			имяФлагаУчета = признакУчета.Имя;

			Если общ.Коллекция_Свойство(коллекцияИсключаемых, НРег(имяФлагаУчета)) Тогда
				Продолжить;

			КонецЕсли;

			образ.Вставить(имяФлагаУчета, ссылкаОбъекта[имяФлагаУчета]);

		КонецЦикла;
		признакУчета = Неопределено;
		
		// Виды субконто
		Если Не общ.Коллекция_Свойство(коллекцияИсключаемых, НРег("ВидыСубконто")) Тогда
			оВидахСубконто = Новый Массив;
			Для индексСубконто = 0 По ссылкаОбъекта.ВидыСубконто.Количество() - 1 Цикл

				строкаВидовСубконто = ссылкаОбъекта.ВидыСубконто[индексСубконто];
				образСтрокиВидовСубконто = Новый Структура;

				образВидаСубконто = Альфа_Образ_ПоСсылке(строкаВидовСубконто.ВидСубконто);
				образСтрокиВидовСубконто.Вставить("ВидСубконто", образВидаСубконто);
				образСтрокиВидовСубконто.Вставить("НомерСтроки", строкаВидовСубконто.НомерСтроки);
				образСтрокиВидовСубконто.Вставить("_НомерСтроки", строкаВидовСубконто.НомерСтроки);

				образСтрокиВидовСубконто.Вставить("Предопределенное", строкаВидовСубконто.Предопределенное);
				образСтрокиВидовСубконто.Вставить("ТолькоОбороты", строкаВидовСубконто.ТолькоОбороты);

				Для Каждого признакУчетаСубконто Из мета.ПризнакиУчетаСубконто Цикл
					имяФлагаУчетаСубконто = признакУчетаСубконто.Имя;
					образСтрокиВидовСубконто.Вставить(имяФлагаУчетаСубконто, строкаВидовСубконто[имяФлагаУчетаСубконто]);

				КонецЦикла;

				оВидахСубконто.Добавить(образСтрокиВидовСубконто);

			КонецЦикла;
			индексСубконто = Неопределено;

			образ.Вставить("ВидыСубконто", оВидахСубконто);

		КонецЕсли; // Виды субконто счета

	КонецЕсли; // Если этоПланСчетов

	Возврат образ;

КонецФункции

// Рекурсивно разворачивает ссылки в коллекции до указанного уровня.
//
// Параметры:
//   пКоллекция - Соответствие Из Произвольный - Коллекция, в которой нужно развернуть ссылки
//   пУровень - Число - Максимальный уровень вложенности ссылок
//   пИсключаяСвойства - Строка, Массив Из Строка - Свойства, которые нужно исключить при развертывании
//
// Возвращаемое значение:
//   Соответствие Из Произвольный - Исходная коллекция с развернутыми ссылками
Функция Альфа_РазвернутьСсылки(пКоллекция, Знач пУровень, Знач пИсключаяСвойства = Неопределено) Экспорт

	Если Не общ.ЭтоКоллекцияКлючЗначение(пКоллекция) Тогда
		Возврат пКоллекция;

	КонецЕсли;

	общ.Проверка_Тип(пУровень, "Число");

	пУровень = Цел(пУровень);
	Если пУровень <= 0 Тогда
		Возврат пКоллекция;

	КонецЕсли;

	коллекцияИсключаемых = общ.Коллекция_ПоЗначению(пИсключаяСвойства);

	коллекцияИсключаемых.Вставить("__ТабличныеЧасти__");
	коллекцияИсключаемых.Вставить("__ХранилищаЗначений__");

	этоПоследний = пУровень <= 1;
	Если этоПоследний Тогда
		коллекцияИсключаемых.Вставить("__Реквизиты__");

	КонецЕсли; 
	
	// Исключаемые свойства должны быть именно в виде строки
	// Потому что если это будет коллекция, то при передаче ее в функцию по ссылке (знач)
	// Она все равно меняется
	стрИсключитьСвойства = Коллекция_КлючиСоединитьВСтроку(коллекцияИсключаемых);

	ссылкаИзКоллекции = Альфа_Ссылка_ПоОбразу(пКоллекция);
	этоПеречисление = Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(ссылкаИзКоллекции));
	метаданныеТЧ = Неопределено;
	Если общ.ЭтоЗаполненнаяСсылка(ссылкаИзКоллекции) И Не этоПеречисление Тогда
		метаданныеТЧ = ссылкаИзКоллекции.Метаданные().ТабличныеЧасти;

	КонецЕсли;
	
	// На последнем уровне не разворачивать вложенные ссылки
	коллекцияРазвернутыхЗначений = Новый Соответствие;
	Для Каждого пара Из пКоллекция Цикл 
		
		// Обработка вложенных коллекций, уровень уменьшается
		вПареКоллекция = общ.ЭтоКоллекцияКлючЗначение(пара.Значение);
		Если вПареКоллекция Тогда
			обработаннаяКоллекция = Альфа_РазвернутьСсылки(пара.Значение, пУровень - 1, стрИсключитьСвойства);

			коллекцияРазвернутыхЗначений.Вставить(пара.Ключ, обработаннаяКоллекция);

			Продолжить;

		КонецЕсли;

		// Обработка ссылок
		Если общ.ЭтоСсылка(пара.Значение) Тогда
			текущаяСсылка = пара.Значение;
			образСсылки = Альфа_Образ_ПоСсылке(текущаяСсылка, стрИсключитьСвойства);
			коллекцияРазвернутыхЗначений.Вставить(пара.Ключ, образСсылки);

			Продолжить;

		КонецЕсли;
			
		// Рекурсивный вызов для табличных частей, уровень остается неизменным 
		этоОбразТЧ = ТипЗнч(пара.Значение) = Тип("Массив") И ТипЗнч(метаданныеТЧ) = Тип("КоллекцияОбъектовМетаданных")
			И метаданныеТЧ.Найти(пара.Ключ) <> Неопределено;
		Если этоОбразТЧ Тогда
			массивРазвернутыхСтрокТЧ = Новый Массив;
			Для Каждого образСтрокиТЧ Из пара.Значение Цикл
				Если общ.ЭтоКоллекцияКлючЗначение(образСтрокиТЧ) Тогда
					развернутыйОбразСтрокиТЧ = Альфа_РазвернутьСсылки(образСтрокиТЧ, пУровень, стрИсключитьСвойства);
					массивРазвернутыхСтрокТЧ.Добавить(развернутыйОбразСтрокиТЧ);

				Иначе
					массивРазвернутыхСтрокТЧ.Добавить(образСтрокиТЧ);

				КонецЕсли;

			КонецЦикла;
			образСтрокиТЧ = Неопределено;

			коллекцияРазвернутыхЗначений.Вставить(пара.Ключ, массивРазвернутыхСтрокТЧ);

			Продолжить;

		КонецЕсли;

	КонецЦикла;
	пара = Неопределено;
	
	// Заменить в исходной коллекции ссылки на развернутые коллекции
	Для Каждого пара Из коллекцияРазвернутыхЗначений Цикл
		пКоллекция.Вставить(пара.Ключ, пара.Значение);

	КонецЦикла;
	пара = Неопределено;

	Возврат пКоллекция;

КонецФункции

// Функция возвращает ссылку на объект информационной базы по его Альфа-образу.
//
// Параметры:
//   пОбразАльфа - Структура - Альфа-образ объекта информационной базы
//
// Возвращаемое значение:
//   ЛюбаяСсылка - ссылка на объект информационной базы или Неопределено, если ссылка не найдена
Функция Альфа_Ссылка_ПоОбразу(пОбразАльфа) Экспорт

	Если Не общ.ЭтоКоллекцияКлючЗначение(пОбразАльфа) Тогда
		Возврат Неопределено;

	КонецЕсли;

	типСсылки = Неопределено;
	стрТипСсылки = Неопределено;
	Если общ.Коллекция_Свойство(пОбразАльфа, "_Тип", стрТипСсылки) Тогда
		типСсылки = общ.Тип_ПоСтроке(стрТипСсылки);
	КонецЕсли;

	Если Не общ.Тип_ЭтоСсылка(типСсылки) Тогда
		Возврат Неопределено;

	КонецЕсли;
	
	// 0. Значение перечисления
	этоПеречисление = Перечисления.ТипВсеСсылки().СодержитТип(типСсылки);
	Если этоПеречисление Тогда
		перечисление_менеджер = общ.Менеджер_ПоОбъекту(типСсылки);
		Если Общ.Коллекция_Свойство(пОбразАльфа, "_ПустаяСсылка") Тогда
			Возврат перечисление_менеджер.ПустаяСсылка();

		КонецЕсли;

		имяПеречисления = "";
		Если Не общ.Коллекция_Свойство(пОбразАльфа, "_Значение") Тогда
			Возврат Неопределено;

		КонецЕсли;

		мета = перечисление_менеджер.пустаяСсылка().Метаданные();
		перечисление_существует = мета.ЗначенияПеречисления.Найти(имяПеречисления) <> Неопределено;
		Если перечисление_существует Тогда
			Возврат перечисление_менеджер[имяПеречисления];

		Иначе
			Возврат Неопределено;

		КонецЕсли;

	КонецЕсли; // этоПеречисление
	
	// 1. Искать по навигационной ссылке
	навигационнаяСсылка = Неопределено;
	естьНавигационнаяСсылка = общ.Коллекция_Свойство(пОбразАльфа, "_НавигационнаяСсылка", навигационнаяСсылка)
		И ЗначениеЗаполнено(навигационнаяСсылка);

	Если естьНавигационнаяСсылка Тогда
		ссылкаРезультат = общ.Ссылка_ПоНавигационнойСсылке(навигационнаяСсылка);
		Если общ.ЭтоЗаполненнаяСсылка(ссылкаРезультат) Тогда
			Возврат ссылкаРезультат;

		Иначе
			ссылкаРезультат = Неопределено;

		КонецЕсли;

	КонецЕсли;
	
	// 2. Искать по типу и уникальному идентификатору
	менеджер = общ.Менеджер_ПоОбъекту(типСсылки);

	уид = Неопределено;
	Если общ.Коллекция_Свойство(пОбразАльфа, "_УникальныйИдентификатор", уид) И общ.Строка_ЭтоУникальныйИдентификатор(
		уид) Тогда
		ссылкаРезультат = менеджер.ПолучитьСсылку(
			Новый УникальныйИдентификатор(пОбразАльфа["_УникальныйИдентификатор"]));

	Иначе
		ссылкаРезультат = менеджер.ПустаяСсылка();

	КонецЕсли;

	Возврат ссылкаРезультат;

КонецФункции

#КонецОбласти // ФорматОбмАльфа

#Область Получение

// Обрабатывает очередь входящих сообщений.
//
// Параметры:
//   пИзвлечьПакетыДанных - Булево - Извлечь пакеты из входящих сообщений со статусом "Получен"
//   пОбработатьПакетыДанных - Булево - Обработать входящие сообщения со статусом "Ждет обработки"
// 
Процедура Получение_ОбработатьОчередь(пИзвлечьПакетыДанных = Истина, пОбработатьПакетыДанных = Истина) Экспорт
	
	// 0. Запрос поиска входящих запросов в определенном статусе
	Запрос = Новый Запрос;
	
	// Использование виртуальной таблицы без параметров здесь оправдано,
	// т.к. надо получить ссылки на аходящие сообщения в определенном статусе
	// 
	// BSLLS:VirtualTableCallWithoutParameters-off
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 100
	|	Т.ВходящееСообщение КАК Ссылка
	|ИЗ
	|	РегистрСведений.обм_ВходящиеСообщения_Статусы.СрезПоследних КАК Т
	|ГДЕ
	|	Т.Статус В(&СтатусДляПоиска)
	|	И НЕ Т.ВходящееСообщение.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	Т.Период";
	// BSLLS:VirtualTableCallWithoutParameters-on
	
	// Ниже запрос в цикле, чтобы реализовать порционную обработку данных
	// BSLLS:CreateQueryInCycle-off
	Пока Истина Цикл
		счетчик = 0;
		
		// 1. Сначала найти все входящие запросы в статусе "Ждет обработки" и завершить их обработку
		Если пОбработатьПакетыДанных Тогда
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.ЖдетОбработки);
			входящиеСообщения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");

			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Обработать(входящиеСообщения);

			счетчик = счетчик + входящиеСообщения.Количество();

		КонецЕсли;
		
		// 2. Найти все входящие запросы в статусе "Получен" и обработать их
		Если пИзвлечьПакетыДанных Тогда
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.Получен);
			входящиеСообщения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");

			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Извлечь(входящиеСообщения);

			счетчик = счетчик + входящиеСообщения.Количество();

		КонецЕсли;

		Если счетчик = 0 Тогда
			Прервать;

		КонецЕсли;

	КонецЦикла;
	счетчик = Неопределено;
	// BSLLS:CreateQueryInCycle-on

КонецПроцедуры

// Обертка функций модуля менеджера справочника обм_ВходящиеСообщения,
// чтобы их можно было вызывать с клиента
#Область ВходящиеСообщения_ИнтерфейсДляКлиента

// Возвращает значение параметра входящего сообщения.
//
// Параметры:
//   пВходящееСообщениеСсылка - СправочникСсылка.обм_ВходящиеСообщения - Ссылка на входящее сообщение
//   КлючПараметра - Строка - Ключ параметра входящего сообщения
//
// Возвращаемое значение:
//   Строка - Значение параметра входящего сообщения
//
// @TODO убрать вызовы ВходящееСообщение_Параметр_Значение с клиента и отключить у модуля вызов сервера
Функция ВходящееСообщение_Параметр_Значение(пВходящееСообщениеСсылка, КлючПараметра) Экспорт

	Возврат Справочники.обм_ВходящиеСообщения.Параметр_Значение(пВходящееСообщениеСсылка, КлючПараметра);

КонецФункции

// Получает ссылку на элемент справочника "Входящие сообщения" по ответу HTTP сервиса.
//
// Параметры:
//   пОтветХТТП - HTTPСервисОтвет - ответ от HTTP сервиса.
//
// Возвращаемое значение:
//   СправочникСсылка.обм_ВходящиеСообщения - ссылка на элемент справочника 
// 												или Неопределено, если не удалось получить ссылку.
Функция ВходящееСообщение_СсылкаПоHTTPСервисОтвет(пОтветХТТП) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off

#Если ВнешнееСоединение Тогда
	Возврат Неопределено;

#Иначе
		общ.Проверка_Тип(пОтветХТТП, Тип("HTTPСервисОтвет"));

#КонецЕсли

	Если пОтветХТТП.КодСостояния <> Код200() Тогда
		Возврат Неопределено;

	КонецЕсли;
	
	// Тело ответа содержит:
	// 
	//	{"Status":"RequestReceived",
	//	"Ticket"":"%УникальныйИдентификатор%"
	//	}
	//
	// см. функцию Запрос_Записать

	стрОтвет = пОтветХТТП.ПолучитьТелоКакСтроку();

	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		образ = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();

	Исключение
		Возврат Неопределено;

	КонецПопытки;

	Если ТипЗнч(образ) <> Тип("Соответствие") Тогда
		Возврат Неопределено;

	КонецЕсли;

	стрИД = образ["Ticket"];

	Если стрИД = Неопределено Тогда
		Возврат Неопределено;

	КонецЕсли;

	Возврат Справочники.обм_ВходящиеСообщения.ПолучитьСсылку(Новый УникальныйИдентификатор(стрИД));

КонецФункции

// Извлекает текст ошибки из ответа HTTP сервиса.
//
// Параметры:
//   пОтветХТТП - HTTPСервисОтвет - ответ от HTTP сервиса
//
// Возвращаемое значение:
//   Строка - текст ошибки, если она есть в ответе, иначе Неопределено
Функция ВходящееСообщение_ОшибкаИзHTTPСервисОтвет(пОтветХТТП) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off

#Если ВнешнееСоединение Тогда
	Возврат Неопределено;

#Иначе
		общ.Проверка_Тип(пОтветХТТП, Тип("HTTPСервисОтвет"));

#КонецЕсли
	
	// 200 значит нет ошибки
	Если пОтветХТТП.КодСостояния = Код200() Тогда
		Возврат Неопределено;

	КонецЕсли;
	
	// Тело ответа содержит:
	// 
	// {"Error":"%1"}
	//	
	// см. функцию Запрос_Записать

	стрОтвет = пОтветХТТП.ПолучитьТелоКакСтроку();

	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		образ = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();

	Исключение
		Возврат Неопределено;

	КонецПопытки;

	Если ТипЗнч(образ) <> Тип("Соответствие") Тогда
		Возврат Неопределено;

	КонецЕсли;

	обОшибке = образ["Error"];

	Если обОшибке = Неопределено Или ПустаяСтрока(обОшибке) Тогда
		Возврат Неопределено;

	КонецЕсли;

	Возврат обОшибке;

КонецФункции

// Создает новое входящее сообщение на основе полученного HTTP-запроса.
//
// Параметры:
//   пХТТПСервисЗапрос - HTTPСервисЗапрос - Объект HTTP-запроса, на основе которого создается входящее сообщение
//   пНаименованиеЗапроса - Строка, Структура - Наименование запроса или дополнительная информация о нем
//   пОбработатьВФоне - Булево - Флаг, определяющий, асинхронную обработку запроса
//
// Возвращаемое значение:
//   HTTPСервисОтвет, Строка - Ответ на запрос в зависимости от результата создания входящего сообщения
Функция ВходящееСообщение_Создать(пХТТПСервисЗапрос, пНаименованиеЗапроса = Неопределено, 
			пОбработатьВФоне = Истина) Экспорт
									
	// Создание входящего сообщения не должно влиять на работу пользователей и алгоритмов
	// поэтому выполнять в прив. режиме, чтобы исключить проблемы с правами
	УстановитьПривилегированныйРежим(Истина); // BSLLS:SetPrivilegedMode-off

	имяСобытия = ИмяСобытияЖурналаРегистрации("Получение.ВходящееСообщение_Создать");

	HTTPСервисЗапрос_ЗарегистрироватьВЖурнале(имяСобытия, пХТТПСервисЗапрос);

	кодСостояния = 400;
	текстОтвета = "";

	Попытка
		ВходящееСообщение_Объект = Справочники.обм_ВходящиеСообщения.СоздатьЭлемент();
		СсылкаНового = Справочники.обм_ВходящиеСообщения.ПолучитьСсылку();
		ВходящееСообщение_Объект.ДополнительныеСвойства.Вставить("СсылкаНового", СсылкаНового);
		ВходящееСообщение_Объект.УстановитьСсылкуНового(СсылкаНового);

		Если Не ПустаяСтрока(пНаименованиеЗапроса) Тогда
			ВходящееСообщение_Объект.Наименование = СокрЛП(пНаименованиеЗапроса);

		Иначе
			ВходящееСообщение_Объект.Наименование = Строка(ТипЗнч(пХТТПСервисЗапрос));

		КонецЕсли;
		ВходящееСообщение_Объект.Наименование = СтрШаблон(	"%1 %2", ВходящееСообщение_Объект.Наименование, // %1

			Строка(СсылкаНового.УникальныйИдентификатор()) // %2
		);

		ВходящееСообщение_Объект.ДатаВремя = общ.ДатаУниверсальная();
		ВходящееСообщение_Объект.Запрос = пХТТПСервисЗапрос.ПолучитьТелоКакСтроку();

		ЗаполнитьЗначенияСвойств(ВходящееСообщение_Объект, пХТТПСервисЗапрос);

		Для Каждого КлючИЗначение Из пХТТПСервисЗапрос.ПараметрыURL Цикл
			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = КлючИЗначение.Ключ;
			рядПараметры.Значение = КлючИЗначение.Значение;
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.URL;

		КонецЦикла;
		КлючИЗначение = Неопределено;

		Для Каждого КлючИЗначение Из пХТТПСервисЗапрос.ПараметрыЗапроса Цикл
			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = КлючИЗначение.Ключ;
			рядПараметры.Значение = КлючИЗначение.Значение;
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.Запрос;

		КонецЦикла;
		
		// Добавить текущего пользователя
		рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
		рядПараметры.Ключ = "ТекущийПользователь_Имя";
		рядПараметры.Значение = ТекущийПользователь_Имя();
		рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;

		Если ТипЗнч(пНаименованиеЗапроса) = Тип("Структура") Тогда
			Для Каждого пара Из пНаименованиеЗапроса Цикл
				рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
				рядПараметры.Ключ = пара.Ключ;
				рядПараметры.Значение = пара.Значение;
				рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;

			КонецЦикла;
			пара = Неопределено;

		Иначе
			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = "Метод";
			рядПараметры.Значение = СокрЛП(пНаименованиеЗапроса);
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;

		КонецЕсли;

		Для Каждого пара Из пХТТПСервисЗапрос.Заголовки Цикл
			
			// Данные авторизации не фиксировать
			Если НРег(пара.Ключ) = "authorization" Тогда
				Продолжить;

			КонецЕсли;

			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = пара.Ключ;
			рядПараметры.Значение = пара.Значение;
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.ЗаголовокHTTP;

		КонецЦикла;
		пара = Неопределено;
		
		// Чтобы запрос не обрабатывался регламентным заданием, пометить его на удаление
		// см. Получение_ОбработатьОчередь
		Если Не пОбработатьВФоне Тогда
			ВходящееСообщение_Объект.ПометкаУдаления = Истина;

		КонецЕсли;

		ВходящееСообщение_Объект.Параметры.Сортировать("Ключ");

		ВходящееСообщение_Объект.Записать();

		кодСостояния = 200;
		уид = Строка(ВходящееСообщение_Объект.Ссылка.УникальныйИдентификатор());
		текстОтвета = СтрШаблон(
				"{""Status"":""RequestReceived"",
				|""Ticket"":""%1""
				|}", уид // %1
		);

	Исключение
		инфоОшибки = ИнформацияОбОшибке();
		общ.Ошибка_ВЖурналРегистрации(имяСобытия, инфоОшибки);

		кодСостояния = 500;
		текстОтвета = СтрШаблон(
				"{""Error"":""%1""}", общ.Ошибка_КраткоеПредставление(инфоОшибки) // %1
		);

	КонецПопытки;

#Если ВнешнееСоединение Тогда
	Ответ = текстОтвета;

#Иначе
		Ответ = Новый HTTPСервисОтвет(кодСостояния);
		Ответ.Заголовки.Вставить("Content-Type", "text/html; charset=utf-8");
		Ответ.УстановитьТелоИзСтроки(текстОтвета);

#КонецЕсли

	УстановитьПривилегированныйРежим(Ложь);

	Возврат Ответ;

КонецФункции

// Создает входящее сообщение через HTTP-запрос эмуляцию.
//
// Параметры:
//   пУРЛ - Строка - URL для отправки запроса
//   пДанные - Строка, ДвоичныеДанные, Массив, Структура, Соответствие - Данные для отправки в теле запроса
//   пПараметрыЗапроса - Структура, Соответствие, Неопределено - Параметры запроса
//   пНаименованиеЗапроса - Неопределено, Строка - Наименование запроса
//   пОбработатьСразу - Булево - Флаг немедленной обработки сообщения
//
// Возвращаемое значение:
//   HTTPСервисОтвет - Ответ о записи запроса
//  
//@skip-check doc-comment-collection-item-type
Функция ВходящееСообщение_СоздатьЧерезHTTPЗапросЭмуляция(пУРЛ,  // BSLLS:LatinAndCyrillicSymbolInWord-off

	пДанные, пПараметрыЗапроса = Неопределено, пНаименованиеЗапроса = Неопределено, пОбработатьСразу = Ложь) Экспорт

	общ.Проверка_Тип(пПараметрыЗапроса, "Структура, Соответствие, Неопределено");

	эмулятор = Обработки.обм_HTTPЗапросЭмуляция.Создать();

	эмулятор.HTTPМетод = "POST";

	эмулятор.БазовыйURL = "emul://" + пУРЛ;
	эмулятор.ОтносительныйURL = пУРЛ;

	Если ТипЗнч(пДанные) = Тип("Строка") Тогда
		эмулятор.Тело = пДанные;

	ИначеЕсли ТипЗнч(пДанные) = Тип("ДвоичныеДанные") Тогда
		эмулятор.Тело = Base64Строка(пДанные);

	ИначеЕсли ТипЗнч(пДанные) = Тип("Массив") Или ТипЗнч(пДанные) = Тип("Структура") Или ТипЗнч(пДанные) = Тип(
		"Соответствие") Тогда
		эмулятор.Тело = Общ.JSON(пДанные);

	Иначе
		эмулятор.Тело = Строка(пДанные);

	КонецЕсли;

	Если пПараметрыЗапроса <> Неопределено Тогда
		Для Каждого пара Из пПараметрыЗапроса Цикл
			эмулятор.ПараметрыЗапроса.Вставить(пара.Ключ, пара.Значение);

		КонецЦикла;
		пара = Неопределено;

	КонецЕсли;
	
	// Для предотвращения конфликта между регламентным заданием и обработкой при загрузке пользователем из формы
	// Запретить обработку регламентным заданием
	обработатьВФоне = Не пОбработатьСразу;
	ответОЗаписиЗапроса = ВходящееСообщение_Создать(эмулятор, пНаименованиеЗапроса, обработатьВФоне);

	Если ответОЗаписиЗапроса.КодСостояния = Код200() И пОбработатьСразу Тогда
		входящееСообщениеСсылка = ВходящееСообщение_СсылкаПоHTTPСервисОтвет(ответОЗаписиЗапроса);

		Если ЗначениеЗаполнено(входящееСообщениеСсылка) Тогда
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Извлечь(входящееСообщениеСсылка);
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Обработать(входящееСообщениеСсылка);

		КонецЕсли;

	КонецЕсли;

	Возврат ответОЗаписиЗапроса;

КонецФункции

#КонецОбласти // ВходящиеСообщения_ИнтерфейсДляКлиента

#КонецОбласти // Получение

#Область Прочее

// Регистрирует информацию о полученном HTTP-запросе в журнале регистрации.
//
// Параметры:
//   пИмяСобытия - Строка - Имя события для записи в журнал регистрации
//   пЗапросХТТП - HTTPСервисЗапрос - Объект HTTP-запроса, информация о котором будет записана в журнал
Процедура HTTPСервисЗапрос_ЗарегистрироватьВЖурнале(пИмяСобытия, пЗапросХТТП) Экспорт

	общ.Проверка_Тип(пЗапросХТТП, Тип("HTTPСервисЗапрос"));

	рез = "";

	рез = рез + пЗапросХТТП.HTTPМетод + Символы.ПС;
	рез = рез + пЗапросХТТП.БазовыйURL + Символы.ПС;
	рез = рез + пЗапросХТТП.ОтносительныйURL + Символы.ПС;
	рез = рез + "Заголовки:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.Заголовки Цикл
		
		// Данные авторизации не фиксировать
		Если НРег(Параметр.Ключ) = "authorization" Тогда
			Продолжить;

		КонецЕсли;

		заготовка = СтрЗаменить(Параметр.Значение, ";", "");
		рез = рез + Параметр.Ключ + ":" + заготовка + Символы.ПС;
	КонецЦикла;
	рез = рез + "Параметры URL:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.ПараметрыURL Цикл
		рез = рез + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;
	рез = рез + "Параметры запроса:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.ПараметрыЗапроса Цикл
		рез = рез + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;

	рез = рез + "BODY:" + пЗапросХТТП.ПолучитьТелоКакСтроку() + Символы.ПС;

	ЗаписьЖурналаРегистрации(пИмяСобытия, УровеньЖурналаРегистрации.Информация, , , рез);

КонецПроцедуры

// Формирует имя события для журнала регистрации на основе переданного имени события.
//
// Параметры:
//   пИмяСобытия - Строка - Имя события, которое необходимо преобразовать
//
// Возвращаемое значение:
//   Строка - Сформированное имя события для журнала регистрации
Функция ИмяСобытияЖурналаРегистрации(пИмяСобытия = "") Экспорт

	частиИмени = Новый Массив;
	частиИмени = общ.Массив_ПоЗначению(пИмяСобытия, Тип("Строка"), ".");
	частиИмени.Вставить(0, "обм");

	результат = СтрСоединить(частиИмени);

	Возврат результат;

КонецФункции

// Возвращает имя текущего пользователя информационной базы.
//
// Возвращаемое значение:
//   Строка - имя текущего пользователя информационной базы
Функция ТекущийПользователь_Имя() Экспорт
	
	// Если не найдено, возвращать текущего пользователя ИБ
	Возврат ПользователиИнформационнойБазы.ТекущийПользователь().Имя;

КонецФункции

// Формирует уникальный идентификатор ресурса (УРИ) для обмена данными.
//
// Параметры:
//   пУзел - Строка - Узел обмена данными
//   пКатегория - Строка - Категория ресурса
//   пИдентификатор - Строка - Идентификатор ресурса
//
// Возвращаемое значение:
//   Строка - Сформированный УРИ
Функция УРИ(пУзел, пКатегория, пИдентификатор) Экспорт

	узел = УзелПривести(пУзел);

	стрУРИ = СтрШаблон("odins_obmen/%1/%2/%3", узел, пКатегория, пИдентификатор);

	Возврат стрУРИ;

КонецФункции

// Приводит узел к единому виду для сравнения или идентификации.
//
// Параметры:
//   пУзел - Строка - Узел, который необходимо привести
//
// Возвращаемое значение:
//   Строка - Приведенный узел в нижнем регистре без пробелов в начале и конце
Функция УзелПривести(пУзел) Экспорт

	результат = НРег(СокрЛП(пУзел));

	Возврат результат;

КонецФункции

#КонецОбласти // Прочее

#КонецОбласти // ВнешнийИнтерфейс

#Область СлужебныйПрограммныйИнтерфейс

#Область РегламентныеЗадания

Процедура Отправка_1_ИсходящиеСообщения_Создать() Экспорт

	РегистрыСведений.обм_Измененные.ОбработатьОчередьИзмененных();

КонецПроцедуры

Процедура Отправка_2_ИсходящиеСообщения_Отправить() Экспорт

	РегистрыСведений.обм_КОтправке.ОбработатьОчередьОтправки();

КонецПроцедуры

// Обработчик фонового задания получения данных
//
Процедура Получение_ФоновоеЗадание() Экспорт

	Если общ.ИнформационнаяБаза_Файловая() Тогда
		Получение_ОбработатьОчередь();
		Возврат;

	КонецЕсли;

	метаЗадания = Метаданные.РегламентныеЗадания.обм_Получение_2_ПакетыДанных_Обработать;
	ключЗадания = метаЗадания.Ключ;
	фоновые = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Ключ", ключЗадания));
	Для Каждого фоновое Из фоновые Цикл
		Если фоновое.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			Возврат;

		КонецЕсли;

	КонецЦикла;
	фоновое = Неопределено;

	ФоновыеЗадания.Выполнить(
		"обм.Получение_ОбработатьОчередь", // ИмяМетода

		Новый Массив, // Параметры

		ключЗадания, // Ключ

		метаЗадания.Наименование // Наименование
	);

КонецПроцедуры

Процедура Получение_1_ПакетыДанных_Извлечь() Экспорт

	Получение_ОбработатьОчередь(
		Истина, // извлечь пакеты данных

		Ложь // обработать пакеты данных
	);

КонецПроцедуры

Процедура Получение_2_ПакетыДанных_Обработать() Экспорт

	Получение_ОбработатьОчередь(
			Ложь, // извлечь пакеты данных

		Истина // обработать пакеты данных
	);

КонецПроцедуры

#КонецОбласти // РегламентныеЗадания

#Область ПодпискиНаСобытия

Процедура ПриЗаписи(пИсточник, пОтказ = Ложь) Экспорт

	Если пИсточник.ОбменДанными.Загрузка Тогда
		Возврат;

	КонецЕсли;
	
	// Объекты подсистемы обм.обмены не пропускаем
	Если ЭтоОбъектПодсистемыОбм(пИсточник) Тогда
		Возврат;

	КонецЕсли;
	
	// В скрипты передаем не сам объект, а ссылку на него
	// Так надо, чтобы в скрипте было невозможно изменить объект или его свойства
	источникСсылка = пИсточник.Ссылка;

	узелОтправитель = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_УзелОтправитель(), узелОтправитель);
	узелОтправитель = УзелПривести(узелОтправитель);

	категорияОтправителя = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_КатегорияОтправителя(), категорияОтправителя);
	идентификаторОтправителя = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_ИдентификаторОтправителя(), идентификаторОтправителя);
		
	// т.к. у пользователя может не быть прав на РегистрыСведений.обм_Измененные
	УстановитьПривилегированныйРежим(Истина); // BSLLS:SetPrivilegedMode-off
	РегистрыСведений.обм_Измененные.Зарегистрировать(	источникСсылка, узелОтправитель, категорияОтправителя,
		идентификаторОтправителя);
	УстановитьПривилегированныйРежим(Ложь);

КонецПроцедуры

#КонецОбласти // Подписки на события

#КонецОбласти // СлужебныйПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

#Область ЛитералыИВолшебныеЧисла

Функция Код200()

	Возврат 200;

КонецФункции

Функция л__Все__()

	Возврат "__Все__";

КонецФункции

Функция ЭтоОбъектПодсистемыОбм(пОбъект)

	результат =	ТипЗнч(пОбъект) = Тип("СправочникОбъект.обм_ВходящиеСообщения") Или ТипЗнч(пОбъект) = Тип(
		"СправочникОбъект.обм_ИсходящиеСообщения") Или ТипЗнч(пОбъект) = Тип("СправочникОбъект.обм_ПакетыДанных")
		Или ТипЗнч(пОбъект) = Тип("СправочникОбъект.общ_Обработчики");
	Возврат результат;

КонецФункции

#КонецОбласти // Литералы и волшебные числа

Процедура Альфа_Образ_ДобавитьМетаданные(пОбразОбъекта)

	обОтправителе = Новый Структура;
	обОтправителе.Вставить("Версия", Метаданные.Версия);
	обОтправителе.Вставить("Имя", Метаданные.Имя);
	обОтправителе.Вставить("Синоним", Метаданные.Синоним);
	обОтправителе.Вставить("ИмяКомпьютера", ИмяКомпьютера());
	обОтправителе.Вставить("ИмяПользователя", ИмяПользователя());
	обОтправителе.Вставить("ИмяИнформационнойБазы", общ.ИнформационнаяБаза_Имя());
	обОтправителе.Вставить("ПолноеИмяПользователя", ПолноеИмяПользователя());
	обОтправителе.Вставить("СтрокаСоединенияИнформационнойБазы", СтрокаСоединенияИнформационнойБазы());
	обОтправителе.Вставить("ЧасовойПоясСеанса", ЧасовойПоясСеанса());
	обОтправителе.Вставить("ИдентификаторИнформационнойБазы", общ.ИдентификаторИнформационнойБазы());
	обОтправителе.Вставить("ЭтоТестоваяБаза", общ.ЭтоТестоваяБаза());

	си = Новый СистемнаяИнформация;
	обОтправителе.Вставить("ВерсияОС", си.ВерсияОС);
	обОтправителе.Вставить("ВерсияПриложения", си.ВерсияПриложения);

	пОбразОбъекта.Вставить("_метаданныеОтправителя", обОтправителе);

КонецПроцедуры

Функция Коллекция_КлючиСоединитьВСтроку(пКоллекция)

	разделитель = ",";

	Если ТипЗнч(пКоллекция) = Тип("Массив") Тогда
		Возврат СтрСоединить(пКоллекция, разделитель);

	ИначеЕсли общ.ЭтоКоллекцияКлючЗначение(пКоллекция) Тогда
		стрРезультат = "";
		Для Каждого пара Из пКоллекция Цикл
			Если ПустаяСтрока(пара.Ключ) Тогда
				Продолжить;

			КонецЕсли;

			Если Не ПустаяСтрока(стрРезультат) Тогда
				стрРезультат = стрРезультат + разделитель;

			КонецЕсли;

			стрРезультат = стрРезультат + СокрЛП(пара.Ключ);

		КонецЦикла;
		пара = Неопределено;

		Возврат стрРезультат;

	Иначе
		Возврат "";

	КонецЕсли;

КонецФункции

Функция Строка_ПоОбразу(пОбраз)
	
	// Формирование строки послания
	стрОбраз = Неопределено;
	Если ТипЗнч(пОбраз) = Тип("Строка") Тогда
		стрОбраз = пОбраз;

	ИначеЕсли общ.ЭтоКоллекцияКлючЗначение(пОбраз) Тогда
		стрОбраз = общ.JSON_ПоКоллекции(пОбраз);

	Иначе
		стрОбраз = Строка(пОбраз);

	КонецЕсли;

	Возврат стрОбраз;

КонецФункции
#КонецОбласти // СлужебныеПроцедурыИФункции

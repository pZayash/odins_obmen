// BSLLS:IncorrectLineBreak-off

#Область ПрограммныйИнтерфейс

#Область ФорматОбмАльфа

Функция Альфа_JSON(пЗначение) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off
	
	кэш = Новый Соответствие;
	
	стрОбраз = ""; // Результат
	
	// Для ссылок формат обм.Альфа
	Если общ.ЭтоСсылка(пЗначение) Тогда
		// Создать краткий образ ссылки без реквизитов, 
		// только необходимые для идентификации ссылки поля
 		образСсылки = обм.Альфа_Образ_ПоСсылке(пЗначение, "__Реквизиты__");
		
		// Развернуть все ссылки в коллекции без вложенных ссылок, 
		// чтобы избежать циклических ссылок при записи JSON
		Альфа_РазвернутьСсылки(образСсылки, 1, "__Реквизиты__"); 

		стрОбраз = общ.JSON_ПоКоллекции(образСсылки, кэш);
		
		Возврат стрОбраз;
		
	// Для прочих типов стандартный JSON
	Иначе
		стрОбраз = общ.JSON(пЗначение, , , кэш);
		
	КонецЕсли;
	
	Возврат стрОбраз;

КонецФункции

Функция Альфа_JSON_ПоОбъекту(пИсточник) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off
	образ = обм.Альфа_Образ_ПоСсылке(пИсточник);
	уровень = 2;
	обм.Альфа_РазвернутьСсылки(образ, уровень);
	Альфа_Образ_ДобавитьМетаданные(образ);
	
	образ.Вставить("_Формат", обм_лит.ФорматОбмАльфа());
	
	стрОбраз = Строка_ПоОбразу(образ);
	
	Возврат стрОбраз;
	
КонецФункции

Функция Альфа_Образ_Минимальный(пСсылкаИлиОбъект) Экспорт
	
	образ = обм.Альфа_Образ_ПоСсылке(пСсылкаИлиОбъект, л__Все__());
	
	Возврат образ;
	
КонецФункции

Функция Альфа_Образ_ПоСсылке(пСсылкаИлиОбъект, Знач пИсключаяСвойства = Неопределено) Экспорт
	
	образ = Новый Структура();
	
	// Подготовительные операции и классификация по входящим параметрам
	осд = общ.ОбъектСсылкаДругое(пСсылкаИлиОбъект);
	этотОбъектУдален = Ложь;
	этоНовый = Ложь;
	этоПеречисление = Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(пСсылкаИлиОбъект));
	Если этоПеречисление Тогда
		ссылкаОбъекта = пСсылкаИлиОбъект;
		
	ИначеЕсли осд = "Ссылка" Тогда
		ссылкаОбъекта = пСсылкаИлиОбъект;
		этотОбъектУдален = общ.ЭтоЗаполненнаяСсылка(ссылкаОбъекта) И Не общ.Ссылка_Существует(ссылкаОбъекта);

	ИначеЕсли осд = "Объект" Тогда
		ссылкаОбъекта = пСсылкаИлиОбъект.Ссылка;
		этоНовый = пСсылкаИлиОбъект.ЭтоНовый();
		этотОбъектУдален = Не этоНовый И общ.ЭтоЗаполненнаяСсылка(ссылкаОбъекта) И Не общ.Ссылка_Существует(ссылкаОбъекта);
		
	Иначе
		Возврат образ;
		
	КонецЕсли; 
	
	// Внимание! В коде ниже не должно быть переменной пСсылкаИлиОбъект
	// Дальше использовать только ссылкаОбъекта  
	
	типОбъекта = ТипЗнч(ссылкаОбъекта); 
	образ.Вставить("_Тип", общ.Тип_Представление(типОбъекта)); 
	Если Не общ.Тип_ЭтоСсылка(типОбъекта) Тогда
		Возврат образ;
		
	КонецЕсли;  
	
	этоПустаяСсылка = Не ЗначениеЗаполнено(ссылкаОбъекта);
	Если этоПустаяСсылка Тогда
		образ.Вставить("_ПустаяСсылка", Истина);
		Возврат образ;
		
	КонецЕсли;
	
	// Минимальный набор для определения ссылки
	Если этоПеречисление Тогда
		полноеИмяПеречисления = ПолучитьПолноеИмяПредопределенногоЗначения(ссылкаОбъекта);
		образ.Вставить("_Значение", СтрРазделить(полноеИмяПеречисления, ".")[2]); 
		образ.Вставить("_ЭтоПеречисление", Истина);
		
	Иначе // Не перечисление
		образ.Вставить("_ИмяТаблицы", общ.Объект_ИмяТаблицы(ссылкаОбъекта));
		образ.Вставить("_НавигационнаяСсылка", общ.НавигационнаяСсылка(ссылкаОбъекта));
		образ.Вставить("_УникальныйИдентификатор", Строка(ссылкаОбъекта.УникальныйИдентификатор())); 
		
		Если этотОбъектУдален Тогда
			образ.Вставить("_ОбъектУдален", Истина);
		Иначе
			образ.Вставить("_Представление", Строка(ссылкаОбъекта));
		КонецЕсли;

	КонецЕсли; 
	
	// Коллекция исключаемых свойств
	коллекцияИсключаемых = общ.Коллекция_ПоЗначению(пИсключаяСвойства); 
	
	// __Все__ эквивалентно "Исключить все"
	нуженМинимальныйОбраз = общ.Коллекция_Свойство(коллекцияИсключаемых, л__Все__()); 
	Если нуженМинимальныйОбраз Или этотОбъектУдален Или этоПустаяСсылка Тогда  
		образ.Вставить("_ЭтоОбразБезРеквизитов", Истина);
		Возврат образ;
		
	КонецЕсли;

	// Реквизиты определяющие ссылку, нужны для поиска
	#Область ОпределяющиеРеквизиты
	этоПВХ = ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(типОбъекта);
	этоПланСчетов = ПланыСчетов.ТипВсеСсылки().СодержитТип(типОбъекта);
	этоСпр = Справочники.ТипВсеСсылки().СодержитТип(типОбъекта);
	естьИерархия = этоСпр Или этоПВХ;
	
	исключитьВложенныеСсылки =
			общ.Коллекция_Свойство(коллекцияИсключаемых, "__ВложенныеСсылки__")
		Или общ.Коллекция_Свойство(коллекцияИсключаемых, "__МеняющиеХеш__")
		;
		
	Если этоПланСчетов Или этоПВХ Или этоСпр Тогда
		образ.Вставить("_ИмяПредопределенныхДанных", ссылкаОбъекта.ИмяПредопределенныхДанных);
		
	КонецЕсли;
	
	// Выгрузить родителя и владельца
	// Для некоторых видов метаданных родитель/владелец является определяющим признаком, наравне с кодом или наименованием
	// Без него невозможно определить верный элемент справочника.
	// Например, такая ситуация в справочнике ВидыКонтактнойИнформации типовых бухгалтерий 3.0 для России
	// Там элементы без кода с одинаковыми наименованиями, отличаются только положением в иерархии, родитель у них разный
	Если этоСпр Тогда
		образ.Вставить("Наименование", ссылкаОбъекта.Наименование);
		
		владелец = ссылкаОбъекта.Владелец;
		исключитьВсеРеквизиты = исключитьВложенныеСсылки Или владелец = ссылкаОбъекта;
		образВладельца = Неопределено;
		Если исключитьВсеРеквизиты Тогда
			образВладельца = обм.Альфа_Образ_Минимальный(владелец);
			
		Иначе
			образВладельца = владелец;
			
		КонецЕсли; 
		образ.Вставить("Владелец", образВладельца);
		
	КонецЕсли;

	Если этоПланСчетов Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(типОбъекта) Тогда
		образ.Вставить("Наименование", ссылкаОбъекта.Наименование);

	КонецЕсли; 
	
	Если естьИерархия Тогда
		образ.Вставить("_ЭтоГруппа", ссылкаОбъекта.ЭтоГруппа);
		образ.Вставить("ЭтоГруппа", ссылкаОбъекта.ЭтоГруппа);
		
		родитель = ссылкаОбъекта.Родитель;
		образРодителя = Неопределено;
		Если исключитьВложенныеСсылки Или родитель = ссылкаОбъекта Тогда
			образРодителя = обм.Альфа_Образ_Минимальный(родитель);
			
		Иначе
			образРодителя = родитель;
			
		КонецЕсли;
		образ.Вставить("Родитель", образРодителя);
		
	КонецЕсли;
	
	этоДокумент = Документы.ТипВсеСсылки().СодержитТип(типОбъекта);
		
	#Область исключитьМеняющиеХеш
	// Признак необходимости обезличить объект
	// Если равен истина, то не будут выгружены служебные реквизиты типа кода, номера, проведен, версия данных
	// Используется чтобы сравнивать объекты между собой, путем сравнения хешей коллекций или JSON коллекций
	исключитьМеняющиеХеш = общ.Коллекция_Свойство(коллекцияИсключаемых, "__МеняющиеХеш__");
	Если исключитьМеняющиеХеш Тогда
		образ.Удалить("_НавигационнаяСсылка");
		образ.Удалить("_УникальныйИдентификатор");
		образ.Вставить("_ЭтоОбразДляВычисленияХеша", Истина);
		
	Иначе // Не исключитьМеняющиеХеш
		вставитьКод = этоСпр Или этоПВХ Или этоПланСчетов
			Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(типОбъекта)
			;
		Если вставитьКод Тогда
			образ.Вставить("Код", ссылкаОбъекта.Код);
			
		КонецЕсли;
		
		вставитьНомерДату = этоДокумент Или	Задачи.ТипВсеСсылки().СодержитТип(типОбъекта)
			Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(типОбъекта)
			;
		Если вставитьНомерДату Тогда
			образ.Вставить("Номер", ссылкаОбъекта.Номер);
			образ.Вставить("Дата", ссылкаОбъекта.Дата);
			
		КонецЕсли;
		
	КонецЕсли; // не для хеша
		
	#КонецОбласти // неДляХеша  
	
	#КонецОбласти // ОпределяющиеРеквизиты	

	выгружатьРеквизиты = Не общ.Коллекция_Свойство(коллекцияИсключаемых, "__Реквизиты__");
	Если Не выгружатьРеквизиты Или этоПеречисление Тогда
		Возврат образ;
		
	КонецЕсли; 
	
	// Далее полная выгрузка объекта, реквизитов и табличных частей 
	Если Не исключитьМеняющиеХеш Тогда
		образ.Вставить("ПометкаУдаления", ссылкаОбъекта.ПометкаУдаления);
			
		Если этоНовый Тогда
			образ.Вставить("ЭтоНовый", этоНовый);
				
		КонецЕсли;
			
		Если этоДокумент Тогда
			образ.Вставить("Проведен", ссылкаОбъекта.Проведен);
			
		КонецЕсли; 
		
	КонецЕсли; // Если пВыгрузитьРеквизитыСостояния
	
	мета = Метаданные.НайтиПоТипу(типОбъекта);
	
	// Выгрузить реквизиты 
	выгружатьХранилищаЗначений = Не общ.Коллекция_Свойство(коллекцияИсключаемых, "__ХранилищаЗначений__");
	Для Каждого реквизитМетаданных Из мета.Реквизиты Цикл
		Если общ.Коллекция_Свойство(коллекцияИсключаемых, НРЕГ(реквизитМетаданных.Имя)) Тогда
			Продолжить;
			
		КонецЕсли;
		
		значениеРеквизита = ссылкаОбъекта[реквизитМетаданных.Имя];
		типРеквизита = ТипЗнч(значениеРеквизита);
		
		выгрузкаРазрешена = Истина;
		Если типРеквизита = Тип("ХранилищеЗначения") И Не выгружатьХранилищаЗначений Тогда
			выгрузкаРазрешена = Ложь;
			
		КонецЕсли;
		
		Если выгрузкаРазрешена Тогда
			
			// Запрет циклической ссылки самой на себя - например, ГоловнойКонтрагент у Контрагента это он сам
			исключитьВсеРеквизиты = 	(значениеРеквизита = ссылкаОбъекта) 
									Или (исключитьВложенныеСсылки И общ.ЭтоСсылка(значениеРеквизита))
									;
			Если исключитьВсеРеквизиты Тогда
				образ.Вставить(реквизитМетаданных.Имя, обм.Альфа_Образ_Минимальный(значениеРеквизита));
				
			Иначе				
				образ.Вставить(реквизитМетаданных.Имя, значениеРеквизита);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	реквизитМетаданных = Неопределено;

	// Выгрузить табличные части
	выгружатьТабличныеЧасти = Не общ.Коллекция_Свойство(коллекцияИсключаемых, "__ТабличныеЧасти__"); 
	Если выгружатьТабличныеЧасти Тогда
		Для Каждого тчМетаданных Из мета.ТабличныеЧасти Цикл
			Если общ.Коллекция_Свойство(коллекцияИсключаемых, НРЕГ(тчМетаданных.Имя)) Тогда
				Продолжить;
				
			КонецЕсли;
			
			образТЧ = Новый Массив;
			ТЧ = ссылкаОбъекта[тчМетаданных.Имя];
			Для Каждого рядТЧ Из ТЧ Цикл
				образСтрокиТЧ = Новый Структура;

				// Нужен номер строки для сортировки результирующей ТЧ на выходе
				образСтрокиТЧ.Вставить("_НомерСтроки", рядТЧ.НомерСтроки);
				образСтрокиТЧ.Вставить("НомерСтроки", рядТЧ.НомерСтроки); 
				
				Для Каждого реквизитТчМетаданных Из тчМетаданных.Реквизиты Цикл
					Если общ.Коллекция_Свойство(коллекцияИсключаемых, НРЕГ(тчМетаданных.Имя + "." + реквизитТчМетаданных.Имя)) Тогда
						Продолжить;
						
					КонецЕсли;
					
					значениеРеквизитаТЧ = рядТЧ[реквизитТчМетаданных.Имя];
					типРеквизитаТЧ = ТипЗнч(значениеРеквизитаТЧ);
					
					Если общ.ЭтоСсылка(типРеквизитаТЧ) И (исключитьВложенныеСсылки Или значениеРеквизита = ссылкаОбъекта) Тогда
						образСтрокиТЧ.Вставить(реквизитТчМетаданных.Имя, обм.Альфа_Образ_Минимальный(значениеРеквизитаТЧ));
						
					Иначе
						образСтрокиТЧ.Вставить(реквизитТчМетаданных.Имя, значениеРеквизитаТЧ); 
						
					КонецЕсли;

				КонецЦикла;
				реквизитТчМетаданных = Неопределено;
				
				образТЧ.Добавить(образСтрокиТЧ);
				
			КонецЦикла;
			рядТЧ = Неопределено;
			
			образ.Вставить(тчМетаданных.Имя, образТЧ); 

		КонецЦикла;
		тчМетаданных = Неопределено;
		
	КонецЕсли; // Если выгружатьТабличныеЧасти
		
	// Специфика плана счетов
	Если этоПланСчетов Тогда
		// Признаки учета
		Для Каждого признакУчета Из мета.ПризнакиУчета Цикл
			имяФлагаУчета = признакУчета.Имя;
			
			Если общ.Коллекция_Свойство(коллекцияИсключаемых, НРег(имяФлагаУчета)) Тогда
				Продолжить;
				
			КонецЕсли;
			
			образ.Вставить(имяФлагаУчета, ссылкаОбъекта[имяФлагаУчета]);
			
		КонецЦикла;
		признакУчета = Неопределено;
		
		// Виды субконто
		Если Не общ.Коллекция_Свойство(коллекцияИсключаемых, НРег("ВидыСубконто")) Тогда
			оВидахСубконто = Новый Массив;
			Для индексСубконто = 0 По ссылкаОбъекта.ВидыСубконто.Количество() - 1 Цикл
				
				строкаВидовСубконто = ссылкаОбъекта.ВидыСубконто[индексСубконто];
				образСтрокиВидовСубконто = Новый Структура;
				
				образВидаСубконто = обм.Альфа_Образ_ПоСсылке(строкаВидовСубконто.ВидСубконто);
				образСтрокиВидовСубконто.Вставить("ВидСубконто", образВидаСубконто);
				образСтрокиВидовСубконто.Вставить("НомерСтроки", строкаВидовСубконто.НомерСтроки);
				образСтрокиВидовСубконто.Вставить("_НомерСтроки", строкаВидовСубконто.НомерСтроки);
				
				образСтрокиВидовСубконто.Вставить("Предопределенное", строкаВидовСубконто.Предопределенное);
				образСтрокиВидовСубконто.Вставить("ТолькоОбороты", строкаВидовСубконто.ТолькоОбороты);
				
				Для Каждого признакУчетаСубконто Из мета.ПризнакиУчетаСубконто Цикл 
					имяФлагаУчетаСубконто = признакУчетаСубконто.Имя;
					образСтрокиВидовСубконто.Вставить(имяФлагаУчетаСубконто, строкаВидовСубконто[имяФлагаУчетаСубконто]);
					
				КонецЦикла;
				
				оВидахСубконто.Добавить(образСтрокиВидовСубконто);
				
			КонецЦикла;
			индексСубконто = Неопределено;
			
			образ.Вставить("ВидыСубконто", оВидахСубконто);
			
		КонецЕсли; // Виды субконто счета
		
	КонецЕсли; // Если этоПланСчетов

	Возврат образ;

КонецФункции

Функция Альфа_РазвернутьСсылки(пКоллекция, Знач пУровень, Знач пИсключаяСвойства = Неопределено) Экспорт

	Если Не общ.ЭтоКоллекцияКлючЗначение(пКоллекция) Тогда
		Возврат пКоллекция;
		
	КонецЕсли;
	
	общ.Проверка_Тип(пУровень, "Число");
		
	пУровень = Цел(пУровень);
	Если пУровень <= 0 Тогда
		Возврат пКоллекция;
		
	КонецЕсли;  
	
	коллекцияИсключаемых = общ.Коллекция_ПоЗначению(пИсключаяСвойства);
	
	коллекцияИсключаемых.Вставить("__ТабличныеЧасти__");
	коллекцияИсключаемых.Вставить("__ХранилищаЗначений__");
	
	этоПоследний = пУровень <= 1;
	Если этоПоследний Тогда
		коллекцияИсключаемых.Вставить("__Реквизиты__");
					
	КонецЕсли; 
	
	// Исключаемые свойства должны быть именно в виде строки
	// Потому что если это будет коллекция, то при передаче ее в функцию по ссылке (знач)
	// Она все равно меняется
	стрИсключитьСвойства = Коллекция_КлючиСоединитьВСтроку(коллекцияИсключаемых);

	ссылкаИзКоллекции = Альфа_Ссылка_ПоОбразу(пКоллекция);
	этоПеречисление = Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(ссылкаИзКоллекции));
	метаданныеТЧ = Неопределено;
	Если общ.ЭтоЗаполненнаяСсылка(ссылкаИзКоллекции) И Не этоПеречисление Тогда
		метаданныеТЧ = ссылкаИзКоллекции.Метаданные().ТабличныеЧасти;
		
	КонецЕсли;
	
	// На последнем уровне не разворачивать вложенные ссылки
	коллекцияРазвернутыхЗначений = Новый Соответствие;
	Для Каждого пара Из пКоллекция Цикл 
		
		// Обработка вложенных коллекций, уровень уменьшается
		вПареКоллекция = общ.ЭтоКоллекцияКлючЗначение(пара.Значение);
		Если вПареКоллекция Тогда
			обработаннаяКоллекция = Альфа_РазвернутьСсылки(пара.Значение, пУровень - 1, стрИсключитьСвойства);
			
			коллекцияРазвернутыхЗначений.Вставить(пара.Ключ, обработаннаяКоллекция);
			
			Продолжить;
			
		КонецЕсли;

		// Обработка ссылок
		Если общ.ЭтоСсылка(пара.Значение) Тогда
			текущаяСсылка = пара.Значение;
			образСсылки = обм.Альфа_Образ_ПоСсылке(текущаяСсылка, стрИсключитьСвойства);
			коллекцияРазвернутыхЗначений.Вставить(пара.Ключ, образСсылки); 
			
			Продолжить;
			
		КонецЕсли;
			
		// Рекурсивный вызов для табличных частей, уровень остается неизменным 
		этоОбразТЧ = 
			ТипЗнч(пара.Значение) = Тип("Массив")
			И	ТипЗнч(метаданныеТЧ) = Тип("КоллекцияОбъектовМетаданных") 
			И	метаданныеТЧ.Найти(пара.Ключ) <> Неопределено 
			;
		Если этоОбразТЧ	Тогда
			массивРазвернутыхСтрокТЧ = Новый Массив;
			Для Каждого образСтрокиТЧ Из пара.Значение Цикл
				Если общ.ЭтоКоллекцияКлючЗначение(образСтрокиТЧ) Тогда
					развернутыйОбразСтрокиТЧ = Альфа_РазвернутьСсылки(образСтрокиТЧ, пУровень, стрИсключитьСвойства);
					массивРазвернутыхСтрокТЧ.Добавить(развернутыйОбразСтрокиТЧ);
					
				Иначе
					массивРазвернутыхСтрокТЧ.Добавить(образСтрокиТЧ);
					
				КонецЕсли;
			
			КонецЦикла; образСтрокиТЧ = Неопределено;
			
			коллекцияРазвернутыхЗначений.Вставить(пара.Ключ, массивРазвернутыхСтрокТЧ);
			
			Продолжить;
			
		КонецЕсли;
			
	КонецЦикла; пара = Неопределено;
	
	// Заменить в исходной коллекции ссылки на развернутые коллекции
	Для Каждого пара Из коллекцияРазвернутыхЗначений Цикл
		пКоллекция.Вставить(пара.Ключ, пара.Значение);
		
	КонецЦикла; пара = Неопределено;
	
	Возврат пКоллекция;
	
КонецФункции

// Функция обратная ЗначениеВJSON для ссылочных объектов
Функция Альфа_Ссылка_ПоОбразу(пОбразАльфа) Экспорт
	
	Если НЕ общ.ЭтоКоллекцияКлючЗначение(пОбразАльфа) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	типСсылки = Неопределено;
	стрТипСсылки = Неопределено;
	Если общ.Коллекция_Свойство(пОбразАльфа, "_Тип", стрТипСсылки) Тогда
		типСсылки = общ.Тип_ПоСтроке(стрТипСсылки);
	КонецЕсли;
	
	Если НЕ общ.Тип_ЭтоСсылка(типСсылки) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// 0. Значение перечисления
	этоПеречисление = Перечисления.ТипВсеСсылки().СодержитТип(типСсылки);
	Если этоПеречисление Тогда
		перечисление_менеджер = общ.Менеджер_ПоОбъекту(типСсылки);
		Если Общ.Коллекция_Свойство(пОбразАльфа, "_ПустаяСсылка") Тогда
			Возврат перечисление_менеджер.ПустаяСсылка();
			
		КонецЕсли;
		
		имяПеречисления = "";
		Если НЕ общ.Коллекция_Свойство(пОбразАльфа, "_Значение") Тогда
			Возврат Неопределено;
			
		КонецЕсли;
		
		мета = перечисление_менеджер.пустаяСсылка().Метаданные();
		перечисление_существует = мета.ЗначенияПеречисления.Найти(имяПеречисления) <> Неопределено;
		Если перечисление_существует Тогда
			Возврат перечисление_менеджер[имяПеречисления];
			
		Иначе
			Возврат Неопределено;
			
		КонецЕсли;
		
	КонецЕсли; // этоПеречисление
	
	// 1. Искать по навигационной ссылке
	навигационнаяСсылка = Неопределено;
	естьНавигационнаяСсылка =
		общ.Коллекция_Свойство(пОбразАльфа, "_НавигационнаяСсылка", навигационнаяСсылка)
		И ЗначениеЗаполнено(навигационнаяСсылка)
		;
	
	Если естьНавигационнаяСсылка Тогда
		ссылкаРезультат = общ.Ссылка_ПоНавигационнойСсылке(навигационнаяСсылка);
		Если общ.ЭтоЗаполненнаяСсылка(ссылкаРезультат) Тогда
			Возврат ссылкаРезультат;
			
		Иначе
			ссылкаРезультат = Неопределено;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// 2. Искать по типу и уникальному идентификатору
	менеджер = общ.Менеджер_ПоОбъекту(типСсылки);
	
	уид = Неопределено;
	Если 	общ.Коллекция_Свойство(пОбразАльфа, "_УникальныйИдентификатор", уид) 
		И 	общ.Строка_ЭтоУникальныйИдентификатор(уид) 
		Тогда
		ссылкаРезультат = менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(пОбразАльфа["_УникальныйИдентификатор"]));
		
	Иначе
		ссылкаРезультат = менеджер.ПустаяСсылка();
		
	КонецЕсли;
	
	Возврат ссылкаРезультат;
	
КонецФункции

#КонецОбласти // ФорматОбмАльфа

#Область Отправка

// Для использования в переопределяемых обработчиках интерфейсов
Функция Отправить_HTTP_POST(пСообщение, пПараметры, текстОтвета = Неопределено) Экспорт
	
		кодСостояния = 501; // Не выполнено
		
		адресРесурса = общ.Коллекция_ЗначениеПоПути(пПараметры, "АдресРесурса");
		
		Если НЕ ЗначениеЗаполнено(адресРесурса) Тогда
			кодСостояния = 422; // 422 Unprocessable Entity
			Возврат кодСостояния;
			
		КонецЕсли;
		
		заголовки = Новый Соответствие;
		заголовки.Вставить("Content-Charset", "utf-8");
		заголовки.Вставить("Content-Type", "text/plain; charset=utf-8");
		
		// Добавить в заголовки элементы, если они переданы в параметрах
		пЗаголовки = общ.Коллекция_ЗначениеПоПути(пПараметры, "Заголовки");
		Если общ.ЭтоКоллекцияКлючЗначение(пЗаголовки) Тогда
			Для Каждого пара Из пЗаголовки Цикл
				заголовки.Вставить(пара.Ключ, пара.Значение);
				
			КонецЦикла;
			пара = Неопределено;
			
		КонецЕсли;
		
		запрос = Новый HTTPЗапрос(адресРесурса, заголовки);
		
		// Сформировать сообщение
		стрСообщение = "";
		Если
			общ.ЭтоКоллекцияКлючЗначение(пСообщение)
			ИЛИ общ.ЭтоСсылка(пСообщение)
			Тогда
			стрСообщение = общ.JSON(пСообщение);
			заголовки.Вставить("Content-Type", "application/json");
			
		ИначеЕсли ТипЗнч(пСообщение) = Тип("Строка") Тогда
			стрСообщение = пСообщение;
			
		Иначе
			стрСообщение = Строка(пСообщение);
			
		КонецЕсли;
		
		запрос.УстановитьТелоИзСтроки(стрСообщение, КодировкаТекста.UTF8);
		
		сервер = общ.Коллекция_ЗначениеПоПути(пПараметры, "Сервер");
		
		соединение = Новый HTTPСоединение(сервер);
		соединение.Таймаут = 15;
		ЗаполнитьЗначенияСвойств(соединение, пПараметры);
		
		ответ = соединение.ВызватьHTTPМетод("POST", запрос);
		
		// Получить тело ответа из временного файла
		кодировка = КодировкаТекста.UTF8; // Кодировка по умолчанию
		
		// Если в заголовка ответа есть свойство "Content-Encoding", то из него получить кодировку
		Если ответ.Заголовки.Получить("Content-Encoding") = "ANSI" Тогда
			кодировка = "windows-1251"; // указывать кодировку явно, на Linux сервере кодировка ANSI не 1251
			
		КонецЕсли;
		
		имяСобытия = ИмяСобытияЖурналаРегистрации("Отправка.Отправить_HTTP_POST"); 
		текстОтвета = ответ.ПолучитьТелоКакСтроку(кодировка);
		уровеньЖурнала = ?(кодСостояния = Код200(), УровеньЖурналаРегистрации.Информация, УровеньЖурналаРегистрации.Ошибка);
		общ.ВЖурнал(имяСобытия, текстОтвета, уровеньЖурнала);

		Возврат кодСостояния;
	
КонецФункции

#КонецОбласти // Отправка

#Область Получение

// Обработать все необработанные запросы
Процедура Получение_ОбработатьОчередь(пИзвлечьПакетыДанных = Истина, пОбработатьПакетыДанных = Истина) Экспорт
	
	// 0. Запрос поиска входящих запросов в определенном статусе
	Запрос = Новый Запрос;
	
	// Использование виртуальной таблицы без параметров здесь оправдано,
	// т.к. надо получить ссылки на аходящие сообщения в определенном статусе
	// 
	// BSLLS:VirtualTableCallWithoutParameters-off
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 100
		|	Т.ВходящееСообщение КАК Ссылка
		|ИЗ
		|	РегистрСведений.обм_ВходящиеСообщения_Статусы.СрезПоследних КАК Т
		|ГДЕ
		|	Т.Статус В(&СтатусДляПоиска)
		|	И НЕ Т.ВходящееСообщение.ПометкаУдаления
		|
		|УПОРЯДОЧИТЬ ПО
		|	Т.Период";
	// BSLLS:VirtualTableCallWithoutParameters-on
	
	// Ниже запрос в цикле, чтобы реализовать порционную обработку данных
	// BSLLS:CreateQueryInCycle-off
	Пока Истина Цикл
		счетчик = 0;
		
		// 1. Сначала найти все входящие запросы в статусе "Ждет обработки" и завершить их обработку
		Если пОбработатьПакетыДанных Тогда
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.ЖдетОбработки);
			входящиеСообщения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
			
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Обработать(входящиеСообщения);
			
			счетчик = счетчик + входящиеСообщения.Количество();
			
		КонецЕсли;
		
		// 2. Найти все входящие запросы в статусе "Получен" и обработать их
		Если пИзвлечьПакетыДанных Тогда
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.Получен);
			входящиеСообщения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
			
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Извлечь(входящиеСообщения);
			
			счетчик = счетчик + входящиеСообщения.Количество();
			
		КонецЕсли;
		
		Если счетчик = 0 Тогда
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла; 
	счетчик = Неопределено;
	// BSLLS:CreateQueryInCycle-on
	
КонецПроцедуры

Процедура Получение_ФоновоеЗадание() Экспорт
	
	Если общ.ИнформационнаяБаза_Файловая() Тогда
		Получение_ОбработатьОчередь();
		Возврат;
		
	КонецЕсли;
	
	метаЗадания = Метаданные.РегламентныеЗадания.обм_Получение_2_ПакетыДанных_Обработать;
	ключЗадания = метаЗадания.Ключ;
	фоновые = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Ключ", ключЗадания));
	Для Каждого фоновое Из фоновые Цикл
		Если фоновое.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			Возврат;
			
		КонецЕсли;

	КонецЦикла;
	фоновое = Неопределено;
	
	ФоновыеЗадания.Выполнить(
		"обм.Получение_ОбработатьОчередь", // ИмяМетода
		Новый Массив, // Параметры
		ключЗадания, // Ключ
		метаЗадания.Наименование // Наименование
		);

КонецПроцедуры

// Обертка функций модуля менеджера справочника обм_ВходящиеСообщения,
// чтобы их можно было вызывать с клиента
#Область ВходящиеСообщения_ИнтерфейсДляКлиента

Функция ВходящееСообщение_Параметр_Значение(пВходящееСообщениеСсылка, КлючПараметра) Экспорт
	
	Возврат Справочники.обм_ВходящиеСообщения.Параметр_Значение(пВходящееСообщениеСсылка, КлючПараметра);
	
КонецФункции

Функция ВходящееСообщение_СсылкаПоHTTPСервисОтвет(пОтветХТТП) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off
	
	#Если ВнешнееСоединение Тогда
	Возврат Неопределено;
	
	#Иначе
	общ.Проверка_Тип(пОтветХТТП, Тип("HTTPСервисОтвет"));
	
	#КонецЕсли
	
	Если пОтветХТТП.КодСостояния <> Код200() Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Тело ответа содержит:
	// 
	//	{"Status":"RequestReceived",
	//	"Ticket"":"%УникальныйИдентификатор%"
	//	}
	//
	// см. функцию Запрос_Записать
	
	стрОтвет = пОтветХТТП.ПолучитьТелоКакСтроку();
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		образ = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Если ТипЗнч(образ) <> Тип("Соответствие") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	стрИД = образ["Ticket"];
	
	Если стрИД = Неопределено Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Справочники.обм_ВходящиеСообщения.ПолучитьСсылку(Новый УникальныйИдентификатор(стрИД));
	
КонецФункции

Функция ВходящееСообщение_ОшибкаИзHTTPСервисОтвет(пОтветХТТП) Экспорт // BSLLS:LatinAndCyrillicSymbolInWord-off
	
	#Если ВнешнееСоединение Тогда
	Возврат Неопределено;
	
	#Иначе
	общ.Проверка_Тип(пОтветХТТП, Тип("HTTPСервисОтвет"));
	
	#КонецЕсли
	
	// 200 значит нет ошибки
	Если пОтветХТТП.КодСостояния = Код200() Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Тело ответа содержит:
	// 
	// {"Error":"%1"}
	//	
	// см. функцию Запрос_Записать
	
	стрОтвет = пОтветХТТП.ПолучитьТелоКакСтроку();
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		образ = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Если ТипЗнч(образ) <> Тип("Соответствие") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	обОшибке = образ["Error"];
	
	Если обОшибке = Неопределено ИЛИ ПустаяСтрока(обОшибке) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат обОшибке;
	
КонецФункции

Функция ВходящееСообщение_Создать(	пХТТПСервисЗапрос, 
									пНаименованиеЗапроса = Неопределено, 
									пОбработатьВФоне = Истина
									) Экспорт
									
	// Создание входящего сообщения не должно влиять на работу пользователей и алгоритмов
	// поэтому выполнять в прив. режиме, чтобы исключить проблемы с правами
	УстановитьПривилегированныйРежим(Истина); // BSLLS:SetPrivilegedMode-off
	
	имяСобытия = ИмяСобытияЖурналаРегистрации("Получение.ВходящееСообщение_Создать");
	
	HTTPСервисЗапрос_ЗарегистрироватьВЖурнале(имяСобытия, пХТТПСервисЗапрос);
	
	кодСостояния = 400;
	текстОтвета = "";
	
	Попытка
		ВходящееСообщение_Объект = Справочники.обм_ВходящиеСообщения.СоздатьЭлемент();
		СсылкаНового = Справочники.обм_ВходящиеСообщения.ПолучитьСсылку();
		ВходящееСообщение_Объект.ДополнительныеСвойства.Вставить("СсылкаНового", СсылкаНового);
		ВходящееСообщение_Объект.УстановитьСсылкуНового(СсылкаНового);
		
		Если НЕ ПустаяСтрока(пНаименованиеЗапроса) Тогда
			ВходящееСообщение_Объект.Наименование = СокрЛП(пНаименованиеЗапроса);
			
		Иначе
			ВходящееСообщение_Объект.Наименование = Строка(ТипЗнч(пХТТПСервисЗапрос));
			
		КонецЕсли;
		ВходящееСообщение_Объект.Наименование = СтрШаблон(	"%1 %2",
															ВходящееСообщение_Объект.Наименование, // %1
															Строка(СсылкаНового.УникальныйИдентификатор()) // %2
															);
		
		ВходящееСообщение_Объект.ДатаВремя = общ.ДатаУниверсальная();
		ВходящееСообщение_Объект.Запрос = пХТТПСервисЗапрос.ПолучитьТелоКакСтроку();
		
		ЗаполнитьЗначенияСвойств(ВходящееСообщение_Объект, пХТТПСервисЗапрос);
		
		Для Каждого КлючИЗначение Из пХТТПСервисЗапрос.ПараметрыURL Цикл
			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = КлючИЗначение.Ключ;
			рядПараметры.Значение = КлючИЗначение.Значение;
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.URL;
			
		КонецЦикла;
		КлючИЗначение = Неопределено;
		
		Для Каждого КлючИЗначение Из пХТТПСервисЗапрос.ПараметрыЗапроса Цикл
			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = КлючИЗначение.Ключ;
			рядПараметры.Значение = КлючИЗначение.Значение;
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.Запрос;
			
		КонецЦикла;
		
		// Добавить текущего пользователя
		рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
		рядПараметры.Ключ = "ТекущийПользователь_Имя";
		рядПараметры.Значение = ТекущийПользователь_Имя();
		рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
		
		Если ТипЗнч(пНаименованиеЗапроса) = Тип("Структура") Тогда
			Для Каждого пара Из пНаименованиеЗапроса Цикл
				рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
				рядПараметры.Ключ = пара.Ключ;
				рядПараметры.Значение = пара.Значение;
				рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
				
			КонецЦикла; пара = Неопределено;
			
		Иначе
			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = "Метод";
			рядПараметры.Значение = СокрЛП(пНаименованиеЗапроса);
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;

		КонецЕсли;
		
		Для Каждого пара Из пХТТПСервисЗапрос.Заголовки Цикл
			
			// Данные авторизации не фиксировать
			Если НРег(пара.Ключ) = "authorization" Тогда
				Продолжить;
				
			КонецЕсли;
			
			рядПараметры = ВходящееСообщение_Объект.Параметры.Добавить();
			рядПараметры.Ключ = пара.Ключ;
			рядПараметры.Значение = пара.Значение;
			рядПараметры.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.ЗаголовокHTTP;
			
		КонецЦикла; пара = Неопределено;
		
		// Чтобы запрос не обрабатывался регламентным заданием, пометить его на удаление
		// см. Получение_ОбработатьОчередь
		Если НЕ пОбработатьВФоне Тогда
			ВходящееСообщение_Объект.ПометкаУдаления = Истина;
			
		КонецЕсли;
		
		ВходящееСообщение_Объект.Параметры.Сортировать("Ключ");
		
		ВходящееСообщение_Объект.Записать();
		
		кодСостояния = 200;
		уид = Строка(ВходящееСообщение_Объект.Ссылка.УникальныйИдентификатор());
		текстОтвета =
			СтрШаблон(
				"{""Status"":""RequestReceived"",
				|""Ticket"":""%1""
				|}",
				уид // %1
			);
		
	Исключение
		инфоОшибки = ИнформацияОбОшибке();
		общ.Ошибка_ВЖурналРегистрации(имяСобытия, инфоОшибки);
		
		кодСостояния = 500;
		текстОтвета =
			СтрШаблон(
				"{""Error"":""%1""}",
				общ.Ошибка_КраткоеПредставление(инфоОшибки) // %1
			);

	КонецПопытки;
	
	#Если ВнешнееСоединение Тогда
	Ответ = текстОтвета;
	
	#Иначе
	Ответ = Новый HTTPСервисОтвет(кодСостояния);
	Ответ.Заголовки.Вставить("Content-Type", "text/html; charset=utf-8");
	Ответ.УстановитьТелоИзСтроки(текстОтвета);
	
	#КонецЕсли
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Ответ;
	
КонецФункции

Функция ВходящееСообщение_СоздатьЧерезHTTPЗапросЭмуляция(	пУРЛ,  // BSLLS:LatinAndCyrillicSymbolInWord-off
															пДанные,
															пПараметрыЗапроса = Неопределено, 
															пНаименованиеЗапроса = Неопределено, 
															пОбработатьСразу = Ложь
															) Экспорт
	
	общ.Проверка_Тип(пПараметрыЗапроса, "Структура, Соответствие, Неопределено");
	
	эмулятор = Обработки.обм_HTTPЗапросЭмуляция.Создать();
	
	эмулятор.HTTPМетод = "POST";
	
	эмулятор.БазовыйURL = "emul://" + пУРЛ;
	эмулятор.ОтносительныйURL = пУРЛ;
	
	Если ТипЗнч(пДанные) = Тип("Строка") Тогда
		эмулятор.Тело = пДанные;
		
	ИначеЕсли ТипЗнч(пДанные) = Тип("ДвоичныеДанные") Тогда
		эмулятор.Тело = Base64Строка(пДанные);
		
	ИначеЕсли 	ТипЗнч(пДанные) = Тип("Массив") 
			ИЛИ ТипЗнч(пДанные) = Тип("Структура") 
			ИЛИ ТипЗнч(пДанные) = Тип("Соответствие") 
			Тогда
		эмулятор.Тело = Общ.JSON(пДанные);
		
	Иначе
		эмулятор.Тело = Строка(пДанные);
		
	КонецЕсли;
	
	Если пПараметрыЗапроса <> Неопределено Тогда
		Для Каждого пара Из пПараметрыЗапроса Цикл
			эмулятор.ПараметрыЗапроса.Вставить(пара.Ключ, пара.Значение);
			
		КонецЦикла; пара = Неопределено;
		
	КонецЕсли;
	
	// Для предотвращения конфликта между регламентным заданием и обработкой при загрузке пользователем из формы
	// Запретить обработку регламентным заданием
	обработатьВФоне = НЕ пОбработатьСразу;
	ответОЗаписиЗапроса = ВходящееСообщение_Создать(эмулятор, пНаименованиеЗапроса, обработатьВФоне);
	
	Если ответОЗаписиЗапроса.КодСостояния = Код200() И пОбработатьСразу Тогда
		входящееСообщениеСсылка = ВходящееСообщение_СсылкаПоHTTPСервисОтвет(ответОЗаписиЗапроса);
		
		Если ЗначениеЗаполнено(входящееСообщениеСсылка) Тогда
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Извлечь(входящееСообщениеСсылка);
			Справочники.обм_ВходящиеСообщения.ПакетыДанных_Обработать(входящееСообщениеСсылка);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ответОЗаписиЗапроса;
	
КонецФункции

#КонецОбласти // ВходящиеСообщения_ИнтерфейсДляКлиента

#КонецОбласти // Получение

#Область Прочее

Процедура HTTPСервисЗапрос_ЗарегистрироватьВЖурнале(пИмяСобытия, пЗапросХТТП) Экспорт
	
	общ.Проверка_Тип(пЗапросХТТП, Тип("HTTPСервисЗапрос"));
	
	рез = "";
	
	рез = рез + пЗапросХТТП.HTTPМетод + Символы.ПС;
	рез = рез + пЗапросХТТП.БазовыйURL + Символы.ПС;
	рез = рез + пЗапросХТТП.ОтносительныйURL + Символы.ПС;
	рез = рез + "Заголовки:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.Заголовки Цикл
		
		// Данные авторизации не фиксировать
		Если НРег(Параметр.Ключ) = "authorization" Тогда
			Продолжить;
			
		КонецЕсли;
		
		заготовка = СтрЗаменить(Параметр.Значение, ";", "");
		рез = рез + Параметр.Ключ + ":" + заготовка + Символы.ПС;
	КонецЦикла;
	рез = рез + "Параметры URL:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.ПараметрыURL Цикл
		рез = рез + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;
	рез = рез + "Параметры запроса:" + Символы.ПС;
	Для Каждого Параметр Из пЗапросХТТП.ПараметрыЗапроса Цикл
		рез = рез + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;
	
	рез = рез + "BODY:" + пЗапросХТТП.ПолучитьТелоКакСтроку() + Символы.ПС;
	
	ЗаписьЖурналаРегистрации(пИмяСобытия, УровеньЖурналаРегистрации.Информация, , , рез);
	
КонецПроцедуры

Функция ИмяСобытияЖурналаРегистрации(пИмяСобытия = "") Экспорт
	
	частиИмени = Новый Массив;
	частиИмени = общ.Массив_ПоЗначению(пИмяСобытия, Тип("Строка"), ".");
	частиИмени.Вставить(0, "обм");
	
	результат = СтрСоединить(частиИмени);
	
	Возврат результат;
	
КонецФункции

Функция ТекущийПользователь_Имя() Экспорт
	
	// Если не найдено, возвращать текущего пользователя ИБ
	Возврат ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
	
КонецФункции

Функция УРИ(пУзел, пКатегория, пИдентификатор) Экспорт
	
	узел = УзелПривести(пУзел);
	
	стрУРИ = СтрШаблон("odins_obmen/%1/%2/%3", узел, пКатегория, пИдентификатор);
	
	Возврат стрУРИ;
	
КонецФункции

Функция УзелПривести(пУзел) Экспорт
	
	результат = НРег(СокрЛП(пУзел));
	
	Возврат результат;
	
КонецФункции

#КонецОбласти // Прочее

#КонецОбласти // ВнешнийИнтерфейс

#Область СлужебныйПрограммныйИнтерфейс

#Область РегламентныеЗадания

Процедура Отправка_1_ИсходящиеСообщения_Создать() Экспорт
	
	РегистрыСведений.обм_Измененные.ОбработатьОчередьИзмененных();
	
КонецПроцедуры

Процедура Отправка_2_ИсходящиеСообщения_Отправить() Экспорт
	
	РегистрыСведений.обм_КОтправке.ОбработатьОчередьОтправки();
	
КонецПроцедуры

Процедура Получение_1_ПакетыДанных_Извлечь() Экспорт
	
	Получение_ОбработатьОчередь(
		Истина, // извлечь пакеты данных
		Ложь // обработать пакеты данных
	);
	
КонецПроцедуры

Процедура Получение_2_ПакетыДанных_Обработать() Экспорт
	
	Получение_ОбработатьОчередь(
			Ложь, // извлечь пакеты данных
			Истина // обработать пакеты данных
			);
	
КонецПроцедуры

#КонецОбласти // РегламентныеЗадания

#Область ПодпискиНаСобытия

Процедура ПриЗаписи(пИсточник, пОтказ = Ложь) Экспорт
	
	Если пИсточник.ОбменДанными.Загрузка Тогда
		Возврат;
		
	КонецЕсли;
	
	// Объекты подсистемы обм.обмены не пропускаем
	Если ЭтоОбъектПодсистемыОбм(пИсточник) Тогда
		Возврат;
		
	КонецЕсли;
	
	// В скрипты передаем не сам объект, а ссылку на него
	// Так надо, чтобы в скрипте было невозможно изменить объект или его свойства
	источникСсылка = пИсточник.Ссылка;
	
	узелОтправитель = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_УзелОтправитель(), узелОтправитель);
	узелОтправитель = УзелПривести(узелОтправитель);
	
	категорияОтправителя = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_КатегорияОтправителя(), категорияОтправителя);
	идентификаторОтправителя = Неопределено;
	пИсточник.ДополнительныеСвойства.Свойство(обм_лит.Ключ_ИдентификаторОтправителя(), идентификаторОтправителя);
		
	// т.к. у пользователя может не быть прав на РегистрыСведений.обм_Измененные
	УстановитьПривилегированныйРежим(Истина); // BSLLS:SetPrivilegedMode-off
	РегистрыСведений.обм_Измененные.Зарегистрировать(	источникСсылка,
														узелОтправитель,
														категорияОтправителя,
														идентификаторОтправителя		);
	УстановитьПривилегированныйРежим(Ложь);

КонецПроцедуры

#КонецОбласти // Подписки на события

#КонецОбласти // СлужебныйПрограммныйИнтерфейс

#Область ЛитералыИВолшебныеЧисла

Функция Код200()
	
	Возврат 200;
	
КонецФункции

Функция л__Все__()
	
	Возврат "__Все__";
	
КонецФункции

Функция ЭтоОбъектПодсистемыОбм(пОбъект)

	результат =	ТипЗнч(пОбъект) = Тип("СправочникОбъект.обм_ВходящиеСообщения")
		Или ТипЗнч(пОбъект) = Тип("СправочникОбъект.обм_ИсходящиеСообщения")
		Или ТипЗнч(пОбъект) = Тип("СправочникОбъект.обм_ПакетыДанных")
		Или ТипЗнч(пОбъект) = Тип("СправочникОбъект.общ_Обработчики")
		;
	Возврат результат;
	
КонецФункции

#КонецОбласти // Литералы и волшебные числа

#Область СлужебныеПроцедурыИФункции

Процедура Альфа_Образ_ДобавитьМетаданные(пОбразОбъекта)
	
	обОтправителе = Новый Структура;
	обОтправителе.Вставить("Версия", Метаданные.Версия);
	обОтправителе.Вставить("Имя", Метаданные.Имя);
	обОтправителе.Вставить("Синоним", Метаданные.Синоним);
	обОтправителе.Вставить("ИмяКомпьютера", ИмяКомпьютера());
	обОтправителе.Вставить("ИмяПользователя", ИмяПользователя());
	обОтправителе.Вставить("ИмяИнформационнойБазы", общ.ИнформационнаяБаза_Имя());
	обОтправителе.Вставить("ПолноеИмяПользователя", ПолноеИмяПользователя());
	обОтправителе.Вставить("СтрокаСоединенияИнформационнойБазы", СтрокаСоединенияИнформационнойБазы());
	обОтправителе.Вставить("ЧасовойПоясСеанса", ЧасовойПоясСеанса());
	обОтправителе.Вставить("ИдентификаторИнформационнойБазы", общ.ИдентификаторИнформационнойБазы());
	обОтправителе.Вставить("ЭтоТестоваяБаза", общ.ЭтоТестоваяБаза());
	
	си = Новый СистемнаяИнформация;
	обОтправителе.Вставить("ВерсияОС", си.ВерсияОС);
	обОтправителе.Вставить("ВерсияПриложения", си.ВерсияПриложения);
	
	пОбразОбъекта.Вставить("_метаданныеОтправителя", обОтправителе);
	
КонецПроцедуры

Функция Коллекция_КлючиСоединитьВСтроку(пКоллекция)
	
	разделитель = ",";
	
	Если ТипЗнч(пКоллекция) = Тип("Массив") Тогда
		Возврат СтрСоединить(пКоллекция, разделитель);
		
	ИначеЕсли общ.ЭтоКоллекцияКлючЗначение(пКоллекция) Тогда
		стрРезультат = "";
		Для Каждого пара Из пКоллекция Цикл
			Если ПустаяСтрока(пара.Ключ) Тогда
				Продолжить;
				
			КонецЕсли;
			
			Если Не ПустаяСтрока(стрРезультат) Тогда
				стрРезультат = стрРезультат + разделитель;
				
			КонецЕсли;
			
			стрРезультат = стрРезультат + СокрЛП(пара.Ключ);
			
		КонецЦикла;  
		пара = Неопределено;
		
		Возврат стрРезультат;
		
	Иначе
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

Функция Строка_ПоОбразу(пОбраз)
	
	// Формирование строки послания
	стрОбраз = Неопределено;
	Если ТипЗнч(пОбраз) = Тип("Строка") Тогда
		стрОбраз = пОбраз;
		
	ИначеЕсли общ.ЭтоКоллекцияКлючЗначение(пОбраз) Тогда
		стрОбраз = общ.JSON_ПоКоллекции(пОбраз);
		
	Иначе
		стрОбраз = Строка(пОбраз);
		
	КонецЕсли;
	
	Возврат стрОбраз;
	
КонецФункции


#КонецОбласти // СлужебныеПроцедурыИФункции
#Область ВнешнийИнтерфейс 

#Область Отправка

Функция Отправить_HTTP_POST(пСообщение, пПараметры, пРезультат = Неопределено) 
	
	имяСобытия = ИмяСобытияЖурналаРегистрации("Отправка.Отправить_HTTP_POST");
	
	Попытка
		кодСостояния = 501; // Не выполнено 
		
		адресРесурса = общ.Коллекция_Значение(пПараметры, "АдресРесурса");
		
		Если Не ЗначениеЗаполнено(адресРесурса) Тогда 
			кодСостояния = 422; // 422 Unprocessable Entity
			Возврат кодСостояния;
			
		КонецЕсли;
		
		заголовки = Новый Соответствие;
		заголовки.Вставить("Content-Charset", "utf-8");
		заголовки.Вставить("Content-Type", "text/plain; charset=utf-8"); 

		// Добавить в заголовки элементы, если они переданы в параметрах
		пЗаголовки = общ.Коллекция_Значение(пПараметры, "Заголовки");
		Если общ.ЭтоКоллекцияКлючЗначение(пЗаголовки) Тогда
			Для Каждого пара из пЗаголовки Цикл
				заголовки.Вставить(пара.Ключ, пара.Значение);
				
			КонецЦикла;
			пара = Неопределено;
			
		КонецЕсли;
		
		запрос = Новый HTTPЗапрос(адресРесурса, заголовки);
		
		// Сформировать сообщение
		стрСообщение = "";
		Если 
				общ.ЭтоКоллекцияКлючЗначение(пСообщение)
			Или общ.ЭтоСсылка(пСообщение)
		Тогда
			стрСообщение = общ.ЗначениеВJSON(пСообщение);
			заголовки.Вставить("Content-Type", "application/json");	

		ИначеЕсли ТипЗнч(пСообщение) = Тип("Строка") Тогда
			стрСообщение = пСообщение;
			
		Иначе
			стрСообщение = Строка(пСообщение);
			
		КонецЕсли;
		
		запрос.УстановитьТелоИзСтроки(стрСообщение, КодировкаТекста.UTF8);

		соединение = Новый HTTPСоединение(общ.Коллекция_Значение(пПараметры, "Сервер"));
		ЗаполнитьЗначенияСвойств(соединение, пПараметры);

		ответ = соединение.ВызватьHTTPМетод("POST", запрос);

		// Получить тело ответа из временного файла
		кодировка = КодировкаТекста.UTF8; // Кодировка по умолчанию
			 
		// Если в заголовка ответа есть свойство "Content-Encoding", то из него получить кодировку
		Если ответ.Заголовки.Получить("Content-Encoding") = "ANSI" Тогда
			кодировка = "windows-1251"; // указывать кодировку явно, на linux сервере кодировка ANSI не 1251

		КонецЕсли;

		пРезультат = ответ.ПолучитьТелоКакСтроку(); 
		 
		ЗаписьЖурналаРегистрации(
			имяСобытия,
			?(КодСостояния = 200, УровеньЖурналаРегистрации.Информация, УровеньЖурналаРегистрации.Ошибка),
			, // Объект метаданныех
			, // Данные
			пРезультат, // Комментарий
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
			);
	 
 	Исключение
		КодСостояния = 500; // Внутренняя ошибка сервера
	 
		пРезультат = ИнформацияОбОшибке(); 

		ЗаписьЖурналаРегистрации(
			имяСобытия,
			УровеньЖурналаРегистрации.Ошибка,
			, // Объект метаданныех
			, // Данные
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), // Комментарий
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
			);
			
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

Процедура Отправка_АдресацияИзмененных() Экспорт
	
	имяСобытия = ИмяСобытияЖурналаРегистрации("Отправка.АдресацияИзмененных");
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Т.Ссылка КАК Ссылка,
	|	Т.ВерсияДанных КАК ВерсияДанных,
	|	Т.УзелОтправитель КАК УзелОтправитель,
	|	Т.Категория КАК Категория,
	|	Т.Идентификатор КАК Идентификатор
	|ИЗ
	|	РегистрСведений.обм_Измененные КАК Т
	|
	|УПОРЯДОЧИТЬ ПО
	|	Т.ДатаВремя";
	
	выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл  
		
		Если Не общ.ЭтоЗаполненнаяСсылка(выборка.Ссылка) Тогда
			Продолжить;
			
		КонецЕсли;
		
		Попытка
			АдресацияКОтправке(выборка.Ссылка, выборка.ВерсияДанных, выборка.УзелОтправитель, выборка.Категория, выборка.Идентификатор);
			
		Исключение
			имяСобытия = обм.ИмяСобытияЖурналаРегистрации("Отправка.АдресацияИзмененных");
			инфоОшибки = ИнформацияОбОшибке();
			стрОбОшибке = ОбработкаОшибок.ПодробноеПредставлениеОшибки(инфоОшибки);
			ЗаписьЖурналаРегистрации(
				имяСобытия, // "Отправка.АдресацияИзмененных"
				УровеньЖурналаРегистрации.Ошибка,
				выборка.Ссылка.Метаданные,
				выборка.Ссылка,
				стрОбОшибке,
				РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
				);

		КонецПопытки;
		
	КонецЦикла;
	Выборка.Сбросить();
		
КонецПроцедуры 

Процедура АдресацияКОтправке(пСсылка, пВерсияДанных = Неопределено, пУзелОтправитель = Неопределено, пКатегория = Неопределено, пИдентификатор = Неопределено, пОставитьРегистрациюИзмененных = Ложь) Экспорт
	
	Если Не общ.ЭтоЗаполненнаяСсылка(пСсылка) Тогда
		Возврат;
		
	КонецЕсли;  

	структураПараметры = Новый Структура;
	структураПараметры.Вставить("ВерсияДанных", пВерсияДанных);
	структураПараметры.Вставить("УзелОтправитель", пУзелОтправитель);
	структураПараметры.Вставить("Категория", пКатегория);
	структураПараметры.Вставить("Идентификатор", пИдентификатор);
	коллекцияУзловПолучателей = общ_адм.ВыполнитьОбработчик("обм_Измененные_Адресация", пСсылка, структураПараметры);
				
	Если ТипЗнч(коллекцияУзловПолучателей) = Неопределено Тогда
		коллекцияУзловПолучателей = Новый Соответствие;
		коллекцияУзловПолучателей.Вставить(пСсылка, Новый Массив);

	ИначеЕсли ТипЗнч(коллекцияУзловПолучателей) = Тип("Массив") Тогда
		массивУзлов = коллекцияУзловПолучателей;
		коллекцияУзловПолучателей = Новый Соответствие;
		коллекцияУзловПолучателей.Вставить(пСсылка, массивУзлов);
			
	ИначеЕсли ТипЗнч(коллекцияУзловПолучателей) = Тип("Строка") Тогда
		массивУзлов = СтрРазделить(коллекцияУзловПолучателей, ",", Ложь);
		коллекцияУзловПолучателей = Новый Соответствие;
		коллекцияУзловПолучателей.Вставить(пСсылка, массивУзлов);
		
	ИначеЕсли ТипЗнч(коллекцияУзловПолучателей) = Тип("Соответствие") Тогда
		// Структура для обработки по умолчанию, модифицировать не надо
		
	Иначе
		ВызватьИсключение СтрШаблон("Тип '%1' для коллекции узлов адресации не поддерживается", ТипЗнч(коллекцияУзловПолучателей));
		
	КонецЕсли; // Если ТипЗнч(коллекцияУзловПолучателей) ...
		
	Для Каждого пара Из коллекцияУзловПолучателей Цикл
		отправляемаяСсылка = пара.Ключ;
		массивУзловПолучателей = пара.Значение; 
			
		Если Не общ.ЭтоЗаполненнаяСсылка(отправляемаяСсылка) Тогда
			Продолжить;
				
		КонецЕсли; 
			
		Если ТипЗнч(массивУзловПолучателей) <> Тип("Массив") Или массивУзловПолучателей.Количество() = 0 Тогда
			Продолжить;
				
		КонецЕсли;

		стрПосланиеБазовое = Неопределено;
		посланиеБазовоеСформировано = Ложь; 
		
		Для Каждого узелПолучатель Из массивУзловПолучателей Цикл
			Если ПустаяСтрока(узелПолучатель) Тогда
				Продолжить;
					
			КонецЕсли;
			
			// Сначала попытатьсясформировать послание для узла
			стрПослание = Послание_СформироватьДляУзла(отправляемаяСсылка, узелПолучатель);
			
			// Если для узла не сформировано, сформировать базовое послание
			Если ПустаяСтрока(стрПослание) Тогда
				Если Не посланиеБазовоеСформировано Тогда
					стрПосланиеБазовое = Послание_СформироватьПоУмолчанию(отправляемаяСсылка);
					посланиеБазовоеСформировано = Истина;
						
				КонецЕсли;
					
				стрПослание = стрПосланиеБазовое;
					
			КонецЕсли;
			
			Если ПустаяСтрока(стрПослание) Тогда
				обОшибкеСозданияПослания = 
					СтрШаблон(
						"При адресации измененного объекта %1 тип %2 (%3 тип %4) не создано послание для получателя %3",
						отправляемаяСсылка,
						ТипЗнч(отправляемаяСсылка),
						пСсылка,
						ТипЗнч(пСсылка),
						узелПолучатель
						);
						
				// Дополнительная заппись если по одной ссылке для отправки регистрируется несколько других ссылок
				Если отправляемаяСсылка <> пСсылка Тогда
					имяСобытия = обм.ИмяСобытияЖурналаРегистрации("Отправка.АдресацияИзмененных");
					ЗаписьЖурналаРегистрации(
						имяСобытия, // "Отправка.АдресацияИзмененных"
		                УровеньЖурналаРегистрации.Ошибка,
						отправляемаяСсылка.Метаданные,
						отправляемаяСсылка,
						обОшибкеСозданияПослания,
						РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
						); 
							
				КонецЕсли;
					
				// Если не удалось сформировать послание, дальше не обрабатывать
				ВызватьИсключение обОшибкеСозданияПослания;
				
			КонецЕсли;
			
			РегистрыСведений.обм_КОтправке.Зарегистрировать(
				узелПолучатель, // Узел
				, // Категория
				,  // Идентификатор
				отправляемаяСсылка, // Ссылка
				стрПослание  // строка сообщения
				);

		КонецЦикла;
		узелПолучатель = Неопределено;
		
	КонецЦикла;
	пара = Неопределено;
	
	Если Не пОставитьРегистрациюИзмененных Тогда
		РегистрыСведений.обм_Измененные.УдалитьРегистрацию(пСсылка, пВерсияДанных); 
		
	КонецЕсли;
	
КонецПроцедуры // АдресацияКОтправке

Функция Отправка_Отправка() Экспорт 
	
	имяСобытия = обм.ИмяСобытияЖурналаРегистрации("Отправка.ОбработатьОчередь");
	
	массивУзловСОшибками = Новый Массив;
	Пока Истина Цикл 
		стрОбОшибке = "";

		объектВыгружен = Ложь; 
		представлениеОшибки = "";
		
		// Выбрать первую запись по ФИФО
		зпрс = Новый Запрос;
		зпрс.УстановитьПараметр("массивУзловСОшибками", массивУзловСОшибками);
		зпрс.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 100
		|	Т.Послание КАК Послание,
		|	Т.Узел КАК Узел,
		|	Т.Категория КАК Категория,
		|	Т.Идентификатор КАК Идентификатор,
		|	Т.ВерсияДанных КАК ВерсияДанных,
		|	Т.Ссылка КАК Ссылка
		|ИЗ
		|	РегистрСведений.обм_КОтправке КАК Т
		|ГДЕ
		|	НЕ Т.ФлагОшибки
		|	И НЕ Т.Узел В (&массивУзловСОшибками)
		|
		|УПОРЯДОЧИТЬ ПО
		|	Т.ДатаВремя"; 
		
		вбрк = зпрс.Выполнить().Выбрать();
		
		Если вбрк.Количество() = 0 Тогда
			// Если закончились записи в регистре,
			// сбросить флаги ошибок, чтобы данные выгрузились в следующий раз
			// И выйти
			РегистрыСведений.обм_КОтправке.СброситьВсеФлагиОшибки();
			Прервать;
			
		КонецЕсли; 
		
		Пока вбрк.Следующий() Цикл 
			НачатьТранзакцию();
			
			структураПараметров = Новый Структура("Ссылка, Узел, Категория, Идентификатор");
			ЗаполнитьЗначенияСвойств(структураПараметров, вбрк);
			результатОтправки = Послание_Отправить(вбрк.Послание, вбрк.Узел, вбрк.Категория, вбрк.Идентификатор, вбрк.Ссылка);
			
			отказ = ТипЗнч(результатОтправки) = Тип("ИнформацияОбОшибке");

			Если отказ Тогда
				ОтменитьТранзакцию(); 
				
				РегистрыСведений.обм_КОтправке.ПоднятьФлагОшибки(вбрк.Узел, вбрк.Категория, вбрк.Идентификатор);
				//массивУзловСОшибками.Добавить(вбрк.Узел);
				
				стрОбОшибке = 
					СтрШаблон(
						"Ошибка при отправке образа объекта %1 типа '%2'
						|%3
						|в узел: %4
						|категория: %5
						|идентификатор: %6
						|По причине
						|%7",
						вбрк.Ссылка, // %1
						ТипЗнч(вбрк.Ссылка), // %2
						общ.НавигационнаяСсылка(вбрк.Ссылка), // %3 
						вбрк.Узел, // %4
						вбрк.Категория, // %5
						вбрк.Идентификатор, // %6
						стрОбОшибке // %7
						);
					
				ЗаписьЖурналаРегистрации(
					имяСобытия,
					УровеньЖурналаРегистрации.Ошибка,
					,
					вбрк.Ссылка,
					стрОбОшибке,
					РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
					); 
					
				Прервать;

			КонецЕсли;
					
			РегистрыСведений.обм_КОтправке.УдалитьРегистрацию(
				вбрк.Узел, 
				вбрк.Категория, 
				вбрк.Идентификатор, 
				вбрк.ВерсияДанных
				);
						
			// В журнале регистрации сделать запись о выгрузке объекта 
			стрРезультатВыгрузки = 
				СтрШаблон(
					"Объект %1 выгружен в 
					|узел: %2
					|категория: %3
					|идентификатор: %4",
					вбрк.Ссылка, // %1
					вбрк.Узел, // %2
					вбрк.Категория, // %3
					вбрк.Идентификатор // %4
					);
					
			ЗаписьЖурналаРегистрации(
				имяСобытия,
				УровеньЖурналаРегистрации.Информация,
				, // Объект метаданных
				вбрк.Ссылка,
				стрРезультатВыгрузки, // Комментарий
				РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная
				);
						
			ЗафиксироватьТранзакцию();

		КонецЦикла;
		вбрк = Неопределено;

	КонецЦикла; // Пока Истина Цикл
	
КонецФункции

Функция Послание_Отправить(пПослание, пУзел, пКатегория, пИдентификатор, пСсылка = Неопределено) Экспорт
	
	пПараметры = Новый Структура;
	пПараметры.Вставить("Послание", пПослание);
	пПараметры.Вставить("Узел", пУзел);
	пПараметры.Вставить("Категория", пКатегория);
	пПараметры.Вставить("Идентификатор", пИдентификатор);
	
	Попытка
		результат = общ_адм.ВыполнитьОбработчик("обм_ОтправитьПослание", пСсылка, пПараметры); 
		
	Исключение
		результат = ИнформацияОбОшибке();
		
	КонецПопытки;
	
	Возврат результат;
	
КонецФункции  

Функция Послание_ПривестиКСтроке(пПослание)
	
	// Формирование строки послания
	стрПослание = Неопределено;
	Если ТипЗнч(пПослание) = Тип("Строка") Тогда
		стрПослание = пПослание;
		
	ИначеЕсли общ.ЭтоКоллекцияКлючЗначение(пПослание) Тогда
		стрПослание = общ.Коллекция_ЗаписатьJSONсСортировкой(пПослание);
		
	Иначе
		стрПослание = Строка(пПослание);
			
	КонецЕсли;			
	
	Возврат стрПослание; 
	
КонецФункции

Функция Послание_СформироватьПоУмолчанию(пИсточник) Экспорт

	послание = Неопределено;			

	// Сформировать образ объекта переопределяемым скриптом
	// скрипт не зависит от узла
	послание = общ_адм.ВыполнитьОбработчик("обм_СфомироватьОбразОбъекта", пИсточник);
	
	// Если скрипт не сформировал образ объекта, сформировать стандартным способом
	Если послание = Неопределено Тогда 
		послание = общ.СсылкаВКоллекцию(пИсточник);
		общ.Коллекция_РазвернутьСсылки(послание, 2);
		обм.ПодписатьМетаданными(послание);
		
	КонецЕсли;
		
	Возврат Послание_ПривестиКСтроке(послание); 
	
КонецФункции 

Функция Послание_СформироватьДляУзла(пИсточник, пУзел)
	
	Если ПустаяСтрока(пУзел) Тогда
		Возврат Неопределено;
		
	КонецЕсли;

	// Сформировать образ объекта скриптом, в контексте которого доступен узел
	структураПараметров = Новый Структура("Ссылка, Узел", пИсточник, пУзел);
	образИсточника = общ_адм.ВыполнитьОбработчик("обм_СфомироватьОбразОбъектаДляУзла", пИсточник, структураПараметров);

	Возврат Послание_ПривестиКСтроке(образИсточника); 
	
КонецФункции

Функция ПодписатьМетаданными(пОбразОбъекта) Экспорт
	
	обОтправителе = Новый Структура;
	обОтправителе.Вставить("Версия", Метаданные.Версия); 
	обОтправителе.Вставить("Имя", Метаданные.Имя);
	обОтправителе.Вставить("Синоним", Метаданные.Синоним);
	обОтправителе.Вставить("ИмяКомпьютера", ИмяКомпьютера()); 
	обОтправителе.Вставить("ИмяПользователя", ИмяПользователя());
	
	// 20230713
	обОтправителе.Вставить("ИмяИнформационнойБазы", общ.ИнформационнаяБазаИмя());
	
	обОтправителе.Вставить("ПолноеИмяПользователя", ПолноеИмяПользователя());
	обОтправителе.Вставить("СтрокаСоединенияИнформационнойБазы", СтрокаСоединенияИнформационнойБазы());
	
	// Текущую дату сеанса не включать в сообщение, потому что она меняется
	// В приемнике изменяется хеш сообщения
	// И приемник считает каждое новое сообщение изменненным
	//обОтправителе.Вставить("ТекущаяДатаСеанса", ТекущаяДатаСеанса());
	
	обОтправителе.Вставить("ЧасовойПоясСеанса", ЧасовойПоясСеанса());
	обОтправителе.Вставить("ИдентификаторИнформационнойБазы", общ.ИдентификаторИнформационнойБазы());
	обОтправителе.Вставить("ЭтоТестоваяБаза", общ_Кэш.ЭтоТестоваяБаза());
	
	си = Новый СистемнаяИнформация;
	обОтправителе.Вставить("ВерсияОС", си.ВерсияОС);
	обОтправителе.Вставить("ВерсияПриложения", си.ВерсияПриложения);

	пОбразОбъекта.Вставить("_метаданныеОтправителя", обОтправителе);
	
КонецФункции	

#КонецОбласти // Отправка

#Область Получение

// Обработать все необработанные запросы
Процедура Получение_ОбработатьОчередь(пСоздатьДанныеЗаполнения = Истина, пОбработатьДанныеЗаполнения = Истина) Экспорт

	// 0. Запрос поиска входящих запросов в определенном статусе
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 100
	|	Т.ВходящееСообщение КАК Ссылка
	|ИЗ
	|	РегистрСведений.обм_ВходящиеСообщения_Статусы.СрезПоследних(&ТекущаяДата, ) КАК Т
	|ГДЕ
	|	Т.Статус В(&СтатусДляПоиска)
	|	И НЕ Т.ВходящееСообщение.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	Т.Период"; 
	
	обработчик = Обработки.обм_ВходящиеСообщения_Обработка.Создать(); 
	
	Пока Истина Цикл
		
		счетчик = 0;
		
		// 1. Сначала найти все входящие запросы в статусе "Ждет обработки" и завершить их обработку
		Если пОбработатьДанныеЗаполнения Тогда
			Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДата());
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.ЖдетОбработки);
			входящиеСообщенияМассив = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");

			обработчик.ВходящиеСообщения_ОбработатьДанныеЗаполнения(входящиеСообщенияМассив);
			
			счетчик = счетчик + входящиеСообщенияМассив.Количество();
			
		КонецЕсли;
		
		// 2. Найти все входящие запросы в статусе "Получен" и обработать их
		Если пСоздатьДанныеЗаполнения Тогда
			Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДата());
			Запрос.УстановитьПараметр("СтатусДляПоиска", Перечисления.обм_ВходящиеСообщения_Статусы.Получен);
			входящиеСообщенияМассив = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
			
			обработчик.ВходящиеСообщения_ДанныеЗаполнения_Создать(входящиеСообщенияМассив); 
			
			счетчик = счетчик + входящиеСообщенияМассив.Количество(); 
			
		КонецЕсли;
		
		Если счетчик = 0 Тогда
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла; // Пока Истина Цикл
	
	
КонецПроцедуры

Процедура Получение_ОбработатьДанныеЗаполнения() Экспорт 
	
	Получение_ОбработатьОчередь(
		Ложь,  // Создавать данные заполнения
		Истина  // Обрабатывать даннные заполнения
		);
	
КонецПроцедуры

Процедура Получение_СоздатьДанныеЗаполнения() Экспорт 
	
	Получение_ОбработатьОчередь(
		Истина, // Создавать данные заполнения
		Ложь // Обрабатывать данные заполнения
		);
	
КонецПроцедуры

Процедура Получение_ФоновоеЗадание() Экспорт
	
	Ключ = Метаданные.РегламентныеЗадания.обм_Получение_ОбработатьДанныеЗаполнения.Ключ;
	Наименование = Метаданные.РегламентныеЗадания.обм_Получение_ОбработатьДанныеЗаполнения.Наименование;
	
	Если общ.ИнформационнаяБазаФайловая() Тогда
		Получение_ОбработатьОчередь();		
		Возврат;
		
	КонецЕсли;
	
	Активно = Ложь;
	Для Каждого ФЗ Из ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Ключ",Ключ)) Цикл 
		Если ФЗ.Состояние = СостояниеФоновогоЗадания.Активно Тогда 
			Активно = Истина; Прервать;
			
		КонецЕсли;	
		
	КонецЦикла;
	ФЗ = Неопределено;
	
	Если Не Активно Тогда 
		ФоновыеЗадания.Выполнить(
			"обм.Получение_ОбработатьОчередь", // ИмяМетода
			Новый Массив, // Параметры
			Ключ, // Ключ
			Наименование // Наименование
			);
		
	КонецЕсли;	
	 	 	
КонецПроцедуры	

// Обертка функций модуля менеджера справочника обм_ВходящиеСообщения, 
// чтобы их можно было вызывать с клиента 
#Область ВходящиеСообщения_ИнтерфейсДляКлиента

Функция ВходящееСообщение_Параметр_Значение_Получить(пВходящееСообщениеСсылка, КлючПараметра) Экспорт
	
	Возврат Справочники.обм_ВходящиеСообщения.Параметр_Значение_Получить(пВходящееСообщениеСсылка, КлючПараметра);
	
КонецФункции  

Функция ВходящееСообщение_ПолучитьСсылкуИзHTTPСервисОтвет(пHTTPОтветОЗаписиЗапроса) Экспорт

	#Если ВнешнееСоединение Тогда
		Возврат Неопределено;
		
	#Иначе
		общ.Проверка_Тип(пHTTPОтветОЗаписиЗапроса, Тип("HTTPСервисОтвет"));
		
	#КонецЕсли
	
	Если пHTTPОтветОЗаписиЗапроса.КодСостояния <> 200 Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Тело ответа содержит:
		//ТекстОтвета = 
		//	СтрШаблон(
		//		"{""Status"":""RequestReceived"",
		//		|""Tiket"":""%1""
		//		|}",
		//		Строка(ВходящийЗапрос_Объект.Ссылка.УникальныйИдентификатор())
		//		);
	// см. функцию Запрос_Записать
	
	стрОтвет = пHTTPОтветОЗаписиЗапроса.ПолучитьТелоКакСтроку();
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		соотвРезультат = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Если ТипЗнч(соотвРезультат) <> Тип("Соответствие") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	стрИД = соотвРезультат["Tiket"];
	
	Если стрИД = Неопределено Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Справочники.обм_ВходящиеСообщения.ПолучитьСсылку(Новый УникальныйИдентификатор(стрИД));
		
КонецФункции

Функция ВходящееСообщение_ПолучитьОшибкуИзHTTPСервисОтвет(пHTTPОтветОЗаписиЗапроса) Экспорт
	
	#Если ВнешнееСоединение Тогда
		Возврат Неопределено;
		
	#Иначе
		общ.Проверка_Тип(пHTTPОтветОЗаписиЗапроса, Тип("HTTPСервисОтвет"));
		
	#КонецЕсли
	
	// 200 значит нет ошибки
	Если пHTTPОтветОЗаписиЗапроса.КодСостояния = 200 Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Тело ответа содержит:
		//ТекстОтвета = 
			//СтрШаблон(
			//	"{""Error"":""%1""}",
			//	КраткоеПредставлениеОшибки(ИнформацияОбОшибке()) // %1
			//	);
	// см. функцию Запрос_Записать
	
	стрОтвет = пHTTPОтветОЗаписиЗапроса.ПолучитьТелоКакСтроку();
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(стрОтвет);
		соотвРезультат = ПрочитатьJSON(ЧтениеJSON, Истина); // Прочитать в соответствие
		ЧтениеJSON.Закрыть();
		
	Исключение
		Возврат Неопределено;
		
	КонецПопытки;
	
	Если ТипЗнч(соотвРезультат) <> Тип("Соответствие") Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	обОшибке = соотвРезультат["Error"];
	
	Если обОшибке = Неопределено Или ПустаяСтрока(обОшибке) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат обОшибке;
		
КонецФункции

Функция ВходящееСообщение_Создать(пHTTPСервисЗапрос, пНаименованиеЗапроса = Неопределено, пОбрабатыватьРегламентнымЗаданием = Истина) Экспорт 

	УстановитьПривилегированныйРежим(Истина);
	
	имяСобытия = ИмяСобытияЖурналаРегистрации("Получение.ВходящееСообщение_Создать");
	
	HTTPСервисЗапрос_ЗарегестрироватьВЖурнале(имяСобытия, пHTTPСервисЗапрос);
	
	КодОтвета = 400;
	ТекстОтвета = "";
	
	Попытка
		ВходящееСообщение_Объект = Справочники.обм_ВходящиеСообщения.СоздатьЭлемент();
		СсылкаНового = Справочники.обм_ВходящиеСообщения.ПолучитьСсылку();
		ВходящееСообщение_Объект.ДополнительныеСвойства.Вставить("СсылкаНового", СсылкаНового);
		ВходящееСообщение_Объект.УстановитьСсылкуНового(СсылкаНового);
				
		Если Не ПустаяСтрока(пНаименованиеЗапроса) Тогда
			ВходящееСообщение_Объект.Наименование = СокрЛП(пНаименованиеЗапроса);
			
		Иначе
			ВходящееСообщение_Объект.Наименование = Строка(ТипЗнч(пHTTPСервисЗапрос));
			
		КонецЕсли;
		ВходящееСообщение_Объект.Наименование = ВходящееСообщение_Объект.Наименование + " " + Строка(СсылкаНового.УникальныйИдентификатор());

		ВходящееСообщение_Объект.ДатаВремя = общ_Сервер.ТекущаяДатаНаСервере();
		ВходящееСообщение_Объект.Запрос = пHTTPСервисЗапрос.ПолучитьТелоКакСтроку();
		
		ЗаполнитьЗначенияСвойств(ВходящееСообщение_Объект, пHTTPСервисЗапрос);
		
		Для Каждого КлючИЗначение Из пHTTPСервисЗапрос.ПараметрыURL Цикл
			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = КлючИЗначение.Ключ;
			тчПараметры_Строка.Значение = КлючИЗначение.Значение;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.URL;
			
		КонецЦикла;
		КлючИЗначение = Неопределено;
		
		Для Каждого КлючИЗначение Из пHTTPСервисЗапрос.ПараметрыЗапроса Цикл
			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = КлючИЗначение.Ключ;
			тчПараметры_Строка.Значение = КлючИЗначение.Значение;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.Запрос;
			
		КонецЦикла;
		
		// Добавить текущего пользователя
		тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
		тчПараметры_Строка.Ключ = "ТекущийПользователь_Имя";
		тчПараметры_Строка.Значение = ТекущийПользователь_Имя();
		тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
		
		Если ТипЗнч(пНаименованиеЗапроса) = Тип("Строка") И ЗначениеЗаполнено(пНаименованиеЗапроса) Тогда
			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = "Метод";
			тчПараметры_Строка.Значение = пНаименованиеЗапроса;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
			
		ИначеЕсли ТипЗнч(пНаименованиеЗапроса) = Тип("Структура") Тогда
			Для Каждого Пара Из пНаименованиеЗапроса Цикл
				тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
				тчПараметры_Строка.Ключ = Пара.Ключ;
				тчПараметры_Строка.Значение = Пара.Значение;
				тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.КонтекстБД;
				
			КонецЦикла;
			Пара = Неопределено;
			
		КонецЕсли;

		Для Каждого КлючИЗначение Из пHTTPСервисЗапрос.Заголовки Цикл
			
			// Данные авторизации не фиксировать
			Если НРег(КлючИЗначение.Ключ) = "authorization" Тогда
				Продолжить;
				
			КонецЕсли;

			тчПараметры_Строка = ВходящееСообщение_Объект.Параметры.Добавить();
			тчПараметры_Строка.Ключ = КлючИЗначение.Ключ;
			тчПараметры_Строка.Значение = КлючИЗначение.Значение;
			тчПараметры_Строка.ИсточникПараметра = Перечисления.обм_ВходящиеСообщения_ИсточникиПараметров.ЗаголовокHTTP;
			
		КонецЦикла;
		КлючИЗначение = Неопределено; 

		// Чтобы запрос не обрабатывался регламентным заданием, пометить его на удаление
		// см. Получение_ОбработатьОчередь
		Если Не пОбрабатыватьРегламентнымЗаданием Тогда
			ВходящееСообщение_Объект.ПометкаУдаления = Истина;
			
		КонецЕсли;
		
		ВходящееСообщение_Объект.Параметры.Сортировать("Ключ");
		
		ВходящееСообщение_Объект.Записать();
		
		КодОтвета = 200;
		ТекстОтвета = 
			СтрШаблон(
				"{""Status"":""RequestReceived"",
				|""Tiket"":""%1""
				|}",
				Строка(ВходящееСообщение_Объект.Ссылка.УникальныйИдентификатор())
				);
		
	Исключение
		КодОтвета = 500;
		ТекстОтвета = 
			СтрШаблон(
				"{""Error"":""%1""}",
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке()) // %1
				);
		
		ЗаписьЖурналаРегистрации(
			ИмяСобытияЖурналаРегистрации("Получение.ВходящееСообщение_Создать"),
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.HTTPСервисы.обм, // Объект метаданных
			, // Данные
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			РежимТранзакцииЗаписиЖурналаРегистрации.Независимая
			);		
		
	КонецПопытки;
	
	#Если ВнешнееСоединение Тогда
		Ответ = ТекстОтвета;
		
	#Иначе
		Ответ = Новый HTTPСервисОтвет(КодОтвета);
		Ответ.Заголовки.Вставить("Content-Type","text/html; charset=utf-8");
		Ответ.УстановитьТелоИзСтроки(ТекстОтвета); 
		
	#КонецЕсли
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Ответ;
	
КонецФункции

Функция ВходящееСообщение_СоздатьЧерезHTTPЗапросЭмуляция(
		URI, пДанные, ПараметрыЗапроса = Неопределено, НаименованиеЗапроса = Неопределено, ОбрабатыватьСразу = Ложь) Экспорт
	
	общ.Проверка_Тип(ПараметрыЗапроса, "Структура, Соответствие, Неопределено");
	
	httpЗапросЭмуляция = Обработки.обм_HTTPЗапросЭмуляция.Создать();
	
	httpЗапросЭмуляция.HTTPМетод = "POST";
	
	httpЗапросЭмуляция.БазовыйURL = "emul://" + URI;
	httpЗапросЭмуляция.ОтносительныйURL = URI;

	Если ТипЗнч(пДанные) = Тип("Строка") Тогда
		httpЗапросЭмуляция.Тело = пДанные;
		
	ИначеЕсли ТипЗнч(пДанные) = Тип("ДвоичныеДанные") Тогда
		httpЗапросЭмуляция.Тело = Base64Строка(пДанные);

	ИначеЕсли ТипЗнч(пДанные) = Тип("Массив") Или ТипЗнч(пДанные) = Тип("Структура") Или ТипЗнч(пДанные) = Тип("Соответствие") Тогда
		httpЗапросЭмуляция.Тело = Общ.ЗначениеВJSON(пДанные);	
		
	Иначе
		httpЗапросЭмуляция.Тело = Строка(пДанные);
		
	КонецЕсли;

	Если ПараметрыЗапроса <> Неопределено Тогда
		Для Каждого Пара Из ПараметрыЗапроса Цикл
			httpЗапросЭмуляция.ПараметрыЗапроса.Вставить(Пара.Ключ, Пара.Значение);
			
		КонецЦикла;
		Пара = Неопределено;
		
	КонецЕсли;	

	// Для предотвращения конфликта между регламентым заданием и обработкой при загрузке пользователем из формы
	// Запретить обработку регламентным заданием
	ОбрабатыватьРегламентымЗаданием = Не ОбрабатыватьСразу;
	ответОЗаписиЗапроса = ВходящееСообщение_Создать(httpЗапросЭмуляция, НаименованиеЗапроса, ОбрабатыватьРегламентымЗаданием); 
	
	Если ответОЗаписиЗапроса.КодСостояния = 200 И ОбрабатыватьСразу Тогда
		
		входящееСообщениеСсылка = ВходящееСообщение_ПолучитьСсылкуИзHTTPСервисОтвет(ответОЗаписиЗапроса);
		
		Если ЗначениеЗаполнено(входящееСообщениеСсылка) Тогда
			обработчик = Обработки.обм_ВходящиеСообщения_Обработка.Создать();
			
			обработчик.ВходящиеСообщения_ДанныеЗаполнения_Создать(входящееСообщениеСсылка);
			
			обработчик.ВходящиеСообщения_ОбработатьДанныеЗаполнения(входящееСообщениеСсылка);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ОтветОЗаписиЗапроса
	
КонецФункции

#КонецОбласти // ВходящиеСообщения_ИнтерфейсДляКлиента

#Область ОбразВОбъект

Функция ОбразВОбъект(пУзелОтправитель, знач пОбразОбъекта, пПриемник = Неопределено,   пИмяФункцииВосстановления = Неопределено, пМодульФункцииВосстановления = Неопределено) Экспорт
	
	Если ТипЗнч(пОбразОбъекта) = Тип("Строка") И Не ПустаяСтрока(пОбразОбъекта) Тогда
		пОбразОбъекта = общ.UnJSON(пОбразОбъекта); 
		
	КонецЕсли;
	
	Если Не общ.ЭтоКоллекцияКлючЗначение(пОбразОбъекта) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	стрТипИсточника = Неопределено;
	Если Не Общ.Коллекция_Свойство(пОбразОбъекта, "_Тип", стрТипИсточника) Или ПустаяСтрока(стрТипИсточника) Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	типИсточника = Неопределено;
	Попытка
		типИсточника = Тип(стрТипИсточника);
	Исключение
		обОшибке = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если ТипЗнч(типИсточника) <> Тип("Тип") Тогда
		Возврат Неопределено;
		
	КонецЕсли;

	объектСсылкаДругое = общ.ОбъектСсылкаДругое(пПриемник);
	приемникСсылка = Неопределено;
	Если объектСсылкаДругое = "Объект" Тогда 
		приемникСсылка = пПриемник.Ссылка;
		
	ИначеЕсли объектСсылкаДругое = "Ссылка" И общ.ЭтоЗаполненнаяСсылка(пПриемник) Тогда
		приемникСсылка = пПриемник;
		
	ИначеЕсли объектСсылкаДругое = "Другое" Тогда
		// ссылку приемника попытаться получить из навигационной ссылки в коллекции
		приемникСсылка = Неопределено;  
		
	КонецЕсли;
		
	Если Общ.ЭтоЗаполненнаяСсылка(приемникСсылка) И общ.СсылкаСуществует(приемникСсылка) Тогда
		пПриемник = приемникСсылка.ПолучитьОбъект();
			
	Иначе
		менеджерПриемника = общ.Менеджер_Получить(типИсточника); 

		Если общ.Коллекция_Свойство(пОбразОбъекта, "_ЭтоГруппа") Тогда
			пПриемник = общ.Менеджер_СоздатьОбъект(менеджерПриемника, пОбразОбъекта["_ЭтоГруппа"]);
					
		Иначе
			пПриемник = общ.Менеджер_СоздатьОбъект(менеджерПриемника);
					
		КонецЕсли;
		
		приемникСсылка = общ.Менеджер_ПолучитьБитуюСсылку(менеджерПриемника, приемникСсылка);
				
		пПриемник.УстановитьСсылкуНового(приемникСсылка);

	КонецЕсли;

	объектСсылкаДругое = общ.ОбъектСсылкаДругое(пПриемник); 
	Если объектСсылкаДругое <> "Объект" Тогда
		Возврат Неопределено;
		
	КонецЕсли;
	
	пПриемник.ОбменДанными.Загрузка = Истина;

	Для Каждого пара Из пОбразОбъекта Цикл 
		
		этоТабличнаяЧасть = пПриемник.Метаданные().ТабличныеЧасти.Найти(пара.Ключ) <> Неопределено; 
		Если этоТабличнаяЧасть Тогда
			приемник_ТЧ = пПриемник[пара.Ключ];
			приемник_ТЧ.Очистить();
			Для Каждого образРядаТЧ Из пара.Значение Цикл
				рядПриемник = приемник_ТЧ.Добавить();
				Для Каждого параОбразаРяда Из образРядаТЧ Цикл
					ВосстановитьРеквизитОбъекта(пУзелОтправитель, рядПриемник, параОбразаРяда.Ключ, параОбразаРяда.Значение, пИмяФункцииВосстановления, пМодульФункцииВосстановления);
					
				КонецЦикла;
				параОбразаРяда = Неопределено;
				
			КонецЦикла;
			образРядаТЧ = Неопределено; 
			
		// Обычный реквизит, не табличная часть
		Иначе
			ВосстановитьРеквизитОбъекта(пУзелОтправитель, пПриемник, пара.Ключ, пара.Значение, пИмяФункцииВосстановления, пМодульФункцииВосстановления);
			
		КонецЕсли; 
		
	КонецЦикла;
	пара = Неопределено;
		
	Возврат пПриемник;

КонецФункции // ОбразВОбъект  

Процедура ВосстановитьРеквизитОбъекта(пУзел, пОбъект, Знач пКлюч, пОбразЗначения, пИмяФункцииВосстановления = Неопределено, пМодульФункцииВосстановления = Неопределено)

	Если Не общ.ЕстьРеквизитИлиСвойствоОбъекта(пОбъект, пКлюч) Тогда
		Возврат;
		
	КонецЕсли; 
	
	// 1. Сначала попробовать использовать функцию восстановления
	результатВосстановления = Ложь;
	восстановленноеЗначение = Неопределено;
	Если пИмяФункцииВосстановления <> Неопределено И пМодульФункцииВосстановления <> Неопределено Тогда
		Попытка
			Выполнить(
				СтрШаблон(
					"результатВосстановления = пМодульФункцииВосстановления.%1(пУзел, восстановленноеЗначение, пОбразЗначения);",
					пИмяФункцииВосстановления // %1
					)
				);
				
			Если Общ.Проверка_Тип(результатВосстановления, "Булево", Ложь) <> "" Тогда
				результатВосстановления = Ложь;
				
			КонецЕсли;  
			
		Исключение
			// Для отладки 
			обОшибке = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			результатВосстановления = Ложь; 
			
		КонецПопытки;	
		
		Если результатВосстановления Тогда 
			пОбъект[пКлюч] = восстановленноеЗначение;
			Возврат;
			
		КонецЕсли; 

	КонецЕсли; // Если пИмяФункцииВосстановления <> Неопределено

	// 2. Восстановление ссылочных данных
	Если общ.Коллекция_ЭтоОбразСсылки(пОбразЗначения) Тогда
		пОбъект[пКлюч] =  общ.КоллекцияВСсылку(пОбразЗначения);
		Возврат;
			
	КонецЕсли;	
	
	// 3. Значения примитивных типов просто присвоить
	Попытка
		типРеквизитаОбъекта = ТипЗнч(пОбъект[пКлюч]);
		Если типРеквизитаОбъекта = Тип("Дата") Тогда
			Если Не ПустаяСтрока(пОбразЗначения) Тогда
				пОбъект[пКлюч] = XMLЗначение(Тип("Дата"), пОбразЗначения);
				
			КонецЕсли;
			
		Иначе	
			пОбъект[пКлюч] = пОбразЗначения;
			
		КонецЕсли; 
		Возврат;
		
	Исключение
		// для отладки
		обОШибке = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;	

КонецПроцедуры  

#КонецОбласти // ОбразВОбъект

#КонецОбласти // Получение 

#Область ПодпискиНаСобытия

Процедура ПриЗаписи(пИсточник, пОтказ = Ложь) Экспорт 
	
	// Для контекстной подсказки 
	Если Ложь Тогда
		пИсточник = Справочники.общ_Обработчики.СоздатьЭлемент();
		
	КонецЕсли;
	
	#Область обм_РегистрацияИзмененных
	необходимаРегистрацияИзменения = Ложь; 
	
	// Обрабтчик передаем в привелигированный модуль по имени
	// т.к. у пользователя может не быть прав на Справочник.Общ_Обработчики
	имяОбработчика = "";
	
	// Запись через подсистему общ.обм. 
	// см. Обработка.обм_ВходящиеСообщения_Обработка.Приемник_Записать
	Если Общ.Коллекция_Свойство(пИсточник.ДополнительныеСвойства, "УзелОтправитель") Тогда
		имяОбработчика = "обм_Измененные_РегистрироватьПриПоступленииПоОбмену";
		
	// Прочие обмены, не из подсистемы обм
	// Пока не обрабатывать, необходимо проектирование
	ИначеЕсли пИсточник.ОбменДанными.Загрузка Тогда
		// @TODO. Необходимо спроектировать
		
	// Обычная запись измененного объекта
	ИначеЕсли Не пИсточник.ОбменДанными.Загрузка Тогда
		имяОбработчика = "обм_Измененные_РегистрироватьПриЗаписи"; 
		
	КонецЕсли; 

	Если Не ПустаяСтрока(имяОбработчика) Тогда
		// В скрипты передаем не сам объект, а ссылку на него
		// Так надо, чтобы в скрипте было невозможно изменить объект или его свойства
		источникСсылка = общ.Ссылка_Получить(пИсточник);
		
		// Дополнительные свойства объекта копируем в структуру и помещаем в параметры
		структураПараметров = Новый Структура;
		структураПараметров.Вставить("ДополнительныеСвойства", Новый Структура);
		
		Для Каждого пара из пИсточник.ДополнительныеСвойства Цикл
			структураПараметров.ДополнительныеСвойства.Вставить(пара.Ключ, пара.Значение);
			
		КонецЦикла;
		пара = Неопределено;
		
		необходимаРегистрацияИзменения = общ_адм.ВыполнитьОбработчик(имяОбработчика, источникСсылка, структураПараметров);
		
	КонецЕсли;

	// Иногда необходимо при записи объекта зарегистрировать к обмену другие объекты
	// Тогда скрипт может вернуть массив ссылок, которые необходимо зарегистрировать
	Если ТипЗнч(необходимаРегистрацияИзменения) = Тип("Массив") Тогда
		Для Каждого элементМассива Из необходимаРегистрацияИзменения Цикл 
			Если Не общ.ЭтоЗаполненнаяСсылка(элементМассива) Тогда
				Продолжить;
				
			КонецЕсли;
			
			РегистрыСведений.обм_Измененные.Зарегистрировать(элементМассива, пИсточник.ДополнительныеСвойства);
			
		КонецЦикла;
		элементМассива = Неопределено;

	ИначеЕсли необходимаРегистрацияИзменения = Истина Тогда
		РегистрыСведений.обм_Измененные.Зарегистрировать(пИсточник);
		
	КонецЕсли;

	#КонецОбласти // обм_РегистрацияИзмененных
	
КонецПроцедуры

#КонецОбласти // Подписки на события

#Область Прочее

Функция HTTPСервисЗапрос_ЗарегестрироватьВЖурнале(пИмяСобытия, пHTTPСервисЗапрос) Экспорт

	Если ТипЗнч(пHTTPСервисЗапрос) <> Тип("HTTPСервисЗапрос") Тогда
		Возврат Неопределено; 
		
	КонецЕсли;	
	
	Результат = "";
	   
	Результат = Результат + пHTTPСервисЗапрос.HTTPМетод + Символы.ПС;
	Результат = Результат + пHTTPСервисЗапрос.БазовыйURL + Символы.ПС;
	Результат = Результат + пHTTPСервисЗапрос.ОтносительныйURL + Символы.ПС;
	Результат = Результат + "Заголовки:" + Символы.ПС;
	Для каждого Параметр Из пHTTPСервисЗапрос.Заголовки Цикл
		
		// Данные авторизации не фиксировать
		Если НРег(Параметр.Ключ) = "authorization" Тогда
			Продолжить;
			
		КонецЕсли;
		
		Заг =   СтрЗаменить( Параметр.Значение,";","");
	    Результат = Результат + Параметр.Ключ + ":" + Заг+ Символы.ПС;
	КонецЦикла;
	Результат = Результат + "Параметры URL:" + Символы.ПС;
	Для каждого Параметр Из пHTTPСервисЗапрос.ПараметрыURL Цикл
	    Результат = Результат + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;
	Результат = Результат + "Параметры запроса:" + Символы.ПС;
	Для каждого Параметр Из пHTTPСервисЗапрос.ПараметрыЗапроса Цикл
	    Результат = Результат + Параметр.Ключ + ":" + Параметр.Значение + Символы.ПС;
	КонецЦикла;
	
	Результат = Результат + "BODY:" +пHTTPСервисЗапрос.ПолучитьТелоКакСтроку()+ Символы.ПС; 
	 
	ЗаписьЖурналаРегистрации(пИмяСобытия,,,,Результат);

КонецФункции	

Функция ИмяСобытияЖурналаРегистрации(пИмяСобытия = "") Экспорт
	
	результат = "обм";
	
	Если Не ПустаяСтрока(пИмяСобытия) Тогда
		результат = результат + "." + СокрЛП(пИмяСобытия);
		
	КонецЕсли;
	
	Возврат результат;
	
КонецФункции

// Выполняет создание экземпляра внешней обработки (отчета)
// Параметры
//  ВнешняяОбработкаСсылка - СправочникСсылка.ДополнительныеОтчетыИОбработки
//  БезопасныйРежим - Булево - требуется ли запускать обработку в безопасном режиме
// Возвращаемое значение
//  строка - имя обработки известное системе
//
Функция ОбработчикОбъект(пВнешняяОбработкаСсылка, пБезопасныйРежим) Экспорт 
	
	УстановитьПривилегированныйРежим(Истина);
	
		Если Истина Тогда
			ВнешняяОбработкаОбъект = пВнешняяОбработкаСсылка.ПолучитьОбъект(); 
			
		// Для отладки
		Иначе
			ВнешняяОбработкаОбъект = Справочники.ДополнительныеОтчетыИОбработки.СоздатьЭлемент();
			
		КонецЕсли;
		
		// Попробовать из комментария достать путь к файлу для отладки
		имяФайлаОтладки = Неопределено;
		Если Не ПустаяСтрока(ВнешняяОбработкаОбъект.Комментарий) Тогда
			файлОтладки = Новый Файл(ВнешняяОбработкаОбъект.Комментарий);
			Если файлОтладки.Существует() Тогда
				имяФайлаОтладки = ВнешняяОбработкаОбъект.Комментарий;
				
			КонецЕсли;				
			
		КонецЕсли;
		
		имяФайлаОбработки = ПолучитьИмяВременногоФайла("epf");
		Если Не ПустаяСтрока(имяФайлаОтладки) Тогда
			имяФайлаОбработки = имяФайлаОтладки;
			
		Иначе		
			ДвоичныеДанныеОбработки = ВнешняяОбработкаОбъект.ХранилищеОбработки.Получить();
			ДвоичныеДанныеОбработки.Записать(имяФайлаОбработки);
			
		КонецЕсли;
		
		текущийБезопасныйРежим = БезопасныйРежим();
		Если текущийБезопасныйРежим <> Ложь Тогда
			УстановитьОтключениеБезопасногоРежима(Истина);
				
		КонецЕсли;
			
		безЗащиты = Новый ОписаниеЗащитыОтОпасныхДействий;
		безЗащиты.ПредупреждатьОбОпасныхДействиях = Ложь;
		
		Если ВнешняяОбработкаОбъект.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет
		 ИЛИ ВнешняяОбработкаОбъект.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
			Возврат ВнешниеОтчеты.Создать(имяФайлаОбработки, пБезопасныйРежим, безЗащиты);
			
		Иначе
			Возврат ВнешниеОбработки.Создать(имяФайлаОбработки, пБезопасныйРежим, безЗащиты);
			
		КонецЕсли;
	
		Если текущийБезопасныйРежим <> БезопасныйРежим() Тогда 
			Если текущийБезопасныйРежим <> Ложь Тогда
				УстановитьОтключениеБезопасногоРежима(Ложь);

			КонецЕсли;
			
		КонецЕсли;   
		
	УстановитьПривилегированныйРежим(Ложь);
	
КонецФункции

Функция ОбработчикОдиночка(пВнешняяОбработкаСсылка, пБезопасныйРежим, пВерсияДанных = Неопределено) Экспорт
	
	общ.Проверка_Тип(пВнешняяОбработкаСсылка, Тип("СправочникСсылка.общ_Обработчики")); 
	
	// @TODO 250630 Заяш: Переписать отладку на использование параметра сеанса
	// Попробовать из комментария достать путь к файлу для отладки
		имяФайлаОтладки = Неопределено;
		Если Не ПустаяСтрока(пВнешняяОбработкаСсылка.Комментарий) Тогда
			файлОтладки = Новый Файл(пВнешняяОбработкаСсылка.Комментарий);
			Если файлОтладки.Существует() Тогда
				имяФайлаОтладки = пВнешняяОбработкаСсылка.Комментарий;
				
			КонецЕсли;				
			
		КонецЕсли; 
		
		Если имяФайлаОтладки <> Неопределено Тогда
			обработчикОбъект = обм.ОбработчикОбъект(пВнешняяОбработкаСсылка, пБезопасныйРежим); 
			Возврат обработчикОбъект;
			
		КонецЕсли; 
	
	Если пВерсияДанных = Неопределено Тогда
		пВерсияДанных = пВнешняяОбработкаСсылка.ВерсияДанных; 
		
	КонецЕсли;
	
	обработчикОбъект = общ_Кэш.ОбработчикОдиночка(пВнешняяОбработкаСсылка, пБезопасныйРежим, пВерсияДанных);
	
	Возврат обработчикОбъект;

КонецФункции

Функция ТекущийПользователь_Имя() Экспорт
	
	//@TODO 20230515 Заяш: Реализовать получение имени текущего пользователя через обработчик/скрипт
	
	// Если не найдено, возвращать текущего пользователя ИБ
	Возврат ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
	
КонецФункции

#КонецОбласти // Прочее

#КонецОбласти // ВнешнийИнтерфейс  


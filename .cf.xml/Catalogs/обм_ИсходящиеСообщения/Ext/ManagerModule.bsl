#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

// Регистрирует исходящее сообщение к отправке
// например, если его надо отправить повторно
//
// Параметры:
//  пИсходящиеСообщения	 - СправочникСсылка.обм_ИсходящиеСообщения
//
Процедура ЗарегистрироватьКОтправке(пИсходящиеСообщения) Экспорт

	исходящиеСообщения = общ.Массив_ПоЗначению(пИсходящиеСообщения, Тип("СправочникСсылка.обм_ИсходящиеСообщения"));
	
	запрос = Новый Запрос;
	запрос.УстановитьПараметр("исходящиеСообщения", исходящиеСообщения);
	запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
		|	ИС.Ссылка КАК ИсходящееСообщение,
		|	ИС.ДатаВремя КАК ДатаВремя,
		|	ИС.ОбработчикОтправки КАК ОбработчикОтправки,
		|	ИСП.Узел КАК Узел
		|ИЗ
		|	Справочник.обм_ИсходящиеСообщения КАК ИС
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.обм_ИсходящиеСообщения.Получатели КАК ИСП
		|		ПО ИС.Ссылка = ИСП.Ссылка
		|			И (ИСП.Узел <> """")
		|			И ИС.УзелОтправительИсточника <> ИСП.Узел
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.общ_Обработчики КАК Обработчики
		|		ПО ИС.ОбработчикОтправки = Обработчики.Ссылка
		|ГДЕ
		|	ИС.Ссылка В(&исходящиеСообщения)
		|
		|УПОРЯДОЧИТЬ ПО
		|	ИС.ДатаВремя";
	
	выборка = запрос.Выполнить().Выбрать();
	
	Пока выборка.Следующий() Цикл
		РегистрыСведений.обм_КОтправке.Зарегистрировать(выборка.ИсходящееСообщение, выборка.Узел, выборка.ОбработчикОтправки);
		
	КонецЦикла;
	выборка = Неопределено;
	
КонецПроцедуры

// Конструктор нового объекта.
// Чтобы не напутать с заполнением
//
// Параметры:
//  пИсточник			 - произвольный - источник исходящего сообщения;
//  пТекстСообщения		 - строка - текст для отправки получателю;
//  пУзлыПолучатели		 - строка - имена узлов-получателей, разделенных строкой;
//  пОбработчикОтправки	 - см. Справочники.общ_Обработчики.НайтиСсылку - кто должен отправить сообщение;
//
// Возвращаемое значение:
// 	СправочникОбъект.обм_ИсходящиеСообщения
//
Функция Конструктор(пИсточник, пТекстСообщения, пУзлыПолучатели, пОбработчикОтправки = Неопределено) Экспорт
	
	исходящее = Справочники.обм_ИсходящиеСообщения.СоздатьЭлемент();
	
	исходящее.Конструктор(пИсточник, пТекстСообщения, пУзлыПолучатели, пОбработчикОтправки);
	
	Возврат исходящее;
	
КонецФункции

// Создание и регистрация к отправке произвольного сообщения
// Создает исходящее сообщение и регистрирует его к отправке
//
// Параметры:
//  пИсточник			 - произвольный - источник исходящего сообщения;
//  пТекстСообщения		 - строка - текст для отправки получателю;
//  пУзлыПолучатели		 - строка - имена узлов-получателей, разделенных строкой;
//  пОбработчикОтправки	 - СправочникСсылка.общ_Обработчики - кто должен отправить сообщение;
//
// Возвращаемое значение:
//  СправочникСсылка.обм_ИсходящиеСообщения
//
Функция Создать(пИсточник, пТекстСообщения, пУзлыПолучатели, пОбработчикОтправки) Экспорт
	
	общ.Проверка_Тип(пОбработчикОтправки, Тип("СправочникСсылка.общ_Обработчики"));
	
	НачатьТранзакцию();
	Попытка
		исходящее = Конструктор(пИсточник, пТекстСообщения, пУзлыПолучатели, пОбработчикОтправки);
		исходящее.Записать();
		ЗарегистрироватьКОтправке(исходящее.Ссылка);
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		имяСобытия = обм.ИмяСобытияЖурналаРегистрации("Отправка.ИсходящиеСообщения.Создать");
		инфоОшибки = ИнформацияОбОшибке();
		ссылкиДанных = Новый Массив;
		ссылкиДанных.Добавить(пИсточник);
		ссылкиДанных.Добавить(Справочники.общ_Обработчики.НайтиСсылку(пОбработчикОтправки));
		общ.Ошибка_ВЖурналРегистрации(имяСобытия, инфоОшибки, ссылкиДанных);
		
		ВызватьИсключение;
		
	КонецПопытки;
	
	Возврат исходящее.Ссылка;
	
КонецФункции

// Создание исходящего сообщения по ссылке источника
// с помощью переопределяемых обработчиков (см. Справочник.общ_Обработчики)
//
// Параметры:
//  пИсточникСсылка				 - ЛюбаяСсылка - Источник данных сообщения
//  пУзелОтправительИсточника	 - Строка - Отправитель сообщения, изменившего источник
//
// Возвращаемое значение:
//  Массив - ссылки созданных сообщений, Тип("СправочникСсылка.обм_ИсходящиеСообщения")
//
Функция СоздатьПоСсылкеИсточника(пИсточникСсылка, пУзелОтправительИсточника = Неопределено) Экспорт
	
	// Попытка для расширенной фиксации ошибок в привязке к нескольким объектам
	НачатьТранзакцию();
	Попытка
		исходящиеСообщения = Новый Массив;
		Если НЕ общ.ЭтоЗаполненнаяСсылка(пИсточникСсылка) Тогда
			Возврат исходящиеСообщения;
			
		КонецЕсли;
		
		интерфейс = Обработки.обм_ИнтерфейсОбработчиков_ИсходящиеСообщения.Создать();
		реализацииИнтерфейса = общ.Интерфейс_НайтиРеализации(интерфейс);
		
		Если реализацииИнтерфейса.Количество() = 0 Тогда
			Возврат исходящиеСообщения;
			
		КонецЕсли;
		
		Для Каждого обработчик Из реализацииИнтерфейса Цикл
			общ.Интерфейс_УстановитьРеализацию(интерфейс, обработчик);
			исходящие = интерфейс.ИсходящееСообщение_Создать(пИсточникСсылка, пУзелОтправительИсточника);
			
			Если исходящие = Неопределено Тогда
				Продолжить;
				
			КонецЕсли;
			
			Для Каждого исходящееОбъект Из исходящие Цикл
				исходящееОбъект.Конструктор(пИсточникСсылка, , обработчик); // Заполнение незаполненных реквизитов исходящего
				исходящееОбъект.УзелОтправительИсточника = пУзелОтправительИсточника;
				исходящееОбъект.Записать();
				исходящиеСообщения.Добавить(исходящееОбъект.Ссылка);
				
			КонецЦикла;
			исходящееОбъект = Неопределено;
			
		КонецЦикла;
		обработчик = Неопределено;
		
		Справочники.обм_ИсходящиеСообщения.ЗарегистрироватьКОтправке(исходящиеСообщения);
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		имяСобытия = обм.ИмяСобытияЖурналаРегистрации("Отправка.ИсходящиеСообщения.СоздатьПоСсылкеИсточника");
		инфоОшибки = ИнформацияОбОшибке();
		ссылкиДанных = Новый Массив;
		ссылкиДанных.Добавить(пИсточникСсылка);
		ссылкиДанных.Добавить(Справочники.общ_Обработчики.НайтиСсылку(обработчик));
		общ.Ошибка_ВЖурналРегистрации(имяСобытия, инфоОшибки, ссылкиДанных);
		
		ВызватьИсключение;
		
	КонецПопытки;
	
	Возврат исходящиеСообщения;
	
КонецФункции

#КонецОбласти // ПрограммныйИнтерфейс

#КонецЕсли // Если Сервер и тп